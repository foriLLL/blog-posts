## 494. 目标和
### 题目　　

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

* 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

提示：  
* 1 <= nums.length <= 20
* 0 <= nums[i] <= 1000
* 0 <= sum(nums[i]) <= 1000
* -1000 <= target <= 100


### 思路：
####　方法一：回溯
这里我列出题目中的提示，重点是想说明题目要求的范围并不大，一共不超过20个数，所有数都是非负数且总和也没有超过1000，通过这样的提示，我们可以想到通过回溯解决问题，因为回溯的时间复杂度是 $O(2^n)$ ，所以只有在明确了题目中数字不会太大之后，我们才能考虑使用回溯方法。

如果考虑使用回溯，那么这个题的思路就很明确了，定义出口是到了最后一个数字之后，否则分别考虑加减当前数字。

```cpp
class Solution {
    int res = 0;
    void bt(vector<int>& v, int index, int target, int curr){
        int len = v.size();
        if(index==len){ //出口
            if(curr == target) res++;
            return;
        }
        
        bt(v, index+1, target, curr+v[index]);
        bt(v, index+1, target, curr-v[index]);
    }
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        bt(nums, 0, target, 0);
        return res;
    }
};
```

#### 方法二：动态规划
同样因为这个题目中要求的范围很小，我们可以考虑通过动态规划解题，$dp[i][j]$表示通过前$i$个数可以得到$j$的方案数量，由此，答案所求即为$dp[n][target]$，状态转移方程为：  
$$
dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]
$$
不过这里需要考虑的是，对每一个$i$，要检查**所有的** $j$，判断对 $i-1$ 得到的结果中能否得到$j-nums[i]$或是$j+nums[i]$，还要判断加减当前数字是否为越界。我们可以将状态转换方程，判断 $i-1$ 得到的结果中，不为一的数将他加减当前的数字。  

另外要注意的是虽然总和不超过1000，但要考虑到如果全部是负号，会有-1000，所以需要开2001个空间加以映射。
```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int* dp = new int[2001];//+1000
        memset(dp, 0, 2001*sizeof(int));
        int init = nums[0];
        dp[init+1000] +=1;
        dp[-init+1000] +=1;
        int len = nums.size();
        for(int i = 1;i<len;i++){
            int* next = new int[2001];
            memset(next, 0, 2001*sizeof(int));
            for(int j = -1000;j<1001;j++){
                if(dp[j+1000]>0){
                    printf("dp[0][%d]>0\n",j+1000);
                    next[j-nums[i]+1000] += dp[j+1000];
                    next[j+nums[i]+1000] += dp[j+1000];
                }
            }
            delete[] dp;
            dp = next;
        }
        return dp[target+1000];
    }
};
```