-- MySQL dump 10.13  Distrib 8.0.31, for Linux (x86_64)
--
-- Host: localhost    Database: foril_blog
-- ------------------------------------------------------
-- Server version	8.0.31

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `foril_blog`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `foril_blog` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `foril_blog`;

--
-- Table structure for table `about`
--

DROP TABLE IF EXISTS `about`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `about` (
  `content` text
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `about`
--

LOCK TABLES `about` WRITE;
/*!40000 ALTER TABLE `about` DISABLE KEYS */;
INSERT INTO `about` VALUES ('# About🗿\r\n<hr />\r\n\r\n## 关于我🚀\r\n\r\n* 👨‍💻本科：大连理工大学软件工程-大数据技术与应用\r\n* 📚在读：南京大学-计算机科学与技术系\r\n* 喜欢音乐🎶、电影📽、摄影📷\r\n\r\n## 联系方式🤙\r\n* 💬QQ：1571825323\r\n* 📧邮箱：  <a href=\"mailto:1571825323@qq.com\" title=\"邮件\">点击发送邮件</a>  \r\n* <a target=\"_blank\" rel=\"noopener noreferrer\" href=\'https://gitee.com/foril\' title=\"gitee\">gitee</a>\r\n* <a target=\"_blank\" rel=\"noopener noreferrer\" href=\'https://github.com/foriLLL\' title=\"github\">github</a>\r\n\r\n## 有关本站🌐\r\n\r\n本站建立于2021年4月，前后端均由个人独立开发，用于分享记录我在学习过程中所想所得，以便日后复习回顾查看，不保证内容正确性。所有内容由个人维护，如有疑问，请及时联系。欢迎志同道合的小伙伴随时跟我联系！  \r\n\r\n* 本站内容只代表个人观点\r\n* 部分内容、图片来源网络，如有侵权，决非恶意，请联系删除\r\n* 如内容有误，欢迎及时联系向我反馈  \r\n\r\n### 开发技术栈🛠  \r\n|网站部分  |所用技术栈  |  \r\n|:-----:|:----:|\r\n|前端  |React.js + TypeScript |  \r\n|部分组件  |antDesign  |  \r\n|内容编写  |markdown + LaTeX |  \r\n|后端  |express + mysql  |  \r\n\r\n> 向光生长  \r\n> Forever, foriL  \r\n');
/*!40000 ALTER TABLE `about` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `articleID` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `cateID` int NOT NULL,
  `time` timestamp NOT NULL,
  `views` int NOT NULL DEFAULT '0',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
  PRIMARY KEY (`articleID`),
  UNIQUE KEY `article_title_uindex` (`title`)
) ENGINE=InnoDB AUTO_INCREMENT=251 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (7,'力扣刷题笔记（一）',1,'2021-04-24 12:02:08',232,'决定用leetcode刷刷算法题，有些题写完后有些个人的理解和想法在当时顺便写下，便有了这篇笔记。  \n## 1 两数之和  \n### 题目  \n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n你可以按任意顺序返回答案。\n\n### **思路：**  \n这个题最简单的思路就是遍历，通过一个复杂度为N²的遍历，但要注意每次遍历只需要从选定的下标的下一个开始寻找，因为之前的都已经尝试过，不需要再次验证。  \n第二种解法始于对于N²的复杂度的优化，这时可以利用哈希表，快速的找到是否存在对应的下标变量  \n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n    for (int i = 0; i < nums.length; ++i) {\n        if (hashtable.containsKey(target - nums[i])) {\n            return new int[]{hashtable.get(target - nums[i]), i};\n        }\n        hashtable.put(nums[i], i);\n    }\n    return new int[0];\n    }\n```\n这样我们创建一个哈希表，对于每一个 x，我们**首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中**，即可保证不会让 x 和自己匹配。  \n***  \n\n## 21 合并两个有序链表\n### 题目   \n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n![题图](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg )  \n\n其思路类似于大小个两排排队，每次两排中大个先出列，一排为空时直接接上另一排，可使用递归的思想解决问题。  \n```java\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    //判断是否有一队为空\n    if (l1 == null) {   \n        return l2;\n    } else if (l2 == null) {\n        return l1;\n    } else if (l1.val < l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2;\n    }\n\n}\n```  \n---  \n## 705 设计哈希集合\n### 题目  \n \n不使用任何内建的哈希表库设计一个哈希集合（HashSet）。\n\n实现 MyHashSet 类：\n\n* void add(key) 向哈希集合中插入值 key 。\n* bool contains(key) 返回哈希集合中是否存在这个值 key 。\n* void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  \n\n\n### **思路：**  \n要解决这个题目的前提是明白哈希是什么，以我的理解就是很多个桶，拿到值后先算出hash值，然后就知道要放进哪个桶里，有这个理解后，就可以写出初步题解。  \n**链地址法**   \n\n![思路图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzA1LzcwNV9saW5rZWRfbGlzdC5wbmc?x-oss-process=image/format,png)  \n\n```java\nclass MyHashSet {\n	private static final int BASE = 769;\n	private LinkedList<Integer>[] list;\n\n	public MyHashSet() {\n		// 初始化\n		list = new LinkedList[BASE];\n		for (int i = 0; i < BASE; i++) {\n			list[i] = new LinkedList<Integer>();\n		}\n	}\n\n	public void add(int key) {\n		int hash = hash(key);\n		if (!list[hash].contains(key)) {\n			list[hash].push(key);\n		}\n	}\n\n	public void remove(int key) {\n		int hash = hash(key);\n		if (list[hash].contains(key)) {\n			list[hash].remove((Integer) key);\n		}\n	}\n\n	public boolean contains(int key) {\n		int hash = hash(key);\n		return list[hash].contains(key);\n	}\n\n	private static int hash(int key) {\n		return key % BASE;\n	}\n}\n```  \n需要注意这里相当于取了769个桶，这是一个素数，取这个数的原因是利用了同余的概念：当元素是个有规律的等差数列时，并且和基数（数组大小）最大公约数不为1时，就会造成哈希映射时冲突变高（数组某些位置永远不会有值）。  \n比如数列0,6,12,18,24,30...，base为10，取模(0,6,2,8,4,0...)后，放入哈希表中位置将只能在0,2,4,6,8这几个数组位置上；\n但我们如果把base取7（数组大小甚至比10小），同样数列取模后(0,6,5,4,3,2,1,0,...)，可以分布在哈希表中的0,1,2,3,4,5,6所有位置上；  \n### 改进\n有了初步的思路以后，想要改进就要考虑如果大量值的hash值重复，会造成一个桶里东西太多，到头还还是等同于遍历，可以优化哈希算法，包括开放地址法、再哈希法等等。\n\n*** \n\n## 706 设计哈希映射\n### 题目\n不使用任何内建的哈希表库设计一个哈希映射（HashMap）。\n\n实现 MyHashMap 类。  \n\n### **思路：**  \n这题与705相差不多，代码热热还能用。  \n上代码\n```java\nclass MyHashMap {\n\n	class Pair {\n		private int key;\n		private int value;\n\n		public Pair(int key, int value) {\n			this.key = key;\n			this.value = value;\n		}\n\n		public int getKey() {\n			return this.key;\n		}\n\n		public void setValue(int value) {\n			this.value = value;\n		}\n	}\n\n	private LinkedList[] list;\n	private static final int BASE = 769;\n\n	public MyHashMap() {\n		list = new LinkedList[BASE];\n		for (int i = 0; i < BASE; i++) {\n			list[i] = new LinkedList<Pair>();\n		}\n	}\n\n	public void put(int key, int value) {\n		int hash = hash(key);\n		Iterator<Pair> it = list[hash].iterator();\n		while (it.hasNext()) {\n			Pair existed = it.next();\n			if (existed.getKey() == key) {\n				existed.setValue(value);\n				return;\n			}\n		}\n		list[hash].add(new Pair(key, value));\n	}\n\n	public int get(int key) {\n		int hash = hash(key);\n		Iterator<Pair> it = list[hash].iterator();\n		while (it.hasNext()) {\n			Pair existed = it.next();\n			if (existed.getKey() == key) {\n				return existed.value;\n			}\n		}\n		return -1;\n	}\n\n	public void remove(int key) {\n		int hash = hash(key);\n		Iterator<Pair> it = list[hash].iterator();\n		while (it.hasNext()) {\n			Pair existed = it.next();\n			if (existed.getKey() == key) {\n				list[hash].remove(existed);\n                return;\n			}\n		}\n	}\n\n	private static int hash(int key) {\n		return key % BASE;\n	}\n}\n```\n\n## 54 螺旋矩阵\n### 题目：  \n给你一个 `m` 行 `n` 列的矩阵 matrix ，请按照**顺时针螺旋顺序** ，返回矩阵中的所有元素。\n\n### **思路：** \n第一次拿到这个题我的想法是循环套循环，外层循环判断是否上下左右可以前进，内层循环按照先向右走到头，下、左、上同理的顺序来保证顺时针螺旋顺序，这里用一个boolean列表用来记录是否走过对应的格子\n\n```java\n	private boolean[][] printed;\n	private int rowNow = 0, colNow = 0;\n\n    //判断是否能向对应方向走\n	private boolean up() {\n		if (rowNow == 0)\n			return false;\n		if (!printed[rowNow - 1][colNow])\n			return true;\n		return false;\n	}\n\n	private boolean down() {\n		if (rowNow == printed.length - 1)\n			return false;\n		if (!printed[rowNow + 1][colNow])\n			return true;\n		return false;\n	}\n\n	private boolean left() {\n		if (colNow == 0)\n			return false;\n		if (!printed[rowNow][colNow - 1])\n			return true;\n		return false;\n	}\n\n	private boolean right() {\n		if (colNow == printed[0].length - 1)\n			return false;\n		if (!printed[rowNow][colNow + 1])\n			return true;\n		return false;\n	}\n\n	public List<Integer> spiralOrder(int[][] matrix) {\n		List<Integer> list = new ArrayList<Integer>();\n		int rows = matrix.length;\n		int cols = matrix[0].length;\n		printed = new boolean[rows][cols]; // 初始化都为false\n		list.add(matrix[rowNow][colNow]); // 第一个\n		printed[rowNow][colNow] = true;\n\n		while (right()) {\n			// 有路可走\n			while (right()) {\n				// 能向右走\n				colNow++;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n\n			while (down()) {\n				// 能向下走\n				rowNow++;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n\n			while (left()) {\n				// 能向左走\n				colNow--;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n\n			while (up()) {\n				// 能向上走\n				rowNow--;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n		}\n		return list;\n	}\n```\n\n\n\n## 59 螺旋矩阵II\n### 题目：\n给你一个正整数 `n` ，生成一个包含 1 到 `n²` 所有元素，且元素按**顺时针顺序螺旋排列**的 `n x n` 正方形矩阵 matrix 。\n\n### **思路：** \n思路同54  \n上代码\n```java\npublic int[][] generateMatrix(int n) {\n    int[][] matrix = new int[n][n];\n    int left = 0, right = n - 1, top = 0, bottom = n - 1;\n    int count = 1;\n    while (count <= n * n) {\n        // 右\n        for (int col = left; col <= right; col++) {\n            matrix[top][col] = count++;\n        }\n        // 下\n        for (int row = top + 1; row <= bottom; row++) {\n            matrix[row][right] = count++;\n        }\n        if (left < right && top < bottom) {\n            // 左\n            for (int col = right - 1; col >= left; col--) {\n                matrix[bottom][col] = count++;\n            }\n            // 上\n            for (int row = bottom - 1; row > top; row--) {\n                matrix[row][left] = count++;\n            }\n        }\n        top++;\n        bottom--;\n        right--;\n        left++;\n    }\n    return matrix;\n}\n```\n\n基本思路大同小异，下面提供一种官方更简洁的方法：\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int maxNum = n * n;\n        int curNum = 1;\n        int[][] matrix = new int[n][n];\n        int row = 0, column = 0;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // 右下左上\n        int directionIndex = 0;\n        while (curNum <= maxNum) {\n            matrix[row][column] = curNum;\n            curNum++;\n            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];\n            if (nextRow < 0 || nextRow >= n || nextColumn < 0 || nextColumn >= n || matrix[nextRow][nextColumn] != 0) {\n                directionIndex = (directionIndex + 1) % 4; // 顺时针旋转至下一个方向\n            }\n            row = row + directions[directionIndex][0];\n            column = column + directions[directionIndex][1];\n        }\n        return matrix;\n    }\n}\n```\n\n## 115 不同的子序列\n### 题目： \n给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。\n\n字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\"ACE\" 是 \"ABCDE\" 的一个子序列，而 \"AEC\" 不是）\n\n题目数据保证答案符合 32 位带符号整数范围。\n\n### **思路：**\n这个题目很明显是一个动态规划的题目，利用空间保存之前的计算结果，通过状态转移公式得到下一状态的结果并保存。\n\n假设字符串 s(sentence) 和 t(target) 的长度分别为 m 和 n。\n建立一个(m+1)*(n+1)的数组dp：  \n> 通过`dp[i][j]`来保存`s[i:]`的子序列中 `t[j:]` 出现的个数  \n\n其中下表为m,n的分别表示最后为空字符串\"\"的结果。  \n\n首先考虑几个初始状态，并初始化：  \n* 当 j=n 时，t[j:] 为空字符串，由于空字符串是任何字符串的子序列，因此对任意 0≤i≤m，有 `dp[i][n]` = 1；\n\n* 当 i=m 且 j<n 时，s[i:] 为空字符串，t[j:] 为非空字符串，由于非空字符串不是空字符串的子序列，因此对任意 0≤j<n，有 `dp[m][j]` = 0。\n\n得到状态转移方程\n$$\ndp[i][j] =\n\\begin{cases}\ndp[i+1][j+1]+dp[i+1][j], & \\ s[i]=t[j]  \\\\[2ex]\ndp[i+1][j], & \\ s[i]\\ne t[j]\n\\end{cases}\n$$\n\n于是可得到代码：\n```java\n public int numDistinct(String s, String t) {\n        int m = s.length(), n = t.length(); //便于之后使用\n        //不可能情况\n        if (m < n) {\n            return 0;\n        }\n        //dp\n        int[][] dp = new int[m + 1][n + 1];\n        //初始化边界情况\n        for (int i = 0; i <= m; i++) {\n            dp[i][n] = 1;\n        }\n        \n        for (int i = m - 1; i >= 0; i--) {\n            char sChar = s.charAt(i);\n            for (int j = n - 1; j >= 0; j--) {\n                char tChar = t.charAt(j);\n                if (sChar == tChar) {\n                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];\n                } else {\n                    dp[i][j] = dp[i + 1][j];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n```\n\n\n## 206 反转列表\n### 题目：\n反转一个单列表\n\n### **思路：** \n最一般的方法是使用迭代将每一个指针指向前一个。  \n这种链表的题最容易想错的地方是改变了指向后忘记把原来存在的指针删除，导致思路出错。通俗来想是把这个节点的指向`“掰”`向另一个节点。  \n所以做链表的题应该先沉下心来，把思路完全想清楚了，然后用几行代码解决问题，而不是修修补补。  \n\n* 第一种迭代的思路：\n  共使用三个指针，一个记录当前节点curr，一个记录前一个节点prev，一个记录下一个节点next。每一次将当前节点的next指向前一个节点，直至当前节点为null。  \n  每次迭代的开始先记录下一个节点（块内变量），prev的初始值为null，刚好作为返还后的结束，之后每次迭代后要将prev的值改为curr。\n    \n```java\n    class Solution {\n        public ListNode reverseList(ListNode head) {\n            ListNode prev = null;   //初始值为null作为结束的指向\n            ListNode curr = head;\n            while (curr != null) {\n                ListNode next = curr.next; //可在每次迭代时再声明临时变量保存\n                curr.next = prev;\n                prev = curr;\n                curr = next;\n            }\n            return prev;\n        }\n    }\n```\n\n\n* 第二种递归的思路：  \n  这种思路比较难理解，但设计非常巧妙。其关键在于反向工作。**假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？**    \n  主要难以理解的地方在于：真正修改指向的操作在递归之后，也就是说是在***回溯***的阶段从后往前修改指向的，\n  上代码理解：\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) { //包括一个节点的情况\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;  //后面的节点转向\n        head.next = null;   //前面的节点指向null\n        return newHead; //新的head依次传递回来\n    }\n}\n```\n\n\n## 191 位1的个数\n### 题目：\n\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 \'1\' 的个数（也被称为汉明重量）。\n\n提示：\n\n请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。  \n在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n### **思路：** \n解法1：  \n最简单直接的、不用位运算的思路就是使用`Integer.toBinaryString(n)`将十进制整数n转换成二进制字符串，然后遍历串的每一位检查是否为1  \n```java\npublic int hammingWeight(int n) {\n    String a = Integer.toBinaryString(n);   //Integer内置函数\n    int count = 0;\n    for(int i = 0; i < a.length(); i++){\n        if(a.charAt(i)==\'1\') {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n但这样效率比较低，如果可以直接操作二进制数，效率会高很多。  \n解法2：  \n使用位操作符，循环i从0到31，利用 `n&(1<<i)` 对比是否第i位上为1。  \n```java\npublic int hammingWeight(int n) {\n    int count = 0;\n    for(int i = 0;i<32;i++) {\n        if((n&(1<<i))!=0) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n解法3：  \n对于位运算的优化——注意到`n&(n-1)`可以让`n`最后一位1变为0，于是循环直至`n==0`。  \n```java\npublic int hammingWeight(int n) {\n    int count = 0;\n    while(n!=0) {\n        n = n&(n-1);\n        count++;\n    }\n    return count;\n}\n```\n\n## 73 矩阵置零\n### 题目：\n\n给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 ***原地*** 算法。\n### **思路：** \n这是我第一次听说原地算法，说白了就是不利用或只利用固定的少量空间来完成题解，对于这个题，就是在原矩阵中做出标记完成理解。  \n对于这个题来说，如果某行某列是0，那么该行该列都要置为0，那么我们可以利用 **第一行**（第一列）来保存是否该行（该列）要置为0。  \n其原理就在于反正这一块要被污染，就利用他来保存需要的标记。  \n存在的问题是需要额外的变量来保存是否第一行（第一列）本身需要被全部置零。可用`[0,0]`来保存是否第一行要被置零，这样就只需要一个额外的变量来保存是否第一列要被置零。\n```java\npublic void setZeroes(int[][] matrix) {\n    boolean ifCol1Z = false; // 用来记录第一列是否需要置空\n    int m = matrix.length, n = matrix[0].length;\n    for (int i = 0; i < m; i++) {\n        if (matrix[i][0] == 0) {\n            // 第一列为0\n            ifCol1Z = true;\n        }\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[0][j] = matrix[i][0] = 0;\n            }\n        }\n    }\n    // 填充\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = 1; j <= n - 1; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n        if (ifCol1Z) {\n            matrix[i][0] = 0;\n        }\n    }\n}\n```\n\n## 456 132模式\n### 题目：\n给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。\n\n如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。\n\n进阶：很容易想到时间复杂度为 $O(n^2)$ 的解决方案，你可以设计一个时间复杂度为 $O(n logn)$ 或 $O(n)$ 的解决方案吗？\n### **思路：**   \n如题所说，很容易想到时间复杂度为$O(n^2)$的思路，以i, j, k标识，即遍历j，i保存为j以前最小的数，每一次遍历j都内部循环j右侧次大的数k（或比i最大的数中最小的那个）。  \n这样的算法问题出在每次求k都需要遍历，所以想到改进得到$O(nlogn)$的算法：使用平衡树记录j右边的数每次通过logn的复杂度获得j右侧次大的数k（或比i最大的数中最小的那个）。  \n> 这里用到的数据结构是TreeMap。用到的方法有：  \n> * put \n> * ceilingKey\n> * remove\n> * getOrDefault\n\n\n```java\npublic boolean find132pattern(int[] nums) {\n    int n = nums.length;\n    if (n < 3)\n        return false;\n\n    // 至少3个\n    int leftMin = nums[0];\n    TreeMap<Integer, Integer> right = new TreeMap<Integer, Integer>();\n\n    // 扫描从2开始右侧的所有，建立\n    for (int k = 2; k < n; k++) {\n        right.put(nums[k], right.getOrDefault(nums[k], 0) + 1);\n    }\n\n    for (int j = 1; j < n - 1; j++) {\n        if (leftMin < nums[j]) {\n            Integer tmp = right.ceilingKey(leftMin + 1);\n            if (tmp != null && tmp < nums[j])\n                return true;\n        }\n        // 为下一次循环更新\n        // 计数减一\n        right.put(nums[j + 1], right.get(nums[j + 1]) - 1);\n        if (right.get(nums[j+1]) == 0)\n            right.remove(nums[j+1]);\n        leftMin = Math.min(leftMin, nums[j]);\n    }\n    return false;\n}\n```\n\n\n## 61 旋转链表\n### 题目：\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。  \n注意k可能大于链表的长度\n### **思路：**   \n解法1：  \n对于链表的循环，我初步的想法是因为链表循环n次会回到初始情况，所以实际上只需要移动k%n个位置，这样我第一遍得到链表的长度n，之后通过几个变量移动k%n次即可。  \n```java\npublic ListNode rotateRight(ListNode head, int k) {\n    ListNode header = new ListNode(0,head);\n    ListNode pre = header,pio = header;\n    int count = 0;\n    while(head!=null){\n        head = head.next;\n        count++;\n    }\n    if(count == 0 || count == 1) return header.next;\n\n    for(int i = 0; i<k%count;i++){\n        pio = pio.next;\n    }\n    while(pio.next!=null){\n        pio = pio.next;\n        pre = pre.next;\n    }\n    pio.next = header.next;\n    header.next = pre.next;\n    pre.next = null;\n    return header.next;\n}\n```\n\n解法2：  \n后来看到官方题解**闭合为环**，觉得很有意思，在这里分享一下。  \n首先遍历到链表尾部，顺便得到链表的长度n，这样便只需要移动k%n次。  \n新的头部则在原头部`n-k%n`处，若`n-k%n`等于`n`，则返回原头部。  \n```java\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter->next = head;\n        while (add--) {\n            iter = iter->next;\n        }\n        ListNode* ret = iter->next;\n        iter->next = nullptr;\n        return ret;\n    }\n```\n这里还有一个很有意思的循环a次的方法`while(a-- > 0)`\n\n## 190 颠倒二进制位\n### 题目：\n颠倒给定的 32 位无符号整数的二进制位。\n### **思路：**   \n在刚拿到这个题时本想偷个懒，利用`Integer.toBinaryString`得到字符串再乘加权简单通过，然后发现当使用`Math.pow`数字太大（比如$2^{31}$）时，java的double会变得不够精确，会有1的偏差，导致得到的结果会有差距而失败。只能通过位运算。  \n除了基本的解题方法（见代码）外，题解中的`位运算分治`方法思路比较清奇，在这里都贴出来。\n\n```java\npublic int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; i++) {\n        res |= (n&1)<<31-i;\n        n>>=1;\n    }\n    return res;\n}\n```\n方法2（位运算分治）：  \n若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。\n\n由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。\n\n对于递归的最底层，我们需要交换所有奇偶位：\n\n取出所有奇数位和偶数位；  \n将奇数位移到偶数位上，偶数位移到奇数位上。  \n类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。\n\n需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 nn 的右移操作应使用逻辑右移。\n\n```java\npublic class Solution {\n    private static final int M1 = 0x55555555; // 01010101010101010101010101010101\n    private static final int M2 = 0x33333333; // 00110011001100110011001100110011\n    private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111\n    private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111\n\n    public int reverseBits(int n) {\n    //偶数位放在奇数位置上 | 奇数位放在偶数位置上\n        n = n >>> 1 & M1 | (n & M1) << 1;\n  //偶数组放在奇数组位置上 | 奇数组放在偶数组位置上\n        n = n >>> 2 & M2 | (n & M2) << 2;\n        n = n >>> 4 & M4 | (n & M4) << 4;\n        n = n >>> 8 & M8 | (n & M8) << 8;\n        return n >>> 16 | n << 16;\n    }\n}\n```'),(10,'Nginx学习笔记（简单理论篇）',1,'2021-05-03 02:48:39',219,'Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。在之前部署上一个项目配置Nginx的过程中，很多操作并不熟悉，感觉只是做一步查一步，对于真正的用法和原理并没有深究，本文记录了最近对于Nginx的进一步学习的笔记，图片和部分内容来源网络。\n\n下图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。\n\n<img src=\"https://pic1.zhimg.com/80/v2-e1826bab1d07df8e97d61aa809b94a10_1440w.jpg\" width=500 alt=\"架构图\" style=\"margin: 0 auto;\"/>\n\n\n接下来需要区分清楚正向代理和反向代理的区别。  \n## 正向代理：\n正向代理“代理”的是客户端，而且**客户端是知道目标的**，而**目标是不知道客户端是通过VPN访问的**。  \n\n<img src=\"http://img.foril.space/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpg\" width=500 style=\"margin:0 auto\" alt=\"正向代理\"/>\n\n\n## 反向代理：\n**反向代理“代理”的是服务器端**，而且这一个过程对于客户端而言是透明的。\n\n<img src=\"http://img.foril.space/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.jpg\" width=500 style=\"margin:0 auto\" alt=\"反向代理\"/>  \n\n## Master-Worker模式\n启动Nginx后，其实就是在80端口启动了Socket服务进行监听。  \nNginx采用**Master-Worker模式**  \n\n### Master的作用：\n* Master负责管理Worker进程  \n* 读取并验证配置文件`nginx.conf`；\n\n### Worker的作用：\n* 每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；\n* Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。\n\n***\n上文基本描述了Nginx如何处理具体的请求。接下来考虑下一个深入一步问题：  \n### Nginx如何做到高并发下的高效处理？  \nNginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。\n> **思考：Nginx如果挂了怎么办？**  \n> Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。  \n> 一般的处理是使用进程管理工具**守护进程**。  \n> 题外话：  \n> **本站并未对Nginx采用进程守护**    \n> **但对后端服务器通过pm2守护进程并使用监听模式**  \n> 监听模式启用后，编辑后端时，对应常采取的方式是VSCode远程编辑后端代码，每次更新都会自动刷新，存在的小问题是每次编辑都会刷新后端的缓存，所有的session都会失效，可以用持久化存储解决这个小问题（在后端代码之前的版本里启用了持久化存储到文件里，后来看着文件太多心烦就注释了），但我也只有自己一个用户，影响不大  \n> pm2是一个进程管理工具,可以用它来管理你的node进程，并查看node进程的状态，当然也支持性能监控，进程守护，负载均衡等功能  \n  \n之后将会在操作篇进入对Nginx配置的实际操作学习。\n\n## 参考：\n- [1] [知乎：8分钟带你深入浅出搞懂Nginx](https://zhuanlan.zhihu.com/p/34943332)'),(13,'力扣刷题笔记（二）',1,'2021-05-13 06:10:42',186,'第二篇leetcode刷题笔记  。\n\n## 7. 整数反转　　\n### 题目　　\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。　　\n\n如果反转后整数超过 32 位的有符号整数的范围 [$−2^{31}$,  $2^{31} − 1$] ，就返回 0。　　\n\n假设环境不允许存储 64 位整数（有符号或无符号）。　　\n\n### 思路：　\n这是一道简单题，之所以放在这里，是因为其中题解提供的一些思路很值得学习，并且在其中我遇到的一些小问题也很值得记录下来以便以后回忆。  \n\n#### 不借助栈的“弹出”和“推入”  \n首先这个题第一思路是需要借助栈翻转，但作为数字，我们可以不使用栈就对其数字加以翻转。这是值得记录回忆的小技巧之一。  \n\n```java\n// 弹出 x 的末尾数字 digit\ndigit = x % 10\nx /= 10\n\n// 将数字 digit 推入 rev 末尾\nrev = rev * 10 + digit\n```\n\n其次需要判断反转后的数字是否溢出，因为我们只能使用32位整型，所以不能使用`rev*10+digit >　Integer.MAX_VALUE`这样的语句来判断，但我们可以反其道而行，对`Integer.MAX_VALUE`除10来判断，这里题解中有一个值得学习的推导思路：  \n\n考虑 x>0 的情况，记 $INT\\_MAX=2^{31}-1=2147483647$ ，由于\n\n$$\n\\begin{aligned} \\textit{INT\\_MAX}&=\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor\\cdot10+(\\textit{INT\\_MAX}\\bmod10)\\\\ &=\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor\\cdot10+7 \\end{aligned}\n$$\n\n则不等式$rev⋅10+digit≤INT\\_MAX$\n\n等价于\n\n$$\n\\textit{rev}\\cdot10+\\textit{digit}\\le\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor\\cdot10+7\n$$\n\n移项得\n\n$$\n(\\textit{rev}-\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor)\\cdot10\\le7-\\textit{digit}\n$$\n\n讨论该不等式成立的条件：\n\n若 $rev>\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$ ，由于 ${digit}\\ge0$，不等式不成立。  \n\n若 $rev=\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$\n ，当且仅当 ${digit}\\le7$ 时，不等式成立。  \n\n\n若 $rev<\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$\n​，由于 ${digit}\\le9$，不等式成立。\n\n**注意**：这里需要注意如果$rev=\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$时仍然能够推入数字，说明 x 和$INT\\_MAX$的位数相同，digit 为 x 的首位，因为$x<0$，所以$digit\\le2$，\n因此判定条件可简化为：当且仅当 $rev\\le\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$ 时，不等式成立。\n\nx<0 的情况类似.\n\n**综上所述**，判断不等式\n\n$$\n-2^{31}\\le\\textit{rev}\\cdot10+\\textit{digit}\\le2^{31}-1\n$$\n\n是否成立，可改为判断不等式\n$$\n\\lfloor\\cfrac{-2^{31}}{10}\\rfloor\\le\\textit{rev}\\le\\lfloor\\dfrac{2^{31}-1}{10}\\rfloor\n$$\n\n是否成立，若不成立则返回 0。\n\n---\n\n解决了边界问题这个重点问题，剩余的部分就很简单了，需要判断结尾的`0`以及开头的`-`，在这里就不详细分析了。\n\n\n\n## 1310. 子数组异或查询  　\n### 题目　　\n有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。\n\n对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。\n\n并返回一个包含给定查询 queries 所有结果的数组。\n\n输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]  \n输出：[2,7,14,8]   \n解释：  \n数组中元素的二进制表示形式是：  \n1 = 0001  \n3 = 0011  \n4 = 0100  \n8 = 1000  \n查询的 XOR 值为：  \n[0,1] = 1 xor 3 = 2   \n[1,2] = 3 xor 4 = 7   \n[0,3] = 1 xor 3 xor 4 xor 8 = 14   \n[3,3] = 8  \n\n\n### 思路：\n最初写了一个最简单的遍历想解决问题，设`arr`的长度为`n`，`queries`的长度为`m`，这样时间复杂度为$O(mn)$，结果运行超时，我开始思考怎么解决问题。  \n\n后来看到题解“前缀异或”，突然想到，异或和加减有很多相似的性质，看到异或，又看到连续数组，应该想到利用前缀和的思想，异或这东西不是有`x^x=0`这种好用的性质吗，题目要求的是对arr中间一段进行异或，那不是就可以后面的结果异或抵消前面的结果嘛。  \n这里有一个示意可以方便理解。  \n\n```\n--------\n^\n---\n=\n   -----\n```\n\n这样只需要遍历一遍arr，得到arr.size()个结果保存起来，剩下的就是做异或相抵消得问题了。  \n上代码：  \n```cpp\nclass Solution {\n	public:\n		vector<int> xorQueries(vector<int>& arr, vector<vector<int> >& queries) {\n			int len = arr.size();\n			vector<int> rec(len+1, 0);\n			//遍历arr得到arr个结果（第一个0作为初始值，作为最左值之前的结果）\n			for(int i=0; i<len; i++) {\n				rec[i+1] = (rec[i]^arr[i]);\n			}\n			vector<int> res;\n			//右下标异或左下标之前的结果作抵消\n			for(vector<int> lr: queries) {\n				res.push_back(rec[lr[1]+1]^rec[lr[0]]);\n			}\n			return res;\n		}\n};\n```\n\n\n## 62. 不同路径 　\n### 题目　　\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n\n### 思路：\n#### 方法1：数学法\n这个题一看到最初的思路是数学法，利用组合数 $C_{m+n-2}^{m-1}$ 。可以理解为一共有`m+n-2`个空，往其中填入`m-1`个黑棋，剩下的全部填入白棋，便得到了最终的结果，但实际写出来发现存在的问题是如果先计算分母极容易溢出。  \n如果使用的语言有关于组合数的API直接调用即可，如果没有，可以考虑\n```cpp\nfor (int x = n, y = 1; y < m; ++x, ++y) {\n            ans = ans * x / y;\n        }\n```\n(来自力扣官方题解)  \n\n最初纠结这样一个一个分数会不会产生分数，后来看到网友的评论突然想明白了。\n\n<img src=\"https://img.foril.space/%E7%BB%84%E5%90%88%E6%95%B0.jpg\" width=\'1000\'/>\n\n#### 方法2：动态规划\n不多说废话，具体动态规划的要点可以查看我的另一篇博客 [专题：动态规划](https://www.foril.space/article/21)。  \n这一题通过一个二维数组记录到对应点的最多方法。\n\n上代码：\n```cpp\nint uniquePaths(int m, int n) {\n    int dp[m][n];   //二维数组\n    memset(dp,0,sizeof(dp));    //初始化（因为是memset针对字节，所以一般只能初始化为0）\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(i == 0 || j==0){\n                dp[i][j] = 1;   //边界值（初始化）\n            }\n            else{\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]; //状态转换方程\n            }\n        }\n    }\n    return dp[m-1][n-1];\n}\n```\n\n\n## 406. 根据身高重建队列　\n### 题目　　\n\n假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n\n示例：  \n输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]  \n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n\n\n### 思路：\n#### 方法一： 从高到低考虑\n这个题一开始上手没有找到其中的窍门，感觉类似的题目的关键就是能够找到一个窍门，或者说一个隐藏的属性。  \n这个题 ki 记录的是前面有多少身高大于等于 hi 的人数，言下的意思是前面如果放的是比他身高小的人，是没有任何影响的。那我们只要按照一定顺序填入队列就可以得到实际的位置。  \n官方题解的原话是：\n> 如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第 i 个人时：  \n> * 第 0, ... , i-10, ... ,i−1 个人已经在队列中被安排了位置，并且他们无论站在哪里，对第 i 个人都没有任何影响，因为他们都比第 i 个人矮；  \n> * 而第 i+1, ... ,i+1, ... ,n−1 个人还没有被放入队列中，但他们只要站在第 i 个人的前面，就会对第 i 个人产生影响，因为他们都比第 i 个人高。\n\n所以我们要先找到大个的相对位置，把大个的放进队列里，这样其他人的位置不会影响到更大个的人的位置。同时，相同个子的人需要先放入前面人少的人，也就是得到了一个排序的方法：**先按第一列从大到小排序，第一列相同的按第二列从小到大排序**。\n```cpp\n//排序\nsort(people.begin(), people.end() , [](const vector<int> & a, const vector<int> & b) {\n    if(a[0] == b[0]) return a[1]<b[1];\n    return a[0]>b[0];\n});\n```\n\n那么，对示例`[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`来说，排序后的结果应该是：  \n```\n7,0\n7,1\n6,1\n5,0\n5,2\n4,4\n```\n这也就是我们填入的顺序，每填入一个**当前最小个的人**，根据它前面的人数`ki`，把他放在第`ki`个位置，之后的全部往后移。最后全部填入，就是最终的顺序。  \n这样频繁插入移动，在java中考虑使用 LinkedList 。\n\n代码：\n```cpp\nvector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n    //第零列从大到小\n    //第一列从小到大哦\n    int len = people.size();\n    sort(people.begin(), people.end() , [](const vector<int> & a, const vector<int> & b) {\n        if(a[0] == b[0]) return a[1]<b[1];\n        return a[0]>b[0];\n    });\n\n    //排好序后开始放位置\n    vector<vector<int>> list(len);\n    for(int i = 0; i<len; i++) {\n        int pos = people[i][1];\n        for(int j = len-2; j>=pos; j--) {\n            //往后窜\n            list[j+1] = list[j];\n        }\n        list[pos] = people[i];\n    }\n    return list;\n}\n```\n\nPS:  \n后来发现往后窜的步骤可以通过 `insert`。\n```cpp\nfor (const vector<int>& person: people) {\n    ans.insert(ans.begin() + person[1], person);\n}\n```\n#### 方法二： 从低到高考虑\n同上，在排好序的队列中，个小的人是影响不到个高的人的 `ki` 的，所以我们可以按身高从低到高往队列中插入，前面只要留够 `ki` 个 “空座” 给之后个更高的人。对于相同身高的人，需要先排入 `ki` 大的人。  \n\n> 这里需要注意的是排序方法和方法一刚好相反。  \n\n对示例`[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`，排序后的结果应该是：  \n```\n4,4\n5,2\n5,0\n6,1\n7,1\n7,0\n```\n有了这个顺序，便遵循 `留空 -> 插入` 的原则找到位置即可。  \n\n<img src=\"https://img.foril.space/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.webp\" width=1000/>\n\n代码：\n```cpp\nvector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n    sort(people.begin(), people.end(), [](const vector<int>& u, const vector<int>& v) {\n        return u[0] < v[0] || (u[0] == v[0] && u[1] > v[1]);\n    });\n    int n = people.size();\n    vector<vector<int>> ans(n);\n    for (const vector<int>& person: people) {\n        int spaces = person[1] + 1;\n        for (int i = 0; i < n; ++i) {\n            if (ans[i].empty()) {\n                --spaces;\n                if (!spaces) {\n                    ans[i] = person;\n                    break;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n\n## 96. 不同的二叉搜索树\n### 题目　　\n\n给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\n\n示例 1：  \n输入：n = 3  \n输出：5\n\n<img src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" width=800>\n\n### 思路：\n如果了解过**卡塔兰数**的话，可以直接得到\n$$\nC_{n+1} =  \\frac{2(2n+1)}{n+2}C_n\n$$\n> 令h(0)=1,h(1)=1，卡塔兰数满足递归式：  \n> h(n)= h(0)*h(n-1) + h(1)*h(n-2) + ... + h(n-1)h(0) (其中n>=2),这是n阶递推关系;\n\n以这个题作为背景的话，实际意义就是 n 个数对应分别以 1 到 n 作为根节点，也就是左孩子分别有 0 个到 n-1 个节点这n种情况的数量之和。  \n\n## 664. 奇怪的打印机\n### 题目　　\n\n有台奇怪的打印机有以下两个特殊要求：\n\n1. 打印机每次只能打印由 同一个字符 组成的序列。  \n2. 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。\n\n给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。\n\n**示例 1：**  \n输入：s = \"aaabbb\"  \n输出：2  \n解释：首先打印 \"aaa\" 然后打印 \"bbb\"。  \n    \n**示例 2：**  \n输入：s = \"aba\"  \n输出：2  \n解释：首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 \'a\'。  \n\n### 思路：\n之前在 [动态规划专题](https://www.foril.space/article/21) 中，提到过很多字符串最优问题都是使用动态规划解决的。  \n这个题一上手，并没有找到解决的方法，主要问题是找不到状态转换方程，在查看题解后，发现题解将一个区间的最优问题转化为小区间的最优问题求和的最小值。后来从评论区明白这是一类叫 **“区间DP”** 的问题。  \n\n#### 什么是区间DP？\n区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过 *合并小区间的最优解进而得出整个大区间上最优解* 的DP算法。  \n既然让我求解在一个区间上的最优解，那么我把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可。\n\n朴素区间DP（$N^3$）转移方程：  \n```cpp\ndp[j][ends] = min(dp[j][ends],dp[j][i]+dp[i+1][ends]+weigth[i][ends]);\n```\n有了这些背景知识，就可以得到本题的基本思路。\n\n动态规划的基本要素：  \n* **保存**：`dp[i][j]`保存下标从`i`到`j`的最小打印次数\n* **状态转移方程**： \n$$\ndp[i][j] = \n\\begin{cases}\n        dp[i][j-1] &,s[i]==s[j]\\\\\n        min_{k=i}^{j-1} dp[i][k] + dp[k+1][j]&,s[i]!=s[j]\n\\end{cases}\n$$\n* **初始化**：`dp[i][i] = 1`\n* **遍历顺序**：`i`从大到小；`j`从小到大\n* **结果**：`dp[0][n-1]`\n\n这就是做一道动态规划最重要的步骤了，这一题还有一个主要要理解的难点就是如何使用区间DP。  \n上代码：  \n```cpp\nclass Solution {\npublic:\n    int strangePrinter(string s) {\n        int n = s.length();\n        int dp[n][n];\n        //初始化\n        for(int i = 0;i<n;i++){\n            dp[i][i] = 1;\n        }\n        //状态转移方程\n        for(int i = n-1;i>=0;i--){\n            for(int j = i+1;j<n;j++){\n                if(s[i] == s[j]){\n                    dp[i][j] = dp[i][j-1];\n                }else{\n                    int minR = INT_MAX;\n                    for(int k = i;k<j;k++){\n                        minR = min(minR, dp[i][k] + dp[k+1][j]);\n                    }\n                    dp[i][j] = minR;\n                }\n            }\n        }\n        //结果\n        return dp[0][n-1];\n    }\n};\n```\n## 39. 组合总和\n### 题目　　\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n\n### 思路：\n这个题是在刷回溯专题时遇到的。接下来几个题都有很典型的回溯算法的结构。\n```cpp\nclass Solution {\nprivate:\n    vector<vector<int>> res;    //存放结果\n    void bt(vector<int>& v,int index, int already,int target, vector<int>& candidates){\n        if(already>target){ //出口条件（不合格，舍弃）\n            return;\n        }\n        if(already==target){//出口条件（是结果，加入结果数组）\n            res.push_back(v);\n            return;\n        }else{\n            //继续往下试探\n            for(int i = index;i<candidates.size();i++){ //尝试不同的数字作为下一个候选\n\n                v.push_back(candidates[i]); //第一部分，把当前数字加入结果往下试探\n\n                bt(v, i, already+candidates[i], target, candidates);    //递归试探过程\n\n                v.pop_back();   //试探结束后，为了使用下一个数字，要把当前数字所做的改变全部复原\n            }\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<int> v;\n        bt(v, 0, 0, target, candidates);    //进入\n        return res;\n    }\n};\n```\n'),(17,'项目管理笔记',1,'2021-05-06 07:21:26',186,'软件项目管理笔记。   \n\n# 软件管理\n\n# Class 1\n\n项目：为了得到一个产品、服务、成果而付出的一次性的临时努力\n\n项目的特点：临时（有开始，有结束），追求结束，一次性，独特的。其他项目的经验只能借鉴不能直接拿来用。\n\n渐进明细：波动式计划，远期粗略规划，近期细化\n\n运营：为了持续的经营下去，执行反复的流程。\n\n共同点：受资源限制，都需要计划\n\n项目的结果（产品）：项目成功的依据，范围、进度、成本、质量\n\n项目目标：追求成功，受到的影响：技术，分工，干系人影响最大\n\n识别：多目标，层次化，优先级	\n\n干系人：对项目有影响的人就是干系人（积极影响，消极影响）\n\n### 关键干系人：\n\n客户方：建设方（甲方）\n\n实施方：PM项目经理，团队成员（程序，测评，架构，系统分析，质量QA），外包团队\n\n第三方：咨询方（需求开发）---》监理方，专家\n\n### 项目经理角度考虑问题：\n\n1. 项目管理的知识领域（赶工，绩效）\n2. 广博的知识，丰富的经历\n3. 应用领域的知识标准和规定\n4. 良好的沟通和协调能力（人），软技能\n5. 良好的职业道德\n\n### 项目管理\n\n科学规划角度出发\n\n### 组织结构\n\n因为项目有多个干系人，干系人之间存在关系，如何管理干系人的关系（汇报）\n\n### 组织结构OBS\n\n1. 传统职能型：涉及到和职能经理谈判获取对应的资源，人员会受到多头管理，造成管理混乱，为了解决项目经理权限不足的问题，PMO（项目管理办公室）协调（位于总裁下方那个，比职能经理高半级）\n\n\n\n# Class 2\n\n项目：独特，结束，逐步细化\n\n衡量：范围，进度，成本，质量\n\n干系人：有影响的人，关键干系人（客户，承建，第三方）\n\n### 组织结构OBS\n\n1. 传统职能型：涉及到和职能经理谈判获取对应的资源，人员会受到多头管理，造成管理混乱，为了解决项目经理权限不足的问题，PMO（项目管理办公室）协调（位于总裁下方那个，比职能经理高半级），员工的职业连续性可以得到保证。\n2. 项目型：PM和员工都属于全时参与，便于绩效考核，员工缺乏事业连续性，PMO一般位于沟通中心，自上而下的按照优先级分配协调资源。\n3. 矩阵型：介于传统之鞥呢和项目之间的一种OBS模型。\n\n### 周期\n\n产品周期\n\n项目周期：项目周期的结束就是项目首尾（必须包含产品的验收和合同管理的收尾【归属于PM的合同部分结束---》将合同移交至外部（财务）】）\n\n管理周期\n\n合同周期\n\n### 阶段\n\n便于控制和管理项目。每个阶段末都应该有交付物，通过评审，评审（独立第三方）是作为结束上一阶段开始下一阶段的依据。\n\n### 项目各阶段因素的影响：PDCA\n\nP Plan（PM的任务，计划，计划，再计划）\n\nD Do（按照已评审的计划执行）\n\nCA Check Action（对于计划发现皮纳差，分析原因，原因可消除就去消除，不可消除修改计划）\n\n### 过程组\n\n启动过程组，规划过程组，执行过程组， 监控过程组，收尾过程组。\n\n过程组：将某项管理的管理内容（活动）分类处理，管理优化。\n\n## 项目管理：十大管理44个过程\n\n整体管理，需求，范围，进度，成本，质量，风险，团队，沟通，合同\n\n## 整体管理流程\n\n### 项目章程：\n\n内容：指导性文件、授权项目经理PM【PMO（项目管理办公室、出资人）】，批准项目或阶段\n\n输入：合同，SOW（工作说明书），柱子过程资产，企业环境因素\n\n工具与技术：项目管理软件，模板，转件判断，方法论\n\n输出：项目章程（主要内容）\n组织的约束，干系人，干系人的期望目标，概要的里程碑，概要的预算，授权项目经理（PM的合法权利）  \n\n\n\n### 初步范围说明书  \n需求来自于合同和SOW（产品需求），概括式的计划  \n\n输入：项目章程  \n工具与技术：  \n输出：范围说明书（初步）--》波动式计划\n\n\n### 整体规划\n制定项目的整体管理计划，包括各子计划  \nPM组织相关干系人制定计划（成果），通过评审后作为项目的指导文件  \n计划：定宗旨，选标准，指导后续工作  \n\n输入：初步范围说明书\n工具与技术：\n输出：\n\n### 执行  \nDo 按照计划做（PM组织资源）\n\n### 监控  \n监督和控制CA  \n万能的监控方式：组织相关干系人制定计划，通过评审，设置周期性和里程碑的监控点，对比计划发现偏差，如果产生偏差分析原因（1.原因可消除，消除原因，2.原因不可消除，更新计划），按照新计划执行，记录存档\n\n### 变更  \n强制变更（政策类），普通变更，不管哪一类变更，必须要走变更控制流程  \n1. 申请（PM提出）  \n2. 组织评估，提供评估报告（PM组织）  \n3. 提供CCB进行决策  \n4. 更新计划  \n5. 组织资源按照更新后的计划实施  \n6. 验证变更是否符合评估\n7. 记录日志（累积组织过程资产）\n\n### 收尾  \n项目的收尾包括产品的验收管理的收尾  \n产品验收：准备（产品，用户手册，质保，验收单），通知甲方验收（合同中写明验收规范）  \n管理收尾：绩效考核，总结经验\n\n# Class 3\n\nPDCA =》五大过程组。\n\n在项目管理过程中，前序工作的成果【在每个过程都叫做输出】通过评审（测试）可以作为后续工作的前提和依据【输入】，过程中采用的手段叫做工具与技术。\n\n性质，范围，合同是多方之间民事行为的约束\n\nSOW，工作说明书，用户需求的更详细的描述\n\n组织过程资产：积累的经验和教训\n\n企业环境因素：（不可裁剪）\n\n专家判断：德尔菲法\n\n多轮，背靠背（防止想法被片面方放大），投票，筛选\n\n纵向思维法，横向思维法，头脑风暴法\n\n范围：需求的抽象描述，范围就是完成项目需要仅需要做的工作或活动  \n\n# Class4\n\n变更：软件项目中，变更是不可避免的   \n变更混乱会发生，会发生配置管理混乱，返工   \nCCB：变更控制委员会（配置控制委员会），临时机构，负责进行变更的审批（变或不变）  \nCCB成员：具有资金审批权的人，甲乙双方以及监理的高层，PM也应该是CCB的成员（不可以承担副组长以上的职务）  \nCCB可以只有1人，也可以兼职  \n变更可能会引起项目的进度、成本、合同发生改变\n  \n\n推进顺序：  \n招投标和采购  \n招标：\n1. 编制标书（评标规则-无歧视，不能模糊）\n2. 发布招标公告（公共平台，声明资质要求）\n3. 发售标书（进行资格预审，购买费用+投标保证金）\n4. 接受投标（密封）\n5. 评标（解封）\n6. 宣布中标，签订合同  \n\n### 标书密封，标底可保密     \n反不正当竞争法：不得以低于成本价竞标，发售标书时间不得短于20天  ，如果修改了招标文件截止日期不得短于15天，确定中标需要通知所有投标方 （退还保证金），中标后30天内必须签订合同，评标技术专家不能低于2/3，专家不能少于5人，专家>=5人的奇数\n          \n可以不招标的活动，私人企业，可行性研究，涉密，救灾\n\n\n# Class5\n\n###身份（PM，投递，讲解）\n\n私企，涉密，救灾，可行性研究可以不招标  \n\n### 可行性研究  \n目的：论证项目是否可行（可能性，必要性）  \n可行性研究的方面：\n1. 技术可行性：人员、资源、 \n2. 经济可行性：敏感性（龙卷风 或者财务分析方法  \n3. 运行环境：（用户最关注的，调研客户的水平，能力，企业环境）\n4. 其他可行性：法律，社会行为\n  \n如果团队内部缺乏某些技术，可以采用的手段：  \n培训（内培）：团队能力的提升  \n招募：得到知识（不能确保事业的连续）    \n外包：专业的人做专业的事（降低成本），不易获取知识  \n财务分析：  \n静态：不需要考虑资金的时间价值，【关键字：期】  \n动态：考虑资金的时间价值 【利率，CPI】 【关键字：率，现，净】  \n计算回收期的时候，从投入的时候开始计算    \n\n<br />  \n\n可行性研究的过程：\n1. 机会研究【自运营重要】  （可省略）\n2. 初步可行性研究（级别）  （可省略）\n3. 详细可行性研究（量化）  （不可省略）\n4. 形成《可行性研究报告》进行论证   \n\n<br />\n中标后首先签合同，发布项目章程(授权PM)       \n<br />    \n\n### 需求管理：  \n需求分为需求工程（实际）和需求管理（管理）  \n### 需求的层次：  \n招投标文件+合同（用户的高层需求）-》SOW（产品需求）-》需求规格说明书（功能+性能+安全需求）  \n\n### 需求工程的过程\n1. 需求获取：充分，多层次都需要调研《用户需求说明书》\n2. 需求分析：建模，解决冲突（信息的使用者优先原则，优先满足信息使用者的需求）\n3. 需求定义：形成《需求规格说明书》，无歧义的多方签字认可的，具有法律效力的正式文档\n4. 需求验证：通过需求文档和产品能够双向追踪（需求的跟踪矩阵）\n     \n需求定义：产生了需求基线（基线需要改变，必须按照变更流程实施)  \n已定义，已实现，已删除  \n\n### 需求管理：\nPDCA，规划（定宗旨、造标准、如何指导后续工作），理解，承诺，管理变更（流程），维护需求的跟踪\n  \n企业的层次：高层战略+中层管理+基层操作+底层产品层\n\n# Class6  \n\n### 需求：    \n需求工程  \n需求管理：PDCA（规划、理解、承诺、变更、监控【双向跟踪】）\n立项：可行性研究（机会、初步、详细【报告】、论证）  \n可行性：技术、经济、运行、其他（法律、社会行为）  \n### 范围管理  \n范围完成项目所需要做的仅需要做的工作或活动\n范围管理特别适用于波动式计划【1、范围来自于需求的抽象描述  2、整体管理中已经生成了初步范围说明书】--》项目的范围应该是逐步细化的而不是蔓延的  \n### 范围管理的流程PDCA  \n规划：（定宗旨，选标准【符合自身】，指导后续工作）  \n定义：产生《范围说明书》--【干系人以及期望，假设以及约束，活动和产品的描述】--》作为后续工作的万能输入（范围基线【范围说明书+WBS+WBS字典】）  \nWPS（*）：  \n1. 工作分解结构，作用：将项目分解为更小更易于管理的单元，便于控制和管理，类似于WBS的OBS（组织），RBS（风险），RBS（资源），BOM（物料清单）   \n2. 依据和形式：层次化的树形结构（直观，如果对于大项目不合适（分级控制）），矩阵表格（目录），文本形式（详细描述，WBS字典--负责人，工作的描述，衔接））    \n3. 控制账号：WBS每个节点的控制单元，每个工作包只属于一个控制好，符合RACI模式，每个单元只有一个人负责  \n4. WBS划分规则：\n   1. 每个分支可以选择不同的划分方法（每个分支的划分方法尽量相同）\n   2. 可以按照交付物、周期、组织结构（超大型项目）\n   3. 外包工作需要纳入WBS\n   4. WBS的层次建议3-5层\n   5. 最小的工作包（叶子结点）建议80人时，1人两周工作量（周期性的安排监控点）    \n5. 步骤：  \n   1. 明确项目的范围\n   2. 选择合适的形式\n   3. 划分（分解）\n   4. 分配具体的控制账号\n   5. 通过评审  \n   \n确认（内部） ：  核心确保范围和需求一致 \n监控  CA  ：控制变更，纠偏  \n确认  （外部）：用户验证，确保范围的实现和用户的目标一致  \n\n质量控制和范围确认：    \n质量控制（内部）主要的目的是检测交付物满足标准的程度  \n范围确认（可内可外，一般强调外部）主要目的是检测交付物是否符合用户的期望  \n一般情况质量控制先于范围确认  \n\n\n作业：根据WBS模板，创建一个单月内学习计划\n\n# class 7\n### 范围管理\n完成项目目标所需仅需做的工作\n\n流程PDCA：规划=》定义【范围说明书】=》WBS（WBS字典）=》范围确认（内部）=》范围控制=》范围确认（客户）\n\n### 进度管理（周期管理），时间管理  \n流程：PDCA  \n活动定义：识别完成项目所需要的活动【借鉴WBS并更新】  \n活动排序：确定依赖关系【找到活动的前置后置逻辑关系】  \n活动资源估算：结合PMO提供的资源日历，确定资源的有效性。使用资源可以适当的评估历时  \n \n活动历时估算：  \n制定进度计划P：创建进度基线，需要调整，适用于合同  \n1. 关键路径CPM，完成项目所有目标的最长路径，CPM可以有多条，非关键路径上的调整会影响到CPM，关键活动没有自由时间  \n2. 图示技术调整进度【进度压缩】   \n进度控制CA:    \n\n#### 常见逻辑关系：  \n结束开始： FS，最常见  \n结束-结束：FF，  \n开始-结束：SF，后置活动开始，前置活动才结束（升级）  \n开始-开始：SS，并行    \n\n### 网络图示技术表示：\n1. 单代号网络图：AON,PDM前导图，节点表示工作，线表示逻辑关系（只能表示FS关系），节点可以通过不同的图示详细表示\n2. 双代号网络图：AOA，箭线图：节点表示关键点，线表示工作或活动，虚线表示虚活动（仅用来表示前后逻辑关系，不消耗任何资源）  \n3. 时标网络图：用于进度分析\n4. 甘特图：一般用日历日期表示，用于汇报，核对进度，缺陷不能表示复杂的逻辑关系\n\n  \n### 活动历时估算：  \n最直接：工作量/工作效率，弊端（理想化）  \n参数估算：计算沟通渠道  \n三点估算PERT：（乐观、悲观、可能）   \n正态分布：3个标准差的分布概率：68、95、99\n\n# class 8  \n进度（活动定义--识别WBS--》 排序--依赖逻辑 （FS)PDM，ADM，时标网络图，甘特图--》，资源估算【PMO资源日历】--》历史估算）  \n\nA\n\nB\n\nC\n\n如果多个工作串行方式安排，标准差 =  sqrt（方差之和 ===  所有标准差的平方之和）  \nsqrt 是开平方  \n压缩工期时需要注意：  压缩比例越大成本以指数级上升\n\n进度+成本+资源  \n\n成本管理（EVT）\n\n# class 9    \n进度偏差：用户引发（缩范围--先实现核心功能，多期开发），加资源（时间-团队管理混乱，成本，人手-经验丰富），适当并行（快速跟进）  \n\n图示--计算（查看状态、预知未来)  \n\n\n## 成本管理PDCA    \n流程：\n1. 成本计划：估算、预算、管理、监督、控制项目成本的过程  \n   ------------项目管理（风险、质量提前介入），风险管理计划是输入之一\n2. 成本估算：求得一个近似成本，识别成本项，找到可替代成本，确认成本值的质量（类别--每个项目都是不同的，外界因素干扰。自下而上的估算-WBS汇总，质量成本，储备分析--应急储备，管理储备）\n3. 成本预算：建立成本基线（基线），规划管理储备和项目资金预算，再将预算额度具体对应到活动中，（成本预算不是分配资金）\n4. 成本控制\n  \n成本投入过程对于软件项目：实施阶段比重最大，累计投入成本，估算值+应急储备构成成本基线  \n\n应急储备：介于成本基线和估算值之间的值，主要是应对已知风险，需要实现挣值管理（PM可调用，负责）  \n管理储备：项目预算（资金准备量）和成本基线之间的储备值，用于应对未知风险（PM不能把控），绩效考核中不纳入对PM的考核中，PM不可调用，PMO提供使用\n\n挣值分析EVT技术：  \n\nPM不关心任何利润，在成本基线的约束下完成项目目标  \n\nEVT几个基础值：\n1. 计划值：PV，规划中的预计值，总的PV也叫做BAC，如果没有特别说明当前PV，则PV为BAC/周期\n2. 实际成本：AC，已经支出的成本\n3. 挣值：EV，已创造的产品的价值\n  \n状态判断的基本模式  \nCV成本偏差 EV-AC  \nSV进度偏差 EV-PV    \nCPI成本绩效指数 EV/AC  \nSPI进度绩效指数 EV/PV\nCV,SV<0代表超支超时，>0代表节约提前   \nCPI,SPI<1代表超支超时，>1代表节约提前  \n一个项目的PV大于AC不代表项目节约  \n\nCV和SV主要用于判断状态，不用于多项目比较    \n预测未来  \nETC完工尚需成本：\n1. 典型偏差：偏差继续 ETC=(BAC-EV)/CPI\n2. 非典型偏差：消除偏差，回归原始计划 ETC=BAC-EV  \n     \nEAC完工总成本：EAC=ETC+AC\n\n\n\n\n\n\n\n\n\n\n\n'),(18,'Nginx学习笔记（基本操作篇）',1,'2021-05-07 06:48:01',130,'之前在理论篇中简单学习了一些必要的Nginx相关知识，在实际运用中，我们还需要熟悉相关的操作，本篇从安装开始，记录常用的Nginx操作。\n> 环境：\n> * CentOS 8.0 64bit with ARM　　\n> * Nginx 1.14.1  \n\n## 安装  \n### Yum\n首先简单介绍Yum（Yellow dog Updater, Modified），是一个在Fedora和RedHat以及CentOS中的Shell前端**软件包管理器**。 基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。（PS：如果上面过于官方的介绍不好理解，那么可以把yum简单的理解为CentOS中的npm。）  \n\n## 使用yum安装  \n\n```bash\nyum install nginx\n```\n\n之后可通过`nginx -v`来判断是否安装成功\n> tips:  \n> 可通过`whereis nginx`查找Nginx所有文件，如果之前安装过Nginx，可直接删去找到的文件后重新下载  \n\n## 命令行基本参数  \n   \n安装成功后，首先要学习Nginx命令行的基本命令\n\n1. `nginx -t` #测试配置文件是否有语法错误\n2. `nginx -s reopen` #重启Nginx\n3. `nginx -s reload` #重新加载Nginx配置文件，然后以优雅的方式重启Nginx\n4. `nginx -s stop` #强制停止Nginx服务\n5. `nginx -s quit` #优雅地(gracefully)停止Nginx服务（即处理完所有请求后再停止服务）\n6. `nginx -c [配置文件路径]` #为 Nginx 指定配置文件\n\n如果不指定配置文件，Nginx默认配置文件在`/etc/nginx/nginx.conf`，\n\n配置文件内包括`events`区块和`http`区块，`http`区块包含一个或多个`server`区块，`server`区块包含一个或多个`location`区块。  \n\nNginx目录结构下包括上文提到的`nginx.conf`以及一个conf.d文件夹，conf.d文件夹下包括Nginx所有配置文件目，`nginx.conf`中会包含conf.d文件夹内的所有配置文件块。\n\nnginx包含由配置文件中指定的指令控制的模块。 指令分为简单指令和块指令。 一个简单的指令由用空格分隔的名称和参数组成，并以分号（;）结束。 一个block指令与简单的指令有相同的结构，但不是以分号结束，而是以一系列由大括号（{和}）包围的附加指令结束。 如果一个block指令在大括号内可以有其他的指令，它就被称为一个上下文（例如：events，http，server和location）。\n\n不考虑其他正向代理、负载均衡等功能，一般我们要部署一个前后端分离的项目，只需要在http模块下的一个server块中加入我们要部署的站点信息以及对应的配置即可。  \n下面给出一个简单的配置案例。  \n```nginx\nserver {\n    listen 80;  # 监听80端口\n    server_name www.foril.fun;  # 域名符合的才能匹配进去\n    location / {    # 请求地址（正则）\n    root /aaa/bbb;  # 相应文件的根目录\n    index index.html index.htm; # 在以上根目录下默认的响应文件\n    gzip on;    # gzip压缩启动\n    gzip_min_length 1k;\n    gzip_buffers 4 32K;\n    gzip_http_version 1.1;\n    gzip_comp_level 3;\n    gzip_types text/css application/javascript;\n    gzip_vary on;\n    }\n}\n```\n\n\n### 接下来列出其内容并加以注释。\n> 内容很多，作为文档参考使用。  \n> 来自W3Cschool[1]  \n\n```nginx\n######Nginx配置文件nginx.conf中文详解#####\n\n#定义Nginx运行的用户和用户组\nuser www www;\n\n#nginx进程数，建议设置为等于CPU总核心数。\nworker_processes 8;\n \n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log /usr/local/nginx/logs/error.log info;\n\n#进程pid文件\npid /usr/local/nginx/logs/nginx.pid;\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n# event 模块的主要功能就是，监听 accept 后建立的连接，对读写事件进行添加删除。\nevents\n{\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\n    #补充说明：\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\n    #A）标准事件模型\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\n    #B）高效事件模型\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\n    use epoll;\n\n    #单个进程最大连接数（最大连接数=连接数*进程数）\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。\n    worker_connections 65535;\n\n    #keepalive超时时间。\n    keepalive_timeout 60;\n\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\n    #分页大小可以用命令getconf PAGESIZE 取得。\n    #[root@web001 ~]# getconf PAGESIZE\n    #4096\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\n    client_header_buffer_size 4k;\n\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n    \n    #这个是指多长时间检查一次缓存的有效信息。\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\n    open_file_cache_valid 80s;\n\n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\n    open_file_cache_min_uses 1;\n    \n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误.\n    open_file_cache_errors on;\n}\n \n \n \n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp\n{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n\n    #默认文件类型\n    default_type application/octet-stream;\n\n    #默认编码\n    #charset utf-8;\n\n    #服务器名字的hash表大小\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\n    server_names_hash_bucket_size 128;\n\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\n    client_header_buffer_size 32k;\n\n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\n    large_client_header_buffers 4 64k;\n\n    #设定通过nginx上传文件的大小\n    client_max_body_size 8m;\n\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\n    sendfile on;\n\n    #开启目录列表访问，合适下载服务器，默认关闭。\n    autoindex on;\n\n    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n     \n    tcp_nodelay on;\n\n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n\n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;    #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n\n\n\n    #负载均衡配置\n    upstream jh.w3cschool.cn {\n     \n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n     \n     \n     \n    #虚拟主机的配置\n    server\n    {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.w3cschool.cn w3cschool.cn;\n        index index.html index.htm index.php;\n        root /data/www/w3cschool;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n         \n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n         \n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n         \n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n        \'$status $body_bytes_sent \"$http_referer\" \'\n        \'\"$http_user_agent\" $http_x_forwarded_for\';\n         \n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n         \n        #对 \"/\" 启用反向代理\n        location / {\n            proxy_pass http://127.0.0.1:88;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n             \n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n             \n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n         \n         \n        #设定查看Nginx状态的地址\n        location /NginxStatus {\n            stub_status on;\n            access_log on;\n            auth_basic \"NginxStatus\";\n            auth_basic_user_file confpasswd;\n            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n        }\n         \n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n         \n        #所有静态文件由nginx直接读取不经过tomcat或resin\n        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|\n        pdf|xls|mp3|wma)$\n        {\n            expires 15d; \n        }\n         \n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n    }\n}\n######Nginx配置文件nginx.conf中文详解#####\n```\n\n## 参考：\n- [1] [W3Cshool：Nginx 配置文件nginx.conf中文详解](https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html)\n'),(19,'Linux环境变量学习：su和su - 的区别',1,'2021-05-08 14:00:32',129,'之前一直没有注意过Linux切换身份的命令的不同，也没有注意过不同用户的环境变量问题。以为`su xxx`和`su - xxx`是同一个方法，直到有一次在运行hadoop时，发现找不到命令。明明记得在环境变量里加入过，但是`echo`也没打印出来。后来在排除下发现是并没有在全局配置环境变量，而是配在了当时用户的环境变量下，后来也没有搞明白`su`和`su - `不同用法，导致了问题的产生。  \n所以在理解这两个命令的区别之前，应该首先搞明白另一个概念。  \n\n## Linux环境变量  \nLinux是一个多用户多任务的操作系统，所以像我们在Windows中配置环境变量可以选择 *全局变量* 和 *用户变量* 一样，Linux也有不同上下文的环境变量。  \n### 环境变量的分类  \n* 按照生命周期来分：  \n1. **永久的**：需要用户修改相关的配置文件，变量永久生效。\n2. **临时的**：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。\n\n<br />\n\n* 按照作用域来分：\n1. **系统环境变量**：系统环境变量对该系统中所有用户都有效。\n2. **用户环境变量**：顾名思义，这种类型的环境变量只对特定的用户有效。\n\n### 设置环境变量  \n\n* 在/etc/profile文件中添加变量 对所有用户生效（**永久的**）\n\n* 在用户目录下的.bash_profile文件中增加变量 【对单一用户生效（**永久的**）】\n\n* 直接运行export命令定义变量 【只对当前shell（BASH）有效（**临时的**）】\n\n这里还有一篇讲解很详细的参考文章：[Linux环境下不同脚本文件配置的环境变量作用域范围的区别](https://blog.csdn.net/highfly591/article/details/42497007)  \n\n<hr />\n\n在解决了以上的问题后，来到我们的下一个话题：`su xxx`和`su - xxx`的区别。  \n\n先说结论，su命令和su -命令最大的本质区别就是：\n- 前者只是切换了root身份，<u>但Shell环境仍然是普通用户的Shell</u>；\n- 而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。\n\n我们查看su的帮助文档可以发现：\n\n```bash\n -, -l, --login                  make the shell a login shell\n```\n\n**区别就是**  \nlogin shell：此种方式登录时，shell会重新读取/etc/profile和~/.bash_profile来应用新的环境变量。\n\nnon-login shell：此时shell不会读取 `/etc/profile` 和 `~/.bash_profile`，而是读取 `~/.bashrc` 来应用新的环境变量。\n\n到这里，我们就解决了我们的问题，区分了`su xxx`和`su - xxx`的区别。\n\n\n## 参考：\n- [简书：Linux环境变量总结](https://www.jianshu.com/p/ac2bc0ad3d74)\n\n- [CSDN：login shell和non-login shell](https://blog.csdn.net/zzzhktk/article/details/8221133)\n\n- [CSDN：su 和su -的区别](https://blog.csdn.net/nayanminxing/article/details/76424115)\n'),(21,'专题：动态规划',3,'2021-05-15 04:08:03',191,'之前刷力扣都在刷日题，一段时间后感觉刷题有一点感觉了，但是收获不是很系统，近期决定做一段时间的专题，第一个专题就决定是动态规划。  \n\n## 定义  \n动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。\n以上是百度给出的定义，~~没什么参考价值~~其实按我个人理解，动态规划是一种用空间换时间的策略，记录之前的结果，状态转换方程利用之前的结果，然后快速得到答案。  \nDP的思想与分治法类似，都是把待求解的问题分解为多个子问题，不同的是适用于DP的问题往往不是互相独立的，有些子问题会被重复计算很多次。DP的做法是这些**已经解决的子问题答案保存下来**。\n\n### 引例：\n斐波那契数列\n```cpp\nint Fibonacci(int n) {\n	//0,1,1,2,3,5,8,...\n	//返回数列中第n个数\n	if(n==1 || n==2) return n-1;  //边界情况\n	int dp[n];  //记录方式\n	dp[0] = 0, dp[1] = 1;   //初始化\n	for(int i = 2; i<n; i++) {  //运算顺序\n		dp[i] = dp[i-1] + dp[i-2];  //状态转换方程\n	}\n	return dp[n-1];\n}\n```\n这个题目就是利用了简单的DP思想，是实际上这个题不需要数组，因为只用到了`dp[i-1]`和`dp[i-2]`，且最后不需要遍历找出最优，可以直接用两个变量代替，类似“滚动数组”。  \n\n\n## 核心问题\n\n对于动态规划的核心问题，我个人总结为4点：  \n1. 找到合适的记录方式  \n2. 找到状态转换方程\n3. 找到初始方法  \n4. 找到运算顺序  \n\n展开来谈：  \n### 找记录方式\n之前说DP以空间换时间，实际上就是指DP记录之前的运算结果并运用到新的计算当中。这就要求能够找到合适的记录方法，利用合适的记录方法将之前结果保存下来。 \n\n在近期刷题的经验中，发现DP会有很大概率**与字符串相关**，例如：  \n- [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n- [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n- [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n\n等等，都是DP的经典题目，实际上还会包括一些类似背包题目的其他问题。\n\n通常，DP会利用二维数组`dp[i][j]`记录从i到j的某些结果，或是一维数组`dp[i]`表示以`i`为开头或结尾的一些结果，之后按一定顺序转移计算。  \n\n其中需要**注意题目中给出的变量的范围**，我自己就遇到过选择了过大的二维数组然后发生溢出的错误。\n\n### 找到状态转换方程  \n决定了DP的记录方式以后，便需要通过对题目观察找到巧妙的状态转换方程，举个例子，一般`dp[i][j]`的转换方程可能利用到`i+1`、`j-i`这样的邻近结果，所以一般寻找时也需要从假设已知的状态写起。同时，要注意很多题目中状态转换方程存在条件变化，在不同的条件情况（例如`str[i]==str[j]`和`str[i]!=str[j]`）下，状态转换方程也会有所不同。  \n\n### 找到初始化方法\n有了状态转换方程，初始化方法就会比较轻松，一般是找到一些边界值，例如长度为`n`的字符串，常常会定义`n+1`的数组，下标0对应边界值；或是找到一些规律，例如二维数组***对角线***上的值和***边界***的值。这个过程往往需要从状态转换方程中找到灵感。\n\n### 找到运算顺序  \n同样，有了状态转换方程，运算顺序也比较好判断，假设`dp[i][j]`记录从i到j是否回文，实际上我们只用到了上三角的部分，有状态转换方程：    \n```\ndp[i][j]=dp[i+1][j-1] && str[i]==str[j]\n```  \n其中对角线的值为初始值，要知道`dp[i][j]`，实际上就是找对应矩阵上三角中 ***下一行前一列*** 的值。  \n在`i`固定的前提下，要确定`j`，就需要知道它前一个值，所以`j`的顺序必然是从前到后；  \n而对每一个`i`，要知道他的后一个值，所以应当从后往前运算。  \n之后就是实际的运算过程，在这个过程中，还需要注意一些边界情况。\n\n<img src=\"https://img.foril.space/DP.jpg\"  style=\"width:800px;margin:0 auto\" alt=\"DP例子示意图\" />\n\n\n\n## 能用动态规划解决问题的特点[1]  \n动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。  \n\n能采用动态规划解决的问题，一般要具有三个性质：\n\n1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。\n\n2. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。\n\n3. 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）\n\n\n在理解了以上要点后，个人觉得就应该多刷题去总结自己的经验了。  \n\n## PS  \n何时使用**回溯**，何时使用**动态规划**：    \n\n* 首先看取值范围，递归回溯一维数组，100就是深度的极限了   \n* 迷宫的***路径***是回溯； 迷宫的***路径的条数***用dp\n\n屡试不爽\n\n\n---\n\n## 参考：\n- [1] [知乎：动态规划](https://zhuanlan.zhihu.com/p/126361983)'),(22,'写于210516',2,'2021-05-16 03:25:32',85,'大概是大二的时候萌生了自己写一个博客的想法，记录平时解决一些问题的方法和学习新东西的笔记，但总觉得忙于学习和其他项目，没有机会真正落地。20年底，终于下定决心开始做，最初写了一版样式，在网上与别人的博客一比较，觉得排版很一般而且做得花里胡哨的。在第二个版本重新调整后有了现在的样式。  \n中途因为考试与课程，搁置了一段时间。到了四月份的时候心想不能再拖了，火速完成了前端，飞速写了一版简单的后端，说实话后端非常简陋，甚至没有用到ORM直接手撸了SQL，但至少是完成了基本功能。可结束后心里一直觉得不爽，想要 ~~重构~~ 重写一个版本。算是在这里立下一个Flag。  \n\n---\n\n*网站在四月份上线，写下这篇博客时学校的紫藤萝都开得差不多了。*  \n\n2021年五月，对我而言又是一个交叉路口，要面对保研升学的压力。本来没有想过保研的事情，觉得不用准备很多，随缘就好，最近突然有了压力，毕竟人人都想去一个更高的平台。  \n几天前刚刚结束了一门必修考试，考完才想到可能是本科阶段最后一门考试了（之后的课程大都是大作业的形式）。大三学业相比之下是轻松了不少，有了更多的时间去做自己想做的事。  \n随笔写下本篇，想到哪里就写到哪里，如果真的有读者看到这里，请不要在意我的语无伦次。  \n\n>向光生长'),(23,'Nginx上的HTTPS配置相关内容',1,'2021-05-17 13:57:15',131,'算上之前配的内网服务器，这应该是第三次配置HTTPS了，但每次或多或少都要搜索一些资料和配置说明，这次直接写在博客里，以供之后翻阅查找信息。  \n## 简单原理\nHTTPS 协议是由 **HTTP 加上 TLS/SSL 协议** 构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。  \n有HTTPS的加持，我们的网站传输的数据多了三道安全保证：  \n* 数据保密性  \n* 数据完整性\n* 身份校验安全性  \n\n有了HTTPS协议，浏览器与服务器之间的交互大概可以概括为一下几个过程。  \n\n1. 客户端向服务端发起建立HTTPS请求。\n\n2. 服务器向客户端发送数字证书。\n\n3. 客户端验证数字证书，证书验证通过后客户端生成**会话密钥**（双向验证则此处客户端也会向服务器发送证书）。\n\n4. 服务器生成会话密钥（双向验证 此处服务端也会对客户端的证书验证）。\n\n5. 客户端与服务端开始进行加密会话（通过会话密钥加密）。\n\n## SSL证书申请\n\n这一步实际上可以通过你的域名提供商申请一个SSL证书，对于大多数网站来说，申请个人免费的证书已经绰绰有余了，CA会使用生成一对服务器的公私钥，然后用CA的私钥加密服务器的公钥得到公钥证书，最后将公钥证书颁发给你。  \n\n经过上面的操作，我们就可以得到公钥证书以及服务器的私钥，这里我们就可以配置HTTPS协议的网站了。\n\n> 本站使用的是腾讯云颁发的免费SSL证书，要注意免费的SSL证书不能使用通配符域名，可以是一级域名或者二级域名。  \n\n## Nginx 配置\n\n一般得到SSL证书后，可以根据服务器的类型不同选择不同的证书类型下载。选择Nginx服务器下载证书后，会得到 `.key` 文件和 `.pem` 文件，分别是你的私钥文件和公钥证书文件。**（私钥文件一定不要泄露出去）**  \n\n之后，我们可以将这两个文件放在Nginx的配置文件目录下（例如`/etc/nginx`，也就是有`nginx.conf`的目录下）。  \n这里我们在`nginx.conf`的同级目录下新建一个`cert`文件夹，将两个文件放进去，之后只需要更改Nginx的配置文件指定公私钥的位置即可。  \n\n例如：\n```nginx\nserver {\n listen 443; # 监听443端口\n server_name localhost; # 这里放对应的域名\n ssl on;\n root html;\n index index.html index.htm;\n ssl_certificate   cert/a.pem; # 这里对应公钥证书文件\n ssl_certificate_key  cert/a.key; # 这里对应私钥文件\n ssl_session_timeout 5m;\n ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; # 需要根据你的 openssl 版本支持的算法套件来配置\n ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n ssl_prefer_server_ciphers on;\n location / {\n     # 这里就是你自己的location块设置\n     root html;\n     index index.html index.htm;\n }\n}\n```\n\n### HTTP请求转发\n可以在配置中多加入一个server块，监听80端口，并将请求转发给HTTPS的URL。\n```nginx\nserver {  \n    listen 80;  \n    server_name www.wenhaofan.com;  \n       \n    rewrite ^(.*)$  https://$host$1 permanent;  \n}\n```\n或者还有一个方法，直接在443的server块中同时监听80端口，并加入\n```nginx\nif ($scheme = http) {\n    return 301 https://$server_name$request_uri;\n}\n```\n将请求转发。\n\n## 其他\n这里记录一些遇到的因为不太理解导致的比较坑的过程以及对应的解决方法。  \n\n### 关于重定向次数过多\n在刚配完HTTPS并部署重启后，出现了后端请求失败，错误代码 `ERR_TOO_MANY_REDIRECTS` 重定向过多的情况，最后解决发现是出现cookie重定向网站，清除浏览器数据后，重新访问发现问题解决。\n\n### 关于HTTP资源请求失败\n在解决了以上问题后，访问一些博客内容发现用来存放图片等资源的对象存储OSS资源全部失效，查看发现是图片内容被重定向到HTTPS请求。  \n\n之前Chrome对于HTTPS站点的HTTP子资源是提示不安全但不阻止，查阅资料后发现，从2020年 12 月开始测试的 Chrome 79 开始，Chrome 将会逐步阻止所有混合内容。到 2020 年 1 月，Chrome 80 会将所有混合音频和视频资源自动升级为 HTTPS，如果无法通过 HTTPS 加载，则将自动被阻止。最终，在 2020 年 2 月，Chrome 81 将所有混合图像、音频与视频自动升级为 HTTPS，并且阻止那些无法通过 HTTPS 加载的图像。\n\n这个问题可以通过设置Chrome允许不安全内容解决，但不可能要求所有人都不能用新版Chrome，并且不安全内容本身也是不安全因素。于是决定将OSS存储服务也升级HTTPS，因为用的是`img.`子域名CNAME记录的CDN加速服务，又单独申请了SSL证书，在服务提供商升级了HTTPS请求，代价就是1GB两毛八的额外流量费用，不过至少问题是解决了。\n'),(24,'专题三：回溯法',3,'2021-05-29 12:42:35',58,'回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  \n\n这里列出我接触的两个利用了典型的回溯思想解决的问题：\n* [96. 不同的二叉搜索树II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)　　\n* [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\n\n## 个人简单总结\n\n从这两个题中我个人感觉到的规律就是这类问题一般有 ***两种类型*** ：\n* 第一种相较于原问题是一个序列长度缩小的子问题，通过将一个根问题化解为若干个规模变小的子问题，便可以使用递归解决问题；  \n* 另一种一般对于每一个选项都可以选或者不选（或类似思路），一般会有 $O(2^n)$ 的时间复杂度。 \n \n在 **递归函数中** 需要注意的几点有：  \n1. 先定义判断结束的返回，即出口  \n2. 将问题化解为小问题（或是选或不选两个方向调用递归函数回溯）  \n3. 此时递归回溯阶段，之前的问题已经得到解决，在这里根据之前的结果加以处理返回  \n\n读者可以根据以上总结来阅读以下代码：\n```cpp\nclass Solution {\nprivate: \n    vector<TreeNode*> generateTrees(int start, int end){\n        //定义出口\n        if(start>end){\n            return {nullptr};\n        }\n        vector<TreeNode*> res;\n        for(int i = start ;i<=end;i++){\n            /****化解为小问题******/\n            vector<TreeNode*> lefts = generateTrees(start,i-1);//递归\n            vector<TreeNode*> rights = generateTrees(i+1,end);\n            /*******************/\n\n            //这里已经进入回溯阶段\n            //利用结果分解当前问题\n            for(auto left:lefts){\n                for(auto right:rights){\n                    TreeNode* node = new TreeNode(i, left, right);\n                    res.push_back(node);\n                }\n            }\n        }\n        return res;\n    }\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        //回溯法\n        return generateTrees(1,n);  //问题所求\n    }\n};\n```\n\n接下来是学习笔记。  \n\n## 定义\n回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。\n\n回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n\n> 白话：回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。  \n\n## 典型问题\n\n### N皇后问题\n\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。（不能处在同一行，同一列，同一条斜线）\n\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n\n在实际撰写的过程中，发现思路并不难，但想要写出高效的题解不是一件非常轻松的事情。  \n\n## 1239. 串联字符串的最大长度\n### 题目　　\n\n给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。\n\n请返回所有可行解 s 中最长长度。\n\n \n\n示例 1：\n\n输入：arr = [\"un\",\"iq\",\"ue\"]  \n输出：4  \n解释：所有可能的串联组合是 \"\",\"un\",\"iq\",\"ue\",\"uniq\" 和 \"ique\"，最大长度为 4。  \n示例 2：\n\n输入：arr = [\"cha\",\"r\",\"act\",\"ers\"]  \n输出：6  \n解释：可能的解答有 \"chaers\" 和 \"acters\"。  \n示例 3：\n\n输入：arr = [\"abcdefghijklmnopqrstuvwxyz\"]  \n输出：26\n \n\n提示：  \n* 1 <= arr.length <= 16\n* 1 <= arr[i].length <= 26\n* arr[i] 中只含有小写英文字母\n\n\n### 思路：\n这个题目就是上面所说两个类型中的第二个——对于每一个选项都可以选或者不选，这里专门贴出题目的范围：数组长度不超过16，每个句子长度不超过26，就是因为回溯对时间和空间的开销都很大，这里给出的数字并不大，所以我们可以考虑采用回溯的方法解决问题。  \n基本思路很简单，对于每个字符串，只有选择或者不选两种，时间复杂度为 $O(2^n)$ ，根据刚才总结的三步，定义出口，然后分选择和不选择分别递归，在这里由于是找到最大值，所以在判断出口的位置就可以完成比较，回溯部分没有任务。\n```cpp\nclass Solution {\n    void bt(set<char>& set, int & maxR, int index, const vector<string>& arr, int inh){\n        maxR = max(maxR, inh);\n        int len = arr.size();\n        if(index==len) return;\n        int i = 0;\n        std::set<char> single_set;   //单句子查重\n        for(;i<arr[index].length();i++){\n            if(set.find(arr[index][i])!=set.end() || single_set.find(arr[index][i])!=single_set.end()){\n                //有一种情况是一个句子里有重复单词\n                break;  //不能加\n            }\n            single_set.insert(arr[index][i]);\n        }\n        if(i==arr[index].length()){\n            //能加，加        \n            for(int i = 0;i<arr[index].length();i++){\n                set.insert(arr[index][i]);\n            }\n            bt(set, maxR, index+1, arr, inh+arr[index].length());\n            for(int i = 0;i<arr[index].length();i++){\n                set.extract(arr[index][i]);\n            }\n        }\n        bt(set, maxR, index+1, arr, inh);\n    }\npublic:\n    int maxLength(vector<string>& arr) {\n        set<char> set;\n        int maxR = 0;\n        bt(set, maxR, 0, arr,0);\n        return maxR;\n    }\n};\n```\n这里代码不太美观，下面给出官方题解简洁的题解。  \n主要思路是利用**回溯 + 位运算**，这里利用位运算排除重复字母是一个比较巧妙的思路。mask是作为形式参数传入，记录已经出现的字母位置，每个字符串有一个位数组记录，通过`相与`判断是否已经出现对应字母，通过`相或`来加入对应的字符串字母。\n```cpp\nclass Solution {\npublic:\n    int maxLength(vector<string> &arr) {\n        vector<int> masks;\n        for (string &s : arr) {\n            int mask = 0;\n            for (char ch : s) {\n                ch -= \'a\';\n                if ((mask >> ch) & 1) { // 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解\n                    mask = 0;\n                    break;\n                }\n                mask |= 1 << ch; // 将 ch 加入 mask 中\n            }\n            if (mask > 0) {\n                masks.push_back(mask);\n            }\n        }\n\n        int ans = 0;\n        function<void(int, int)> backtrack = [&](int pos, int mask) {\n            if (pos == masks.size()) {\n                ans = max(ans, __builtin_popcount(mask));   // 数出所有字母数量\n                return;\n            }\n            if ((mask & masks[pos]) == 0) { // mask 和 masks[pos] 无公共元素   加入字符串（选择的情况）\n                backtrack(pos + 1, mask | masks[pos]);// 注意这里传入的是形参，mask没变，还是没有加入当前字符串的状态\n            }\n            backtrack(pos + 1, mask);   //（不选择）的情况\n        };\n\n        \n        backtrack(0, 0);\n        return ans;\n    }\n};\n```\n'),(25,'位运算符相关技巧',3,'2021-05-30 01:49:46',122,'这里想记录一些在做题过程中遇到的位运算相关技巧。\n\n## 二进制表示中最低位\n在位运算相关的题目中，有很多会与位 1 的个数相关。这里有个相关的小技巧。\n\n```cpp\nn & (n-1)\n```\n\n通过以上表达式可以将数 `n` 二进制表示的最低位 1 移除。原理是最低位1后会跟一些0，记最后一位 1 前的高位为 $a$ （`n`为2的幂时全为0），`n` 即 $a10000_2$  ，而`n-1`为 $a01111_2$ ，这两数相与便可以将最后一位 1 移除，而其他位 1 不受影响。\n\n这个技巧可以运用在很多地方，比如我们想统计数`n`中`1`的数量。  \n可以直接让`n`与`n-1`相与，直到`n=0`。代码如下：\n```cpp\nwhile (n) {\n    n &= n - 1;\n    ret++;\n}\n```\n## 判断是否是2的幂\n利用  \n```cpp\n(n&(-n))==n\n```\n可以用来判断正整数`n`是否是2的幂，利用计算机补码知识，可以知道`-n`即为`n`所有位取反加一，记最后一位 1 前的高位为 $a$ （`n`为2的幂时全为0），`n`即 $a10000_2$ ，而 `-n` 为 $\\overline{a}01111 + 1$ ，即 $\\overline{a}10000$ ，所以当`n`为2的幂时， `n` 和 `-n` 相与后仍然得到 `n` 。\n\n## 注意\n在进行位运算时，要时刻注意位运算优先级较低（数字较大），以上面判断是否是2的幂为例，应该使用  \n```cpp\n(n&(-n))==n\n```\n而不是\n```cpp\nn&(-n)==n\n```\n\n后者会先运算 `(-n)==n` 。  \n\n附上c++运算符优先级表:\n\n| 优先级 | 运算符              | 类          | 结合性  |\n|-----|------------------|------------|------|\n| 1   | ( )              | 括号运算符      | 由左至右 |\n| 1   | [ ]              | 方括号运算符     | 由左至右 |\n| 2   | !、 +(正号)、 - (负号) | 一元运算符      | 由右至左 |\n| 2   | ~                | 位逻辑运算符     | 由右至左 |\n| 2   | ++、–             | 递增与递减运算符   | 由右至左 |\n| 3   | *、/、%            | 算术运算符      | 由左至右 |\n| 4   | +、-              | 算术运算符      | 由左至右 |\n| 5   | <<、>>            | 位左移、位右移运算符 | 由左至右 |\n| 6   | >、>=、<、<=        | 关系运算符      | 由左至右 |\n| 7   | ==、!=            | 关系运算符      | 由左至右 |\n| 8   | &(位运算符AND)       | 位逻辑运算符     | 由左至右 |\n| 9   | ^(位运算负号XOR)      | 位逻辑运算符     | 由左至右 |\n| 10  | \\| (位运算负号OR)      | 位逻辑运算符     | 由左至右 |\n| 11  | &&               | 逻辑运算符      | 由左至右 |\n| 12  | \\|\\|               | 逻辑运算符      | 由左至右 |\n| 13  | ?:               | 条件运算符      | 由右至左 |\n| 14  | =                | 赋值运算符      | 由右至左 |\n\n'),(27,'力扣刷题笔记（三）',1,'2021-06-05 12:04:15',140,'第三篇刷题笔记 。  \n\n## 40. 组合总和 II\n\n### 题目　　\n\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n所有数字（包括目标数）都是正整数。\n解集不能包含重复的组合。 \n\n**示例 1:**\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n\n[  \n  [1, 7],  \n  [1, 2, 5],  \n  [2, 6],  \n  [1, 1, 6]  \n]  \n\n**示例 2:**\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n\n[  \n  [1,2,2],  \n  [5]  \n]  \n\n### 思路：\n这一题和上一题的不同在于有了**重复的数字**，上一个题中所有数字是排好了序的。这就会出现一部分结果相同但顺序不同的相同解重复的问题。  \n比如：`[1, 7] 和 [7, 1]`。这一点比较麻烦，我个人的题解中，是通过先将所有数字排序，这样相同的数字会在一起，就不会出现`[1, 7] 和 [7, 1]`这种情况，再利用set来除重，就有了这一种虽然低效但是也可用的解法。\n\n```cpp\nclass Solution {\nprivate:\n    set<vector<int>> ans;\n    void bt(vector<int>& v, int index, int remain, vector<int>& candidates){\n        if(remain==0){  //合格出口，加入结果\n            ans.insert(v);\n            return;\n        }\n        if(remain<0){   //不合格题解\n            return;\n        }\n        for(int i = index+1;i<candidates.size();i++){\n            v.push_back(candidates[i]); //加入当前数字，继续回溯\n\n            bt(v, i, remain-candidates[i], candidates); //递归试探\n\n            v.pop_back();   //试探结束后，为了继续使用其他数字，需要把影响复原，即再弹出当前数字。不用在意bt函数里进行了什么操作，只需要把当前自己加进去的数字删除即可\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<int> v;\n        bt(v, -1, target, candidates);\n        vector<vector<int>> ret;\n        ret.assign(ans.begin(), ans.end());\n        return ret;\n    }\n};\n```\n\n## 46. 全排列\n### 题目　　\n\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n\n示例 1：\n\n输入：nums = [1,2,3]  \n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  \n\n### 思路：\n按照我个人的思路，也是典型的回溯算法几个重要特征。\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    void backTrack(vector<int>& unused, vector<int>& shape ){\n        if(unused.size()==0){   //出口条件\n            res.push_back(shape);\n            return;\n        }\n        for(int i = 0;i<unused.size();i++){ \n            //加入当前数字需要做的变化\n            int tmp = unused.at(i);\n            unused.erase(unused.begin()+i);\n            shape.push_back(tmp);\n\n            backTrack(unused, shape);   //继续试探\n\n            //撤销所有影响\n            shape.pop_back();\n            unused.insert(unused.begin()+i, tmp);\n        }\n    } \n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<int> shape;\n        backTrack(nums, shape);\n        return res;\n    }\n};\n```\n\n\n## 542. 01 矩阵\n### 题目　　\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 。\n\n\n**示例 1：**\n\n输入：  \n[[0,0,0],  \n [0,1,0],  \n [0,0,0]]  \n\n输出：  \n[[0,0,0],  \n [0,1,0],  \n [0,0,0]]  \n\n### 思路：\n这个题一拿到手感觉像是动态规划的问题，但是每一个点的最小值可能是其上下左右四个值中最小值加一，我找不到合适的遍历方式，所以换了一个比较古怪的思路。\n### 方法一： \n所求答案矩阵`ans`和输入矩阵`input`形状一样，记为`m*n`的矩阵，将`ans`的所有值初始化为`INT_MAX`，以此遍历`i, j`，到每一个格时更新他为 0 或者 上下左右四个方向上的最小值加一（比原来的位置上距离小），每一轮遍历如果有更新，则继续遍历，直到没有更新为止。  \n这个方法实际提交能过，但是由于每一次有更新都可能需要多轮遍历来发散开，收敛相对很慢。所以提交结果比较差。\n\n```cpp\nclass Solution {\npublic:\n    \n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int rows = mat.size();\n        int cols = mat[0].size();\n        vector<vector<int>> res(rows, vector<int>(cols,INT_MAX));\n        int directions[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n        while(1){\n            //一直遍历直到没有更新\n            int count = 0;\n            for(int i = 0;i<rows;i++){\n                for(int j = 0;j<cols;j++){\n                    if(mat[i][j]==0 && res[i][j]!=0){\n                        res[i][j] = 0;\n                        count++;    //有更新\n                    }\n                    else{\n                        for(int k = 0;k<4;k++){ //四个方向\n                            int next_i = i+directions[k][0];\n                            int next_j = j+directions[k][1];\n                            if(next_i<0 || next_i==rows || next_j<0 || next_j==cols){\n                                continue;   //碰壁，下一个方向\n                            }\n                            if(res[next_i][next_j]!=INT_MAX && res[next_i][next_j] + 1 < res[i][j]){\n                                res[i][j] = res[next_i][next_j] + 1;    //更新最小值\n                                count++;    //有更新\n                            }\n                        }\n                    }\n                }\n            }\n            if(!count) break;  //没有更新\n        }\n        return res;\n    }\n};\n```\n\n### 方法二：动态规划  \n看了题解发现，虽然每一个格的的实际结果跟上下左右四个方向都可能有关系，但也可以通过动态规划解决这个问题，只需要分别考虑最近的 0 点在该点的**左上，左下，右上，右下**<u>四个方向上分别动态规划</u>，得到四个对应的`m*n`的矩阵，只需要每个点都取这四个矩阵中对应点的最小值，就可以得到最后的结果。\n```\n      |\n  zs  |  ys\n      |\n------1------\n      |\n  zx  |  yx\n      |\n```\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        // 初始化动态规划的数组，所有的距离值都设置为一个很大的数\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX / 2));\n        // 如果 (i, j) 的元素为 0，那么距离为 0\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    dist[i][j] = 0;\n                }\n            }\n        }\n        // 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1);\n                }\n                if (j - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1);\n                }\n            }\n        }\n        // 只有 水平向左移动 和 竖直向下移动，注意动态规划的计算顺序\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = 0; j < n; ++j) {\n                if (i + 1 < m) {\n                    dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1);\n                }\n                if (j - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1);\n                }\n            }\n        }\n        // 只有 水平向右移动 和 竖直向上移动，注意动态规划的计算顺序\n        for (int i = 0; i < m; ++i) {\n            for (int j = n - 1; j >= 0; --j) {\n                if (i - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1);\n                }\n                if (j + 1 < n) {\n                    dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1);\n                }\n            }\n        }\n        // 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = n - 1; j >= 0; --j) {\n                if (i + 1 < m) {\n                    dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1);\n                }\n                if (j + 1 < n) {\n                    dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1);\n                }\n            }\n        }\n        return dist;\n    }\n};\n\n```\n\n## 523. 连续的子数组和\n### 题目　　\n给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n\n* 子数组大小 至少为 2 ，且\n* 子数组元素总和为 k 的倍数。\n\n如果存在，返回 true ；否则，返回 false 。\n\n如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。\n\n### 思路：\n### 思路一：动态规划\n第一次提交，觉得这是一个动态规划题目，dp[i][j]记录从i到j的和。又根据题目，只要出现是k的倍数便可以停止遍历，不需要之前的结果，所以可以用两个变量分别记录上次结果（余数）和这次的数（余数），若为0便可以停止遍历。\n```cpp\nclass Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        int len = nums.size();\n        int before, curr;\n        //init\n        for(int i = 0;i<len;i++){\n            before = nums[i]%k;\n            for(int j = i+1;j<len;j++ ){\n                curr = (before + nums[j])%k;\n                before = curr;\n                if(curr == 0) return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n但是最后两个用例足有500KB，使用动态规划思想，时间复杂度为 $O(n^2)$ ，无法解决超时问题。\n\n### 思路二：前缀和 + 集合\n看到这个题目的关键字 **连续的** 、**数组和** ，应该想到利用前缀和，只需要分别计算从下标 0 到下标 i 的数组前缀和，只需要 $O(n)$ 的空间`sum[n]`，就可以知道任意从 a 到 b 的数组之和为`sum[b] - sum[a-1]`。这便是前缀和的思想。  \n值得注意的是一般从开头开始的序列需要减去值 0 ，我们可以通过开辟长度为`n+1`的数组或是初始化before变量为 0 来解决。\n```\n□□□□□□□□□\n-\n□□□□\n=\n    □□□□□\n```\n为了继续优化，我们考虑如果`sum[j] - sum[i]`即从`i+1`到`j`的数组和是`k`的倍数，则`sum[j]`和`sum[i]`的余数应该相同，可以使用一个**集合Set**来存放遇到过的所有余数，但要注意的是为了保证长度至少为2，我们应该在下一次遍历只后再放入上一次的余数结果。这样对于开头第一个数字，集合为空，对其他所有数字，看不到上一次的余数结果，就保证了长度至少为2。\n```cpp\nclass Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        int len = nums.size();\n        set<int> set;\n        int before = 0, curr;\n        for(int i = 0;i<len;i++){\n            curr = (before + nums[i])%k;\n            if(set.find(curr)!=set.end()) return true;\n            set.insert(before);\n            before = curr;\n        }\n        return false;\n    }\n};\n```\n\n## 416. 分割等和子集\n### 题目　　\n给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n### 思路：0-1背包问题\n容易想到的是，只需要判断是否能够从数组中选出一个子集使其和为原数组总和的一半即可。  \n因此将这个题转换为 `0-1背包问题` ，每个数字可以拿或者不拿，需要刚好凑够总和的一半。  \n\n### 最开始的判断\n先进行以下判断，之后才可以进行动态规划求解：  \n1. 总和 sum 是否为偶数，否则返回 false ，是偶数则令 target = sum/2\n2. 其中最大值是否大于 target ，是则直接返回 false ，如果没有这一步判断，在下面的动态规划中会导致下标访问直接溢出  \n\n### 动态规划\n创建二维数组 `dp[n][target+1]` ，包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。  \n**注意：** 需要 `target+1` 列来包括 `0~target`   \n\n```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);  //求和\n\n        //最开始的判断（防止溢出）\n        if(sum%2) return false;\n        int target = sum/2;\n        int maxNum = *max_element(nums.begin(), nums.end());\n        if(maxNum>target){\n            return false;\n        }\n\n        int len = nums.size();\n        vector<vector<bool>> dp(len,vector<bool>(target+1, false));\n        //初始化\n        for(int i =0;i<len;i++){\n            dp[i][0] = true;\n        }\n        dp[0][nums[0]] = true;\n\n        for(int i = 1;i<len;i++){\n            int num = nums[i];\n            for(int j = 1;j<=target;j++){\n                //状态转换方程\n                if(j - num <0){\n                    dp[i][j] = dp[i-1][j];\n                }else{\n                    dp[i][j] = dp[i-1][j] ||  dp[i-1][j-num];\n                }\n            }\n        }\n        //所需结果\n        return dp[len-1][target];\n    }\n};\n```\n\n## 525. 连续数组\n### 题目　　\n给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。\n\n### 思路：\n看到关键词 **“最长”** 、**“连续子数组”**， 可以想到本地可以使用 **前缀和+哈希表** 来解决。具体前缀和原理可参考上面 523. 连续的子数组和 。\n\n为了找到含有相同数量的 0 和 1 的最长连续子数组，可以使用一个变量 `count` 记录0和1的出现，见到1加一，见到的0减一。  \n也就是说，如果一个子数组 `[i,j]` 中 0 和 1 数量相同，这个区间的 `count` 应该为零，也就是 `count[j]-count[i-1] = 0` ，在实际的实现中，不需要数组来记录所有的count[i]，只需要使用一个哈希表，记录所有之前出现过的count，如果新的count在哈希表里，只需要比对是否是新的最大长度，否则就将这个count加入哈希表中。\n```cpp\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        int len = nums.size();\n        unordered_map<int, int> hashMap;\n        hashMap.insert({0,0});  //注意要加入初始值，如果使用数组保存，应该多声明一个，记录初始状态\n        int count = 0;\n        int max_num = 0;\n        for(int i =1;i<=len;i++){\n            //遍历每个数\n            if(nums[i-1]==1) count++;\n            else count--;\n            auto it = hashMap.find(count);\n            if(it!=hashMap.end()){\n                //存在\n                max_num = max(max_num,i - it->second);\n            }else{\n                //插入\n                hashMap.insert({count, i});\n            }\n        }\n        return max_num;\n    }\n};\n```'),(31,'专题四：并查集',3,'2021-06-08 08:25:46',61,'专门考察并查集的题目并不算多，与之前的专题相比，他不像是一类解决问题的思路，倒更像是一个工具，帮助我们给元素分组，分成不同的“帮派”，并可以方便的查找某两个元素是否是同一个组别中。  \n今天参加了一个ACM比赛，说实话自己接触算法不多，还是最近准备机试才开始刷题之旅，但从比赛的结果来看，确实也有很多的收获。最大的收获应该算是对于最近努力的肯定，让我有了更多的自信和坚持下去的动力。\n\n说回比赛，中间有一道题目，运用了克鲁斯卡尔生成树算法的思想，其中很重要的一部分是**并查集**的运用，在好容易完成代码的编写后提交却发现超时，换思路肯定是太费劲了，突然想到之前看到过不同的优化并查集的思路，于是当即翻出来加进代码，果然AC。第一次意识到是否优化代码的显著差别，时间差了将近十倍，也意识到了并查集优化的重要性，于是决定开专题将之前的学习笔记写下来，以便日后查阅。  \n\n## 并查集的目的\n简单的一句话——**元素分组**。  \n通过并查集，我们可以快速记录元素分组，并快速查询元素是否在统一分组中，这便是并查集最基础的使用目的。在克鲁斯卡尔算法中，我们用来判断是否当前剩下的最短边的起止结点在同一个连通分量中。  \n\n<img src=\"https://img.foril.space/stickPicture.png\" width=600 style=\"margin:0 auto\" alt=\"并查集\"/>\n\n而为了实现这一目的，要说到并查集的两个**基本操作**\n\n## 基本操作：\n1. 合并\n2. 查询\n\n这就是并查集的两个最基本的操作，通过这两个操作，我们就能实现对元素的分组操作。\n\n## 三个要素\n* 初始化  \n开始时，我们需要初始化将所有元素的根元素设为自己，也就是**每个元素自立帮派**。\n\n* 元素查询    \n要查询两个元素是否属于同一个分组，我们只需要查询他的根元素（**帮主**）是否是同一个人。  \n\n* 元素合并    \n相应的，要实现元素合并，就要选两个元素中的任意一个帮主，认另一个帮主作帮主（也就是当他的小弟！），这样我们之后查询两个元素的帮主应该就是同一个元素，我们也就认为他们是同一个分组。  \n\n我们直接上代码块理解并查集的这三个要素，实现了这三个要素，也就有了最基本的并查集，当然后期还有很大的优化空间。  \n\n* 初始化（每个人都做自己的帮主）\n```cpp\nint fa[MAXN];\ninline void init(int n)\n{\n    for (int i = 1; i <= n; ++i)\n        fa[i] = i;\n}\n```\n\n* 查询（递归）\n```cpp\nint find(int x)\n{\n    if(fa[x] == x) //如果帮主是自己\n        return x;\n    else\n        return find(fa[x]); //否则就去找帮主的帮主\n}\n``` \n\n* 合并\n```cpp\ninline void merge(int i, int j)\n{\n    fa[find(i)] = find(j);\n}\n```\n\n这样我们就写出了一个最基本的并查集，然而这个并查集还有很多需要优化的地方。\n\n## 优化\n### 问题一：路径太长（压缩路径）\n如果我们每次合并都只是单纯的让帮主认作别人的小弟，那么底下的小弟就需要通过多次查询才能找到自己真正的帮主，这就是这个并查集存在的第一个问题：**查询的路径太长**。    \n\n<img src=\"https://img.foril.space/stickPicture%20(1).png\" style=\"margin:0 auto\" alt=\"路径压缩\"/>\n\n我们可以**压缩路径**来解决这个问题，如果有一个元素存在帮主，我们就在查询的过程中将他的父元素设置为他的帮主，这样在之后的查询过程中就可以一次查询到根元素。  \n体现在代码中就是查询的代码发生了变化：\n```cpp\nint find(int x)\n{\n    return x == fa[x] ? x : (fa[x] = find(fa[x]));\n}\n```\n<img src=\"https://img.foril.space/stickPicture%20(2).png\" style=\"margin:0 auto\" alt=\"路径压缩\"/>\n\n\n当然这样的解决方案存在一个小小的弊端，就是只有在第一次查询之后路径才会被压缩，而不是建立的时候就已经压缩完成。\n\n### 问题二：生成的树太高（按秩合并）\n之前在说到在并查集元素合并的时候，两个元素任意选择一个作为新的帮主，这就会引发一个问题，我们生成的查找分组的树可能会变的很高很不平衡，我们可以**引入一个新的数组**记录所有元素下面的层数（秩数），在合并时，只需要让秩数较小的元素认秩数大的元素为帮主即可；如果两个元素秩数相同，只需要一个认另一个帮主，再将新的帮主秩数加一即可。  \n\n<img src=\"https://img.foril.space/stickPicture%20(3).png\" alt=\"按秩合并\" width=600 style=\"margin:0 auto\"/>\n\n#### 初始化加入变量\n```cpp\ninline void init(int n)\n{\n    for (int i = 1; i <= n; ++i)\n    {\n        fa[i] = i;\n        rank[i] = 1;    //引入新的变量\n    }\n}\n```\n\n\n#### 新的合并函数\n```cpp\ninline void merge(int i, int j)\n{\n    int x = find(i), y = find(j);    //先找到两个根节点\n    if (rank[x] <= rank[y])\n        fa[x] = y;\n    else\n        fa[y] = x;\n    if (rank[x] == rank[y] && x != y)\n        rank[y]++;                   //如果深度相同且根节点不同，则新的根节点的深度+1\n}\n```\n\n'),(32,'力扣刷题笔记（四）',1,'2021-06-17 12:16:29',119,'第四篇刷题笔记。\n## 494. 目标和\n### 题目　　\n\n给你一个整数数组 nums 和一个整数 target 。\n\n向数组中的每个整数前添加 \'+\' 或 \'-\' ，然后串联起所有整数，可以构造一个 表达式 ：\n\n* 例如，nums = [2, 1] ，可以在 2 之前添加 \'+\' ，在 1 之前添加 \'-\' ，然后串联起来得到表达式 \"+2-1\" 。\n返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n\n提示：  \n* 1 <= nums.length <= 20\n* 0 <= nums[i] <= 1000\n* 0 <= sum(nums[i]) <= 1000\n* -1000 <= target <= 100\n\n\n### 思路：\n#### 方法一：回溯\n这里我列出题目中的提示，重点是想说明题目要求的范围并不大，一共不超过20个数，所有数都是非负数且总和也没有超过1000，通过这样的提示，我们可以想到通过回溯解决问题，因为回溯的时间复杂度是 $O(2^n)$ ，所以只有在明确了题目中数字不会太大之后，我们才能考虑使用回溯方法。\n\n如果考虑使用回溯，那么这个题的思路就很明确了，定义出口是到了最后一个数字之后，否则分别考虑加减当前数字。\n\n```cpp\nclass Solution {\n    int res = 0;\n    void bt(vector<int>& v, int index, int target, int curr){\n        int len = v.size();\n        if(index==len){ //出口\n            if(curr == target) res++;\n            return;\n        }\n        \n        bt(v, index+1, target, curr+v[index]);\n        bt(v, index+1, target, curr-v[index]);\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        bt(nums, 0, target, 0);\n        return res;\n    }\n};\n```\n\n#### 方法二：动态规划\n同样因为这个题目中要求的范围很小，我们可以考虑通过动态规划解题，$dp[i][j]$表示通过前$i$个数可以得到$j$的方案数量，由此，答案所求即为$dp[n][target]$，状态转移方程为：  \n$$\ndp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]\n$$\n不过这里需要考虑的是，对每一个$i$，要检查**所有的** $j$，判断对 $i-1$ 得到的结果中能否得到$j-nums[i]$或是$j+nums[i]$，还要判断加减当前数字是否为越界。我们可以将状态转换方程，判断 $i-1$ 得到的结果中，不为一的数将他加减当前的数字。  \n\n另外要注意的是虽然总和不超过1000，但要考虑到如果全部是负号，会有-1000，所以需要开2001个空间加以映射。\n```cpp\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int* dp = new int[2001];//+1000\n        memset(dp, 0, 2001*sizeof(int));\n        int init = nums[0];\n        dp[init+1000] +=1;\n        dp[-init+1000] +=1;\n        int len = nums.size();\n        for(int i = 1;i<len;i++){\n            int* next = new int[2001];\n            memset(next, 0, 2001*sizeof(int));\n            for(int j = -1000;j<1001;j++){\n                if(dp[j+1000]>0){\n                    printf(\"dp[0][%d]>0\\n\",j+1000);\n                    next[j-nums[i]+1000] += dp[j+1000];\n                    next[j+nums[i]+1000] += dp[j+1000];\n                }\n            }\n            delete[] dp;\n            dp = next;\n        }\n        return dp[target+1000];\n    }\n};\n```\n\n\n## 31. 下一个排列\n### 题目　　\n\n实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须 原地 修改，只允许使用额外常数空间。\n\n示例 1：\n\n输入：nums = [1,2,3]  \n输出：[1,3,2]  \n示例 2：\n\n输入：nums = [3,2,1]  \n输出：[1,2,3]  \n示例 3：\n\n输入：nums = [1,1,5]  \n输出：[1,5,1]  \n示例 4：\n\n输入：nums = [1]  \n输出：[1]  \n\n\n### 思路：\n对于长度为 n 的排列 a：\n\n首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] < a[i+1] 。此时 [i+1,n)[i+1,n) 必然是下降序列。\n\n如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] < a[j] 。\n\n交换 a[i] 与 a[j] ，此时可以证明区间 [i+1,n) 必为降序。我们可以直接反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。\n\n官方简洁代码：\n```cpp\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int len = nums.size();\n        if(len==1) return;\n        auto it1 = nums.begin()+len-2;\n        auto it2 = it1+1;\n        while(it2!=nums.begin()){\n            if(*it1<*it2){\n                auto tmp = nums.end();\n                while(--tmp!=it1){\n                    if(*tmp>*it1){\n                        //交换\n                        swap(*it1,*tmp);\n                        break;\n                    }\n                }\n                sort(it1+1,nums.end());\n                return;\n            }\n            it1--,it2--;\n        }\n        sort(nums.begin(), nums.end());\n    }\n};\n``` \nPS:cpp自带api可以找到下一个字典序排序。  \n```cpp\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        next_permutation(nums.begin(), nums.end());\n    }\n};\n```\n\n## 33. 搜索旋转排序数组\n### 题目　　\n\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n示例 1：\n\n输入：nums = [4,5,6,7,0,1,2], target = 0  \n输出：4  \n示例 2：\n\n输入：nums = [4,5,6,7,0,1,2], target = 3  \n输出：-1  \n示例 3：\n\n输入：nums = [1], target = 0  \n输出：-1\n \n进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？\n\n### 思路：\n要求设计一个时间复杂度为$O(logn)$的算法，可以想到利用二分解决问题，但是本题目中的序列并不是有序的，好在题目是数组中的值各不相同，对任意一个下标的左侧或右侧必有一侧有序且可判断。  \n利用二分思想，找到中间点`mid`，如果左侧有序，判断目标在左侧有序范围内就更新右侧下标，不在左侧有序范围内，只可能在右侧，更新左侧下标，进入下一次循环。  \n同理如果右侧有序，判断目标在右侧有序范围内就更新左侧下标在右侧寻找，不在右侧有序范围内，只可能在左侧，更新右侧下标，进入下一次循环。  \n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int len = nums.size();\n        if(len==0) return -1;\n\n        int l = 0, r = len - 1;\n        while(l<=r){\n            int m = (l+r)/2;\n            if(nums[m]==target) return m;\n            if(nums[0]<=nums[m]){\n                //左侧有序\n                if(target>=nums[l] && target<=nums[m]){ //在左侧有序区间\n                    r = m - 1;\n                }else{  //只可能在右侧\n                    l = m + 1;\n                }\n            }else{\n                if(target>=nums[m] && target<=nums[r]){\n                    l = m + 1;\n                }else{\n                    r = m - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 16. 最接近的三数之和\n### 题目　　\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n示例：\n\n输入：nums = [-1,2,1,-4], target = 1  \n输出：2  \n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。  \n\n提示：\n\n* 3 <= nums.length <= 10^3  \n* -10^3 <= nums[i] <= 10^3  \n* -10^4 <= target <= 10^4  \n\n### 思路：\n最容易想到的自然是构造一个 $O(n^3)$ 复杂度的三重循环，寻找 `abs(a+b+c - target)` 的最小值，在题目中，数组长度为 $10^3$ ，这样的算法一般来说会超时，虽然我在力扣上试了一下，908ms居然都能AC。  \n更高效的想法是 **排序+双指针**，对整个数组进行升序排序，我们便可以利用排序的信息。\n遍历第一个数字`a`，后两个数字分别初始化为`a`后的最小的数`b`和最大的数`c`，接着判断`a+b+c - target`，若为负，将`b`右移，若为正，左移`c`，若等于零，可直接返回target，因为最接近的值必然是target。\n```cpp\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        int len = nums.size();\n        sort(nums.begin(),nums.end());\n        int recorder = INT_MAX;\n        int nearest = INT_MAX;\n        for(int i = 0;i<len-2;i++){\n            int j = i+1, k = len - 1;\n            while(j<k){\n                if(abs(nums[i]+nums[j]+nums[k]-target)<nearest){\n                    nearest = abs(nums[i]+nums[j]+nums[k]-target);\n                    recorder = nums[i]+nums[j]+nums[k];\n                }\n                if(nums[i]+nums[j]+nums[k]-target<0){\n                    j++;\n                }else if(nums[i]+nums[j]+nums[k]-target==0){\n                    return target;\n                }else{\n                    k--;\n                }\n            }\n        }\n        return recorder;\n    }\n};\n```\n实际上，每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 target 的值的关系，选择 **抛弃** 左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 11. 盛最多水的容器 中的双指针解法也是类似的。\n\n\n## 24. 两两交换链表中的节点\n### 题目　　\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1：\n\n输入：head = [1,2,3,4]  \n输出：[2,1,4,3]  \n\n示例 2：\n\n输入：head = [1,2,3]  \n输出：[2,1,3]  \n示例 3：  \n\n输入：head = [1]  \n输出：[1]  \n \n### 思路：\n之前说过做指针的题目重要的是理清思路一遍写完代码，这里先上自己的代码。\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode nullHead = ListNode(-1,head);  //加入一个空头指针\n        ListNode* l = head, * prev = &nullHead;\n        while(l!=nullptr){\n            ListNode* r = l->next;\n            if(r!=nullptr){\n                //交换\n                prev->next = r;\n                l->next = r->next;\n                r->next = l;\n                //更新l prev\n                prev = l;\n                l = l->next;\n            }else{\n                break;\n            }\n        }\n        return nullHead.next;\n    }\n};\n```\n官方有一种递归的解法，重要的是明白方法在栈中叠加，在回溯阶段解决问题的思路。\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);  //递归\n        //在回溯阶段解决问题\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n\n\n## 23. 合并K个升序链表\n### 题目　　\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n \n### 思路：\n最基础的思路就如同之前做过的两个升序链表合并，每次取出所有链表第一个元素中的最小值，然后构建新的链表。  \n在这里我们可以通过优先队列（最大堆）的数据结构来简化代码。  \n这里值得注意的是对`ListNode`做了包装，重载了小于号，使结构体能够直接作为优先队列的泛型，同时使最大堆成为最小堆。\n\n```cpp\nclass Solution {\npublic:\n    struct Status {\n        int val;\n        ListNode *ptr;\n        bool operator < (const Status &rhs) const {\n            return val > rhs.val;\n        }\n    };\n\n    priority_queue <Status> q;\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        for (auto node: lists) {\n            if (node) q.push({node->val, node});\n        }\n        ListNode head, *tail = &head;\n        while (!q.empty()) {\n            auto f = q.top(); q.pop();\n            tail->next = f.ptr; \n            tail = tail->next;\n            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});\n        }\n        return head.next;\n    }\n};\n```\n\n\n## 1530. 好叶子节点对的数量\n### 题目　　\n给你二叉树的根节点 root 和一个整数 distance 。\n\n如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。\n\n返回树中 好叶子节点对的数量 。\n\n提示：\n\n* tree 的节点数在 [1, 2^10] 范围内。\n* 每个节点的值都在 [1, 100] 之间。\n* 1 <= distance <= 10\n\n\n### 思路：\n这个题目比较有难度的是想到利用递归计算，因为题目中提示`distance<=10`这就给我们用一个数据结构记录他左右两部分不同距离的叶子节点数量的可能。\n\n我们通过递归，每一次向传递以当前节点作为根节点的距离在distance以内的叶子节点数量，同时传递当前节点以下的所有可能好叶子节点对数量。  \n这样，在每一次递归里，是需要计算左右孩子距离之和不超过distance的节点对数量，加上孩子节点传递的节点对数量再向上传递即可。  \n其中需要注意更新depths，阅读代码更能体会其中的思路。\n\n```cpp\n//递归\nclass Solution {\npublic:\n	pair<vector<int>, int> dfs(TreeNode* root, int distance) {\n		vector<int> depths(distance + 1, 0);\n		bool ifLeaf = !root->left && !root->right;\n		if (ifLeaf) {	//是叶节点\n			depths[0] = 1;\n			return make_pair(depths, 0);\n		}\n\n		//非叶节点\n		vector<int> leftDepths, rightDepths;\n		int leftCount, rightCount;\n		if (root->left) {\n			auto tmp = dfs(root->left, distance);\n			leftDepths = tmp.first;\n			leftCount = tmp.second;\n		}\n		if (root->right) {\n			auto tmp = dfs(root->right, distance);\n			rightDepths = tmp.first;\n			rightCount = tmp.second;\n		}\n\n		//更新depths\n		for (int i = 0; i < distance; i++) {\n			depths[i + 1] += leftDepths[i];\n			depths[i + 1] += rightDepths[i];\n		}\n\n		int count = 0;	//当前节点的左右孩子组合\n		for (int i = 0; i <= distance; i++) {\n			for (int j = 0; i+j+2 <= distance; j++) {\n				count += leftDepths[i] * rightDepths[j];\n			}\n		}\n		return make_pair(depths, leftCount + rightCount + count);\n	}\n\n	int countPairs(TreeNode* root, int distance) {\n		auto p = dfs(root, distance);\n		return p.second;\n	}\n};\n```'),(33,'01背包和完全背包',3,'2021-06-21 13:03:58',231,'一般来说，只要掌握了基本的 01背包问题 和 完全背包问题 就足够应付大多数面试。二者作为背包问题，区别就是对于物体的数量限制。\n## 01背包 和 完全背包 的区别\n01背包中不同物体只有一个，也就是说对于任一物体，只有选或不选两种选择，而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。  \n\n## 01背包\n有 N 件物品和一个最多能背重量为 W 的背包。第i件物品的重量是 weight[i]，得到的价值是 value[i]。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。  \n要素包括：  \n* N 件物品  \n* 容量为 W  \n* 重量列表 weight\n* 价值列表 value\n* 以及解决问题的前提：***每件物品只能用一次***，这也是01背包的关键特征  \n\n每个物品只能选或者不选，所以暴力解法的时间复杂度是 $O(2^n)$，指数级别。  \n所以需要动态规划来优化。  \n\n我们分别分析之前[动态规划专题](https://www.foril.space/article/21)中提到动态规划的要素：\n1. 找到合适的记录方式（确定dp数组以及下标的含义）  \n   典型的01背包，我们可以使用一个二维数组 $dp[i][j]$ 来表示到第 $i$ 个物品时容量为 $j$ 时背包的最大的价值。\n\n2. 找到状态转换方程  \n   根据记录方式,可以得到:  \n   $$\n    dp[i][j] = max\\{dp[i-1][j-weight[i]]+value[i], dp[i-1][j]\\}\n   $$\n   （这都得好好体会）\n3. 初始化  \n   根据记录方式，在 $j=0$ 时，背包的容量为 0，放不下任何物品，价值始终为 0，所以将 $dp[i][0]$ 赋值为 0。  \n   **注意**：常见的求最优解的背包问题中，有两种不太相同的问法。一种要求“恰好装满背包”时的最优解，一种则没有要求必须把背包装满。一种区别这两种问法的实现方法就是在初始化的时候有所不同。  \n   如果要求恰好装满背包，那么在初始化时除了 $dp[0][0]$ 为 0，其它 $dp[0][1..V]$ 均设为-∞，这样就可以保证最终得到的 $dp[M][N]$ 是一种恰好装满背包的最优解。  \n   如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 $dp[0][0..V]$ 全部设为0。  \n   可以这样理解： $j=0$ 时初始化的数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可能被价值为 0 的 `nothing` “恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。\n\n4. 找到运算顺序  \n   状态转换方程中都是通过当前的 $i,j$ 之前的结果得到的，所以 $i,j$ 都应该从小到大。\n\n之后便可以通过分析的结果运算01背包问题。  \n\n\n## 完全背包\n上面说到完全背包的物品数量是无限的，也就是说，有 N 种物品，每种物品有无限多个可以任取。  \n初始状态01背包和完全背包一致，当 i > 0 时 dp[i][j] 也有两种情况：  \n1. 不装入第i种物品，即dp[i−1][j]，同01背包；\n2. 装入第i种物品，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到dp[i−1][j−w[i]]而应该转移到dp[i][j−w[i]]，即装入第i种商品后还可以再继续装入第种商品。\n所以状态转换方程就是\n$$\ndp[i][j] = max\\{dp[i][j-weight[i]]+value[i], dp[i-1][j]\\}\n$$\n这个状态转移方程与01背包问题唯一不同就是max第一项不是dp[i-1]而是dp[i]。\n\n'),(34,'基于ALS协同推荐算法的简易购物推荐练习',1,'2021-06-28 07:44:13',114,'基于ALS协同推荐算法和SparkStreaming实时运算的的简易Kafka架构购物推荐练习。\n# 基于ALS协同推荐算法的简易购物推荐练习\n## 什么是ALS\nALS是交替最小二乘（Alternating Least Squares）的简称。  \n\nALS属于数据挖掘，可以做推荐系统，比如电影推荐、商品推荐、广告推荐等。  \n原理就是给各个指标，判定等加权重，然后将这些训练集输入ALS，包括其他的参数，内部进行矩阵相乘，根据这些权重，给用户未点击的商品也给一个分数，就是喜好程度。然后把喜好程度高的商品推荐给用户，假如用户不喜欢，从线上观察效果不好，那这个模型就有问题，需要修改参数，修改权重，或者添加权重，使之达到一个理想的效果!\n\n本项目做一个简易的基于ALS协同推荐算法的简易购物推荐练习，在只知道用户评分矩阵（即对于不同商品的评分）的情况下，向用户推荐商品。\n主要目的在于~~完成大作业~~ scala 的学习、MLlib的学习使用、sparkStreaming的学习使用等。\n\n## 开发流程\n### 架构搭建\n项目采用 Kafka 集群架构，Kafka能够提供消息队列，让生产者往队列的末尾添加数据，让多个消费者从队列里面依次读取数据然后自行处理。  \n> 但是，Kafka不仅仅是一套传统的消息总线，本质上Kafka是 **分布式的流数据平台**，因为以下特性而著名：  \n> 1. 提供Pub/Sub方式的海量消息处理。\n> 2. 以高容错的方式存储海量数据流。\n> 3. 保证数据流的顺序。\n\n<img src=\"https://img.foril.space/kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpg\" style=\"margin:0 auto\" alt=\"Kafka架构\" width=600px/>\n\n### 生产者模拟数据\n有了Kafka的存在，我们可以编写程序mock出模拟数据，这里我们只需要模拟用户ID，用户打分和对应的商品ID，利用一个线程池分别模拟数据，模拟出的数据作为生产者产出到我们的虚拟机上的Kafka集群中。（因为没有数据，同时我们也模拟出了用来训练模型的数据）  \n这一步注意需要提前在Kafka集群上建好topic：\n```\nkafka-topics.sh --create --partitions 3 --replication-factor 2 --topic rate --zookeeper node91:2181,node92:2181,node93:2181\n```\n\n<img src=\"https://img.foril.space/%E5%88%9B%E5%BB%BAtopic.jpg\" style=\"margin:0 auto\" alt=\"创建topic\" width=800px/>\n\n这里在模拟出数据了之后可以模拟消费者查看是否能够拉取到数据:\n```\nkafka-console-consumer.sh --bootstrap-server node91:9092,node92:9092,node93:9092 --topic rate --from-beginning\n```\n效果如图：\n\n<img src=\"https://img.foril.space/%E6%A8%A1%E6%8B%9F%E6%B6%88%E8%B4%B9%E8%80%85.jpg\" style=\"margin:0 auto\" alt=\"模拟消费者\" width=600px/>\n\n### 训练模型\n在下一步之前，我们可以通过之前模拟出的训练集，使用MLlib训练ALS模型并保存，这里我将模型保存在项目文件中，并将模型的地址保存在redis中。  \n将80%的模拟数据作为训练集，20%的数据作为测试集。（因为数据本身也是随机模拟，没有采用交叉验证）  \n\n### 利用模型实时推荐\n之后便可以在SparkStreaming中作为Kafka的消费者，对模拟出的每一个用户进行商品推荐了。推荐的结果可以按照需求存储，这里放入redis。\n\n<img src=\"https://img.foril.space/redis%E6%8E%A8%E8%8D%90%E7%BB%93%E6%9E%9C.jpg\" style=\"margin:0 auto\" alt=\"reids推荐结果\" width=600px/>\n\n\n项目后期加入[git仓库](https://gitee.com/foril/als_model_prac)，代码较草率，轻喷。\n'),(35,'初探符号执行',1,'2021-07-06 08:31:20',221,'符号执行技术在如今软件测试领域受到了越来越多的关注，现在已经在测试和查找各种软件中的错误方面证明是有效的，这些软件低至低级网络和操作系统代码，高至高级应用程序代码。很幸运在与老师的接触中，了解到了符号执行领域相关的知识，这篇文章记录在阅读了相关领域的文章后的一些学习笔记。  \n在阅读了帝国理工大学的 Cristian Cadar 的 [《Symbolic execution forsoftware testing: three decades later》](https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795)[1] 后，我对符号执行有了基本的认识，下面简述一下我的理解。  \n\n## 什么是符号执行\n符号执行是一种软件测试技术，从名字出发，大概意思是指利用符号而不是具体数值作为输入，进行代码的执行。  \n符号执行相关思想在上世纪八十年代就被提出，而在近代，随着约束可解性的进展，符号执行也得以蓬勃发展。其最核心的思想是利用符号值（*symbolic values*）代替具体的输入，从而将变量的值用基于符号的符号表达式（*symbolic expressoins*）来表达，最后得到的输出也是一个关于符号的函数。  \n\n### 能干什么\n作为一种软件测试技术，符号执行的关键目的是在给定的时间内探索（并检测）尽可能多的不同程序路径。  \n\n手动规范测试要求输入值是一笔很大的开销，且不能保证在测试期间观察到所有可能的行为。  \n为了改进观察到的行为范围（或测试覆盖范围），我们引入了各项技术，其中之一是随机生成潜在的测试数据，这种方法有着很明显的缺点：\n* 一是很产生很多结果相同的冗余用例\n* 二是想要尝试出会导致bug的输入用例的可能性非常小\n\n而另一种提出的方法就是我们要说的符号执行。如上文所说，在符号执行中，我们使用符号变量代替输入值来执行程序。程序中的每个条件表达式都表示一个确定执行路径的约束。其目标是为输入生成具体的值，从而导向不同的路径。选择路径的策略对分析的质量有很大的影响，经典的方法是使用通过回溯对路径的深度优先探索。\n\n而且符号执行具有能够生成高覆盖率测试用例和发现复杂应用中深层错误的特性，从生成测试用例和寻找程序缺陷两方面出发，符号执行的优势在于：  \n* 生成高覆盖率的测试用例\n* 提供触发bug的具体输入\n\n与其他程序分析技术相比，符号执行不限于查找缓冲区溢出等宽泛的错误，而是可以推理更高级的程序属性，如复杂的程序断言。\n\n## 传统符号分析\n在接触传统的符号分析之前，我们需要先明确几个概念。\n### 执行路径\n当我们在代码的执行过程中遇到程序分支时，我们将选择的布尔值连接，得到的就是我们走到当前路径点的执行路径，也就是说，执行路径就是一个由布尔值构成的序列，第`i`个值代表第`i`次分支的条件语句值。\n### 执行树\n执行路径通过树来表示。\n\n<img src=\"https://img.foril.space/%E6%89%A7%E8%A1%8C%E6%A0%91.jpg\" style=\"margin:0 auto\" alt=\"执行树示意\" width=700px/>\n\n这里注意图中绿色方块中代表的就是对应路径下的一个case。  \n而我们在符号分析的过程中的目标，就是希望通过 *constraint solver* 得到的具体值，关于这些会在下文继续说明。  \n\n有了以上概念的补充，接下来我们可以进入传统的符号执行技术的具体定义。   \n### 组成\n传统的符号执行主要包括两部分内容：  \n1. 一个符号状态 $\\sigma$ ：就是一个映射（函数），初始为空，存放**对应变量**在当前执行路径下的**表达式**（如 {z→2y, z→y}）\n2. 路径约束PC（*path constraint*）：针对对应执行路径下的路径限制，即需要满足的无量词一阶公式，初始为真。\n\n> 这里需要解释一下所谓**无量词一阶公式（quantifier-free first-order formula）**  \n> 根据维基百科，*First-order logic—also known as predicate logic* ，这里的first-order指的是一阶逻辑，也就是谓词逻辑，与零阶逻辑（命题逻辑）区别    \n> 在离散数学的知识中，我们知道谓词逻辑中有存在量词（existential quantifier）和全称量词（universal quantifier），这里的无量词，也就是在约束PC中不能包括量词  \n> 综合上面的定义，无量词一阶公式，就是将命题用逻辑连接词析取、合取、非连接即可（不包括量词）。\n\n我们在程序执行时，PC 和 $\\sigma$ 随着程序的执行而更新，在一条路径的尽头，用*constraint solver*来解出一个约束对应的具体值，即可作为当前路径的输入。*constraint solver* 作为另一个研究领域，这里不再详细讨论。  \n\n在路径中，每遇到一个条件判断（if），第一条路径为真，PC更新为 `PC ∧（命题为真条件）`，第二条为假，新增一个符号执行，加入 σ 并以 `PC ∧（命题为假条件）` 作为新的PC，这一步就是**约束收集**。直到路径出口或是遇到错误就可以利用 *constraint solver* 解出具体的值。\n\n### 基本实现\n关于基本实现的内容，我们可以在2010年卡耐基梅隆大学的一篇论文 [All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)](https://ieeexplore.ieee.org/abstract/document/5504796)[2] 中得到大概的认识，文中首先给出了一个简单语言 *SIMPIL* 的语法定义和操作语义。\n\n<img src=\"https://img.foril.space/%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99.png\" style=\"margin:0 auto\" alt=\"语法定义\" width=700px/>\n<img src=\"https://img.foril.space/%E6%93%8D%E4%BD%9C%E8%AF%AD%E4%B9%89.png\" style=\"margin:0 auto\" alt=\"操作语义\" width=700px/>\n<img src=\"https://img.foril.space/%E5%85%83%E8%AF%AD%E6%B3%95%E5%8F%98%E9%87%8F.png\" style=\"margin:0 auto\" alt=\"元语法变量\" width=700px/>\n\n\n上面三张图片定义的简单语言可以帮助我们更好地理解符号执行的具体方法，注意语法从下往上阅读。  \n要实现符号执行，我们只需要新加入一个上下文变量 $\\Pi$，记载当前路径下的约束；\n\n<img src=\"https://img.foril.space/%E8%AF%AD%E6%B3%95%E5%8A%A0%E5%85%A5%E5%8F%98%E5%8C%96.png\" style=\"margin:0 auto\" alt=\"加入变量\" width=700px/>\n\n同时执行语义加以简单变动，更新变量 $\\Pi$。  \n\n<img src=\"https://img.foril.space/%E6%93%8D%E4%BD%9C%E8%AF%AD%E4%B9%89%E5%8F%98%E5%8C%96.png\" style=\"margin:0 auto\" alt=\"更新变量\" width=700px/>\n\n文中通过这样的语言定义针对具体的例子给出了如何创造一个简单的符号执行引擎，并提出了遇到的问题和一些简单的解决方案，这里不再展开，感兴趣的读者可以自行阅读。\n\n另外，在具体的实现中还要注意在路径中遇到循环或是递归导致执行路径无限长的情况，需要加入限制，我们一般用超时、路径数量、循环迭代次数或探索的深度等指标加以限制，将无穷限制改为多个重复命题合取。  \n例：$N_i>0$为判断条件，当前的PC即可写为\n$$\n(\\bigwedge\\limits_{i\\in[1,n]}N_i>0) \\wedge(N_{n+1}\\leq0)\n$$\n### 限制\n在传统的符号执行中，所有输入都用符号代替，可能遇到的最大的限制就是约束不可求解的问题，这里举两个情况：\n1. 所执行的过程不可见（e.g.系统函数或闭源函数）；\n2. 所执行的过程不能被*constraint solver*计算，可以假设不能进行非线性的运算。\n\n以上两种情况，PC都不能被解出具体的数值，也就不能产生输出，为了解决这种问题，我们引出了现代的符号分析技术，以及其为了缓解不可解问题做出的取舍。　　\n***\n## 现代符号分析技术\n现代符号分析技术的重要特性就是**具体值和符号执行的混合**，也称动态符号分析技术。\n### Concolic测试：导向性随机测试（DART）\n以Concolic测试为例，在执行向下探索时，除了传统的符号状态 $\\sigma$，还会保存一个具体值的映射，映射的具体值也会在路径更新时通过 *constraint solver* 更新。  \n需要注意的是由于Concolic测试需要维护具体值，需要初始具体的值（指定或随机）。\n\n### 执行生成测试（EGT）\nEGT的本质还是具体值和符号执行的混合，他的具体操作方式是区分程序的具体状态和符号状态来工作：在每次执行前，检查值是否为具体的，如果是具体值，直接运算，否则，如果至少有一个值是符号值，就通过符号执行。  \n因此，在需要具体值时，EGT可以随时通过约束计算出一个具体值代入，这一点与Concolic测试**一直维护**一个具体值的映射做区别。  \n\n***\n综上，在现代符号执行技术中，由于采用了混合具体状态和符号状态，需要着重注意的一点就是如何做出**权衡**：  \n在与外界函数或者约束不可解的问题打交道时，动态符号执行采取的策略是利用具体值代替符号值，这样的问题就是可能会导致路径的丢失、完整性下降，所以必须要做出相应的权衡。\n\n## 挑战和一些解决方法\n在代码执行技术领域，目前遇到的主要挑战可分为以下四个：  \n### 路径爆炸\n这主要是指由于动态符号执行的过滤能力不足，程序中路径的指数型增长爆炸问题，当前比较流行的解决方案有：\n* 启发式技术对路径划定优先级  \n  主要利用随机探索或其他手段优先选择一些路径\n* 程序分析技术（减少程序复杂性）  \n  1. 静态合并一些路径，由于时间限制，具体采取的技术暂且不谈\n  2. 缓存和重用后续计算中的低级函数分析来改进符号执行，大概思想是重用类似属性的简单函数结果到复杂函数中（存疑）\n  3. 在路径探索过程中剪枝，删去冗余路径（如同一个程序点下约束相同的输入）\n\n### 约束求解\n\n上面说符号执行是在约束求解领域取得快速进展后快速发展，而实际上约束求解问题仍是现在符号执行领域最主要的瓶颈之一。  \n下面介绍两种具有代表性的优化：\n1. 不相关约束消除：  \n   对于当前分支约束求传递闭包，与**当前分支**无关的变量可忽视。\n2. 增量求解：  \n   **缓存**之前的限制和求解具体值，子集直接使用，超集判断是否可用（通常可用）。\n\n### 内存建模\n将程序语句转换为符号约束的精度会对符号执行实现的覆盖范围以及约束求解的可伸缩性产生显著影响。例如，使用实际整数代替内存中的定长证书数学模型可能有效，但可能会导致例如溢出等的边界用例的不精确问题。  \n\n还有对于指针问题的约束求解，一类代表是像DART这样的系统，它只解决具体指针的问题，或者像CUTE和CREST这样只支持指针的相等和不等的约束的系统，这类系统难题已被很好解决。另一类是EXE等使用数组理论来建模指针的基于STP或Z3这样的求解器实现的系统。\n\n同时应该非常注重在精度和约束求解的伸缩性之间的权衡，这种权衡常常基于被分析的代码的规模以及其处于系统中的层次。\n\n### 并发问题\n由于并发程序不确定性的内在属性，对并发程序的测试往往非常困难。尽管存在这些挑战，但动态符号执行已被有效地用于测试并发程序，包括具有复杂数据输入的系统、分布式系统和GPGPU应用程序。\n\n***\n以上就是代码执行技术领域，目前遇到的主要挑战。\n\n\n\n## 参考文献：\n[1]Cadar C, Sen K. Symbolic execution for software testing: three decades later[J]. Communications of the ACM, 2013, 56(2): 82-90.\n\n[2] Schwartz E J ,  Avgerinos T ,  Brumley D . All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)[C]// 31st IEEE Symposium on Security and Privacy, S&P 2010, 16-19 May 2010, Berleley/Oakland, California, USA. IEEE, 2010.\n'),(36,'在js中使用装饰器',1,'2021-09-11 03:13:50',128,'装饰器（Decorator）是一种与类相关的语法，用来注释或修改类和类方法。很多面向对象语言都有装饰器这种语法，值得注意的是，js并不是严格意义上的面向对象语言，称它是一种“*基于对象的语言*”应该更合适。在es5中，并没有太多对于装饰器的需求，但在es6中，随着class作为一种语法糖的出现，装饰器的便利性得到了体现，逐渐变得流行。\n\n## 装饰器的本质\n装饰器实质是上就是一段功能函数，放在类和类方法的定义前面，但不同于普通函数的是，它的**执行是在代码的编译阶段**，而普通函数的执行需要等到代码运行时，所以装饰器的实质是在**对编程语言进行编程**，属于元编程的一种思想。\n\n```js\n//使用示意\n@decorator_function\nclass ClassName{\n    ...\n}\n```\n\n## 装饰器的配置\n目前装饰器提案[[1]](https://github.com/tc39/proposal-decorators)处在Stage 2[2]，node以及各浏览器均不支持装饰器的语法，所以我们需要使用babel插`@babel/plugin-proposal-decorators`来转换代码。\n\n### 配置webpack\n如果使用webpack来打包项目，通过简单配置webpack就可以使项目支持装饰器语法。  \n\n首先下载webpack\n```bash\nyarn add -D webpack webpack-cli\n```\n下载babel依赖\n```bash\nyarn add -D babel-loader @babel/core @babel/preset-env @babel/plugin-proposal-decorators\n```\n创建`webpack.config.js`\n```js\n//webpack.config.js\nvar path = require(\'path\')\nmodule.exports = {\n    mode: \"development\",\n    entry: { main: \"./index.js\" },\n    output: {\n        path: path.resolve(__dirname, \"./build\"),\n        filename: \"build.js\"\n    }, module: {\n        rules: [\n            {\n                test: /\\.m?js$/,\n                exclude: /(node_modules|bower_components)/,\n                use: {\n                    loader: \'babel-loader\'\n                }\n            }\n        ]\n    }\n}\n```\n配置babel支持装饰器语法\n```json\n//.babelrc\n{\n    \"presets\": [\n        \"@babel/preset-env\"\n    ],\n    \"plugins\": [\n        [\n            \"@babel/plugin-proposal-decorators\",\n            {\n                \"legacy\": true\n            }\n        ]\n    ]\n}\n```\n在这里为了便于演示，简单修改package.json部分字段\n```json\n{\n    \"scripts\": {\n        \"build\": \"webpack\",\n        \"start\": \"node ./build/build.js\"\n    },\n}\n```\n接下来就可以在代码中使用装饰器语法了！\n> **PS**  \n> 如果使用VSCode做编辑器，可能会出现编辑器对装饰器语法依然报错的情况，可以在项目根目录下创建`jsconfig.json`配置VSCode对语法的支持。\n> ```json\n> //jsconfig.json\n> {\n>     \"compilerOptions\": {\n>         \"experimentalDecorators\":true,\n>     },\n>     \"exclude\": [\n>         \"node_modules\",\n>         \"dist/*\"\n>     ]\n> } \n> ```\n\n## 装饰器的常用写法\n装饰器 `@` 后必然需要接一个函数，这个函数需要带一个参数，也就是被装饰的类。  \n**需要注意的是`@`后的函数名带不带括号，带括号表示对函数的调用，调用的返回值不一定是函数**\n\n### 基础用法\n```js\n@fn\nclass MyClass{\n    message = \'hello\'\n}\n\nfunction fn(target){\n    //在类上加入静态属性\n    target.foo = \'bar\'\n}\n\n//注意是类的静态属性\nconsole.log(MyClass.foo)    //bar\n```\n\n### 加入参数的装饰器\n```js\n// 注意decorator后有没有括号，@后一定是一个函数\n@fn2(20)\nclass MyClass{\n    message = \'hello\'\n}\n\nfunction fn2(value){\n    //返回一个函数\n    return function(target){\n        target.count = value\n    }\n}\n\nconsole.log(MyClass.count)  //20\n```\n\n### 给类的实例加入属性\n```js\n@fn3\nclass MyClass{\n    message = \'hello\'\n}\n\nfunction fn3(target){\n    //target.prototype\n    target.prototype.foo = \'bar_ins\'    //给类的实例加入属性\n}\n\nconst c1 = new MyClass();\nconsole.log(c1.foo) //bar_ins\n```\n\n### 修饰类成员\n```js\nclass MyClass{\n    @fn4 message = \'hello\'\n}\n\n//修饰类成员，3个参数\nfunction fn4(target, name, descriptor){\n    console.log(target)             //目标类的.prototype\n    console.log(name)               //被修饰的类成员的名称:message\n    console.log(descriptor)         //被修饰的类成员的描述对象\n\n    //descriptor下有一些对成员的属性描述\n    descriptor.writable = false     //只读\n    descriptor.enumerable = false   //不能被遍历 \n}\n\nconst c1 = new MyClass();\nc1.message = 123    //error，不允许对只读属性赋值\n```\n\n## 参考：\n- [1] [ES6—Decorator，装饰器简介](https://zhuanlan.zhihu.com/p/55086365)\n\n\n## 注解\n\n> ## [2] TC39 Stage Process (TC39 的 Stage 阶段进程)\n> * 阶段 0：Strawperson 稻草人——代表目前仅仅是一个想法。  \n> * 阶段1: Proposal 提案——当想法变成提案，就需要进入阶段 1，面向委员会讲解和介绍，你需要概述解决方案，并且提出一些潜在的困难。委员会可能会接受你的提案，但并不代表就要在浏览器中生效。它仅仅是委员会觉得这是一个值得讨论的议题且愿意继续讨论。  \n> * 阶段2: Draft 草案——进入这一阶段的讨论会更加严肃，需要讨论具体的语法和语义的细节。你需要提供具体的解决方案，如何在语言中实现它，就像一个具体的 API 的实现。\n> * 阶段3: Candidate 候选——这个阶段设计的工作已经结束，你需要接受来自具体实现者和用户们的反馈。这个阶段也会有不同的 JavaScript 引擎来实现你的新特性。  \n> * 阶段4: finished 结束——一旦这个特性被添加进至少两个 JavaScript 实现并且通过具体的测试，代表着可以被大家使用了，提案的标准和规范也会进入到主要的标准规范中，我们会制定测试去保证未来的实现都会包含这项特性，也会添加参考文档。'),(37,'关于保研——我所知道的',2,'2021-09-13 13:31:35',303,'写下这篇文章时，我的夏令营早已结束，只是因为怠惰，没有当时及时写下自己的面试经历。先说我本人的情况，我很幸运地在夏令营阶段就拿到了心仪的offer，于是也决定放弃之后的预推免环节（主要是想提前躺平），所以八九月对我来说，是一个相当空闲的阶段，可以放开心去做一些自己想做的事情。这篇文章，我想从一下几个角度展开，跟有需要的学弟学妹说说我的经历和一些简单的经验：\n1. 什么是保研\n2. 我的夏令营经历\n3. 面试流程\n4. 经验心得\n\n想我自己在五六月临近保研季的时候，对整个保研流程仍是一窍不通，不知道什么是夏令营什么是九推十推，应该算是准备比较晚的，所以我觉得很多和我类似情况的学弟学妹首先最应该对保研的流程有一个大致的认识和心理准备。  \n## 什么是保研\n所谓保研，其实就是高校具有推荐免试生资格，国家下放推免名额，拿到推免名额的同学（也就是具有保研资格的同学）可以在9月28日至10月20日通过 [推免服务系统](https://yz.chsi.com.cn/tm/) 填报志愿、接收并确认招生单位的复试及待录取通知。目前全国共有300多所高校具有推荐免试生资格，不同的学校保研率不同，比如一般清北能有50%左右，一般的985高校能有20%左右，所以具体自己能否在大三学年结束的时候拿到推免名额就需要自己去详细查看学院的政策，大部分高校会参考学习成绩、优秀学生单项奖学金等方面下发推免名额，同时还有一部分专项保研名额，我们学校就有科创保研、支教保研等专项，不过这种专项保研可能会有只能保本校之类的限制。  \n所以一些在保研边缘不确定能否拿到推免名额的同学也可以大胆尝试，很多学校入营的条件都会对成绩放得很宽，可能只需要前30%就可以报名，哪怕没有拿到保研名额，这段推免经历也会在你成长过程中留下很深的印象。  \n\n所以这里产生的问题就是：学校要如何决定录取哪些学生？这就是夏令营和九推十推存在的意义，各个学校会举办自己的夏令营和推免活动来筛选优秀生源（抢人），得到学校认可的同学会得到学校发的**优秀营员**（一般就是拟录取资格，**具体查看学院通知**）。夏令营没有招满或是被咕咕咕的名额会在九月十月预推免（**九推十推**）时继续放出，当然也有很小一部分学校夏令营会超发（比如所谓*良好营员*），也就可能没有预推免活动。  \n夏令营一般会包括参观和考察等环节，很多学校会报销入营的学生的差旅费并解决夏令营期间的食宿问题（相当于简单的公费旅游，带一点考试的那种）。而九推十推就会直接一点，自己出钱去学校参加考试之后等待结果即可。\n\n需要说的是在填系统确认之前你和学校达成的所有协议都是一种契约精神，你可以向学校说明放弃名额，我的建议是拿到了更好的offer就一定及时释放确定不会去的offer，以免影响其他学校招生，恶劣的放鸽子行为可能会影响你的学弟学妹的保研。\n\n## 关于推免流程\n### 怎么准备\n夏令营的准备自然是越早开始越好，最好是四五月份就开始着手复习，能在六七月更加自信。以计算机、软件专业来说，夏令营、推免一般包括机试面试两部分。  \n#### 机试\n机试就是类似力扣类型，我之前也写了许多力扣博客作准备，可能有的学校机试还需要自己写IO，题型大差不差。个人感觉在力扣练习了大部分专题的中等难度题目也就足够了，一般刷200题以上，至少不会出现两眼一抹黑的情况，至于算法大佬（膜），这部分就不需要担心了。\n#### 面试\n面试一般会考察英语和专业，有的可能还会考察数学，我个人被问到了两次关于概率论的题目，都没有回答的很好。  \n英语一定是非常重要的一项，许多学校非常看重英语的水平，好看的四六级英语成绩会很吃香，有的学校面试会提前告诉你准备1分钟或3分钟自我介绍，还有可能会问不少其他问题。我认为应该提前准备并背熟不同时长几个版本的自我介绍，还有关于爱好、学校、喜欢的课程和家乡、朋友等主题的发言，就可以应付大多数学校的面试。  \n\n#### 专业\n想要又全面又细致地复习所有专业课程是不可能的，我的建议是重点复习408课程，其中数据结构与算法最为重要。同时还需要注意复习数据库等课程，需要承认在面试中运气的成分也很重要，认真地复习专业课能保证你不至于全程疯狂向老师道歉。  \n\n最后一点，也是最最重要的，一定要**足够自信**，有实力且足够自信，让老师看到你是个活生生的优秀的人，才更容易得到老师的认可。\n\n### 关于信息获取\n在夏令营中最容易忽视的就是信息的获取，而这却是是最重要的一点。应该提前关注自己选择的学校官网、研究生院等等网站及时获取信息，同时也有很多计算机保研人开辟的git仓库会同步很多学校的信息，着实在我的准备过程中产生了很大的帮助。\n\n![夏令营git仓库](https://img.foril.space/%E5%A4%8F%E4%BB%A4%E8%90%A5git%E4%BB%93%E5%BA%93.jpg)\n\n### 关于整理\n开始前，应该尽早准备好自己需要的材料，包括各类证书和奖项、四六级证明、学生证身份证扫描件等等，尽量保证材料全面且随手可得（我自己采用了WPS云文件夹的形式，WPS在保研期间也发挥了很大的作用），才不会在需要时手忙脚乱焦头烂额。  \n\n同时关于自己心仪的学校通知信息，应该及时整理记录，每日检查，以防自己错过重要的时间点（会很懊悔）。使用excel就是一个不错的选择，我用腾讯文档记录了我关注的学校信息，既可以随时手机查看有很整齐。 ~~其实也挺乱~~\n\n![](https://img.foril.space/%E6%B1%87%E6%80%BB1.jpg)\n![](https://img.foril.space/%E6%B1%87%E6%80%BB2.png)\n\n此外，由于各个学校报名需要的材料内容不同，建一个文件夹按学校保存各个学校的材料也会让你省心不少。\n\n### 如何择校\n关于如何择校见仁见智，我认为多数人会考虑的因素会包括：\n* 学校的title\n* 学校所在城市\n* 联系的导师人品以及方向\n* 住宿宿舍条件\n\n具体以什么因素优先由自己决定，个人认为能找到一个非常喜欢的方向人好的强导最重要，但我选择的时候也还是兼顾到了学校title的因素。\n\n### 怎么联系导师\n联系导师当然也是趁早，毕竟一个萝卜一个坑，哪怕你非常优秀，心仪的导师联系晚了可能连回信都得不到。不过我并不建议所有学校都联系导师，毕竟跟老师沟通好了再咕咕咕对谁都不好，你也尴尬还有可能耽误老师招生。网上有很多联系导师的模板可以参考，下面是我联系导师的模板。\n```\n尊敬的xx老师：\n    您好，冒昧致信，请多包涵。\n    我叫xxx，是xx大学xx学院的2018级本科生。通过对自身学习成绩和综合素质的评估，预计我一定会获得推免资格。所以冒昧给您致信，希望能有机会攻读您的研究生。\n    下面是简单的自我介绍：我的加权绩点为xx，学院专业排名xx，六级成绩xx。在校获得多项奖学金，负责一项省级大学生创新训练项目，获得过包括xxxx的多项竞赛奖项。(一部分个人优势介绍)\n    在贵校首页看到您的个人主页，对您的研究方向非常感兴趣。我热切希望能有机会加入您的团队，在研究生阶段能得到您的指导！\n    附件中是我的个人简历和成绩单供您参考。\n    感谢您能在百忙之中阅信。诚盼老师的回复！\n    祝您身体健康，工作顺利！\n学生：xxx\n2021年x月x日\n```\n\n## 我的夏令营经历\n由于疫情，今年的夏令营也是线上的形式，估计是第二年搞线上学校学生都玩明白了，今年各学校疯狂抬高bar，所有学生疯狂海投（毕竟报名又不收费还基本不会冲突）。  \n首先说一下我的大概情况：成绩前3.6%（参营报名时用的前五学期成绩5.6%，所以能入营的基本5%差不多，面试基本都用的3.6%介绍自己），六级587，没有论文，没有出彩竞赛，项目也只有大创和算上这个博客，我报了十来个学校，和高考志愿大同小异，冲的稳的保的。等学校一个个出结果的过程是焦急的，不过到后面也就麻木了。我个人虽然入营不算多，但幸运的是入营的学校都拿到了优营，拿到一个优营以后也算是有了底气，之后的夏令营也就可以更加自信。    \n主要入营学校包括：  \n* 南京大学CS\n* 中山大学CS\n* 华东师范大学SE\n* 天津大学CS\n* 中南大学CS\n\n> 入营这东西比较玄学，每年学校情况都不太一样，只能作为参考，据说上届西交北理华科基本属于点击即送，于是我也打算西交北理保底，结果西交北理一个没过，着实是被搞了一把心态。\n***\n### 中南大学CS\n报中南大学是在西交大出结果的那天晚上，我一度怀疑自己是不是报高了一个档次，就报名了中南大学多一个保底。中南也是我参加的第一个开营的学校，常规的宣讲什么的也就挂个会议干自己的事。  \n中南要求联系老师考核，我联系的老师跟我约好当天下午面试，面试大概持续了20分钟，老师很认真，仔细研究了我的简历成绩单，专业问题问的不多，就是一些简单的机器学习问题，我虽然学的一般，但也勉强能应付，此外更多就是一些个人的情况，最后给了我三道机试题手写代码，一道是图，直接生套迪杰斯特拉即可，一道是简单的背包问题，最后一道和字符串有关，具体题目记不得了，只记得当时没有想到什么好的办法，反正是手写代码也不怕超时，就用类似遍历的方法写下来了。后来虽然获得了老师的推荐，不过因为之后接着得到了天大的认可，就连中南学校的面试都没有参加。\n***\n\n### 华东师范大学SE\n华东师范SE是出结果较早的几个学院之一，在软工学科中，华师大非常靠前，且中北校区地处魔都中心，这都是我考虑的几个因素，但同时需要说的是，华师大的考核也是我报名参加的所有学校中最烦心最耗时的一个。拿到入营资格后，需要首先联系导师，导师下发任务，在通过导师的考核任务和面试之后，再有一部分进入机试，机试筛选一部分后才能获得面试名额，面试又会筛选一半才能得到最后的结果。\n  \n为什么说他耗时，因为导师考核需要你看几篇导师的论文给导师做报告，假如一路顺利进入学院面试，又需要看另外的论文并做报告。这样下来，在你压力最大、时间最紧张的七月初，你要协调你的时间，在小学期课业、参加其他学校夏令营之余读论文做PPT展示。  \n为什么说他烦心，因为入营800进100，导师考核不知道筛选多少人，机试筛选至50人，面试之后只发25个offer，25个优营800人竞争，而且这期间每一个环节你都不知道自己能不能通过，但又不能不准备下一个环节，无疑是背负着巨大的心理压力的。  \n\n好的是我联系的导师是一位非常认真负责的老师，在这里不得不非常感谢华东师范大学苏亭老师，苏老师学术能力非常强，人好，在专业领域潜力无限，当时有很长一段时间我都想直接确定去找苏亭老师，最后也是经过许多考虑决定选择南大，也祝苏老师工作顺利。\n\n华师大的机试一小时，两道题，每道题十个用例，一个用例10分，共200分，一道题基本套用迪杰斯特拉稍稍优化即可，还有一道题当时不会做，现在也不记得了。至于面试，主要就是PPT自我介绍以及论文展示，还有一部分思想政治的考察，甚至问到了我遇到法轮功应该怎么办，正常回答，都比较顺利。\n\n总的来说，华师大SE实力强劲，但考察流程繁杂，竞争较激烈，毕竟只放出25个offer，不知道预推免会不会容易一些。\n***\n\n### 天津大学CS\n天津大学现在将CS和SE并入“*智算学部*”一起招生，没有机试，只有一个简单的面试，而且我选择的研究组应该算考察比较轻松，大概介绍了自己的情况，闲聊一会之后就拿到了老师的口头offer，相对很轻松，这里不再细说。\n***\n\n### 中山大学CS\n中山大学在今年的夏令营中超发了很多offer，印象中应该是只招收不到200人，但是刚入营的时候群上有600余人，后来随着机试面试的进行，大概退到400人左右。中山的考核流程就是属于中规中矩，机试加面试。\n机试共十道题1000分，三小时，难度力扣中等题，我也是老老实实三小时坐穿拿了490分，应该排名较后，根据学校后面的邮件，在学校超发的300多个优营中我排到了200-250名，所以机试的成绩还是相当重要的。  \n至于面试，是很多老师面试一个学生，除了简单的英文自我介绍以外，还让我用英文讲讲对学校的认识和选择中山大学的理由。专业问题不多，主要问了一些机器学习相关的知识和词汇，回答的不算很好，此外还问了两个概率相关的概念，一个回答上了一个印象不深，确实气氛有点尴尬。之后项目就算是个人比较有把握的部分，回答得都比较流畅，顺利结束。  \n\n虽然最后拿到了学校的offer，但排名并不是很靠前。不过我去中山大学的意愿也不是很强烈，也没有联系老师。\n***\n\n### 南京大学CS\n南大是我最想去的学校之一，也是我重点准备的学校，同时南大因为报名的人太多，也分了多轮考核，7月8号有第一轮线上考试，20道单选10道多选，全是408的内容，还有很多关于Linux的非常细致的问题，个人觉得有些题（尤其是多选题）难度还是挺高的，不过可能入营的标准不算特别高，我感觉我可能多选一个都不对，也顺利入营。  \n之后就是面试，本来南京大学应该是线下机试和面试，学校包夏令营几天的食宿，我连机票和前一天的酒店都订好了，结果由于南京突发疫情，又改回了线上，只有面试没有机试。记得当时是七月底，正值大连最热的几天，我决定等结束了所有夏令营再回家，学校的课程也已经结束，舍友也都回家了，好几天所有的活动都是围绕着南大的夏令营准备，确实是非常煎熬的一段日子，好在最终的结果是令人满意的。  \n\n面试是三个老师考察一个学生，面试开门见山，英语的自我介绍后，老师问我如果面对一个电脑小白，会向他介绍什么课程，为什么？我简单介绍了数据结构与算法的重要性以及主要内容和带给我个人的收获；之后下一个老师问我什么是动态规划，并让我举了一个具体的例子以及怎么用动态规划解决，好在这部分我之前写了博客准备，回答的比较到位；之后问到了项目，我之前都有所准备，老师问我前后端哪个做的比较多，以及对于前后端发展的看法，我从个人的角度发表了一些自己的看法；还问到了我学过哪些语言，觉得这些语言有什么区别，我就从编译型、解释型以及Java这种半编译半解释型的语言做了简单的对比和介绍；此外还有简单的个人性格考察，考察你遇到别人说你坏话后会采取什么样的应对的措施；之后老师问我什么是一个随机事件的期望和方差以及方差和协方差的区别，我回答后意识到自己没有从离散型和连续性分开说，不过也问题不大；之后还有一道面试经典题目：如何用5L的瓶子和3L的瓶子得到4L水，这个我之前有听过，比较顺利。  \n由于没有机试，面试的环节中还问到了不少机试题：\n* 2n+1个数中有n对相同的数和1个落单的数，如果得到这个数，我告诉他将所有的数异或即可；\n* 8个球中有1个球比其他的轻，最少几次可以得到这个轻的球。我当时说利用2分法3次可以得到，后来想到其实只针对8个球这个问题的话，有2次称重就可以找出的方法。\n***\n\n## 在最后\n说实话，真正经历过保研后才明白保研不比考研轻松多少，需要背负着巨大的压力去参加各种机试面试，可能好的一点就是不会在一棵树上挂死而且能比考研党早上岸，但是这背后承载着的，也是几年来自己一直不懈的努力。\n\n相信所有的付出都会得到回报，或早或晚。\n\nTHE END'),(38,'MobX与Redux',1,'2021-09-19 03:37:00',101,'Redux和MobX是当下较为流行的两个状态管理库，在复杂前端项目的状态管理中发挥了很大的作用，那么我们应该怎么使用它们，又该如何选择呢？本文记录一下学习过程中的笔记。\n## 什么是状态管理  \n当我们在使用React进行开发时，每个组件都有自己的状态可以管理，在简单的应用中，我们只需要组件管理好自己的状态，同时向下传递状态；而随着项目规模变大变复杂，在一些场景下，可能会出现一些比较棘手的组件间状态通信难题：\n* 多个组件间的状态共享\n* 组件触发其他组件的状态更新\n\n> React 只是 DOM 的一个抽象层，**并不是 Web 应用的完整解决方案**。有两个方面，它没涉及：  \n> 1. 代码结构\n> 2. 组件之间的通信\n\n\n按照React的设计思想，给出的建议是将公共状态提升，再需要的地方一层一层传递下来，但这样会使得代码臃肿而混乱，维护性极差；Redux和MobX这两个状态管理库，本质任务都是**解决状态管理混乱问题**，更好地管理状态，解决项目中常见到的一些组件间的状态通信问题。  \n\n> 如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。  \n\n## Redux\n再介绍Redux之前，不得不先介绍Flux。  \n\nFlux架构的概念由Facebook在2014年提出。不严谨地讲，它和MVC架构应该算同一个级别的东西。采用Flux组织你的前端应用开发，可以使你的数据组织更加清晰简单，更便于维护。  \n\nFlux 的最大特点，就是数据的\"单向流动\"。  \n\n![Flux的数据单向流动](https://img.foril.space/bg2016011503.png)\n\n它将一个应用分成四个部分。\n* View： 视图层\n* Action（动作）：视图层发出的消息（比如mouseClick）  \n* Dispatcher（派发器）：用来接收Actions、执行回调函数（对应Redux的Reducer）  \n* Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面\n\n每个Action都是一个**对象**，包含一个actionType属性（说明动作的类型）和一些其他属性（用来传递数据）。Dispatcher 只能有一个，而且是全局的。  \n\n概括来说，整个数据流动过程包括用户与View交互，触发Action，这时Dispatcher监听到Action，根据Action的类型（ActionType）执行不同的回调函数，生成新的Store，Store在发生变动后，向View发出事件，实现数据和视图的同步。\n\nRedux就是对 *Flux* 与 *函数式编程* 的统一，与React结合，成为一时热门的前端解决方案。其特点是可预测（源于其纯函数的使用）、易调试（配合Redux DevTools），且能够与任何UI层搭配使用，使你的应用数据中心化。  \n\n## Redux的API使用\n对于Redux来说：\n1. Web 应用是一个状态机，视图与状态是一一对应的。\n2. 所有的状态，保存在一个对象里面。\n\n其基本组成与Flux对应，包括：\n### Store\nStore就是整个应用保存数据的地方，**整个应用只能有一个Store**。使用Redux，可以使用`createStore`这个函数生成Store。\n```js\nimport { createStore } from \'redux\';\nconst store = createStore(reducer);\n```\n`createStore`这个函数**接受一个Reducer**，生成Store。  \n（Reducer传入第一个参数默认值即是Store初始值，后面会提到。）\n\n下面是createStore的一个简单实现\n```js\nconst createStore = (reducer) => {\n  //本质是闭包\n  let state;\n  let listeners = [];\n\n  const getState = () => state;\n\n  const dispatch = (action) => {\n    state = reducer(state, action);\n    listeners.forEach(listener => listener());\n  };\n\n  const subscribe = (listener) => {\n    listeners.push(listener);\n    return () => {\n      listeners = listeners.filter(l => l !== listener);\n    }\n  };\n\n  dispatch({});\n\n  return { getState, dispatch, subscribe };\n};\n```\n此外，Store有三个重要的方法：\n* `store.getState()`  \n  Store对象包含所有数据。如果想得到某个时间点的数据，就要对 Store 生成快照。这种时间点的数据集合，就叫做 **State**。当前时刻的 State，可以通过store.getState()拿到。  \n* `store.dispatch()`  \n  是 **View 发出 Action 的唯一方法**，触发 Reducer 的自动执行，会在稍后的 Action 中提到。\n* `store.subscribe()`\n  Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数（比如更新视图的操作）；store.subscribe方法返回一个函数，调用这个函数就可以解除监听。\n  ```js\n  let unsubscribe = store.subscribe(() =>\n    console.log(store.getState())\n  );\n  unsubscribe();\n  ```\n\n### Action\nAction的本质其实就是一个对象，其中 `type` 属性是必选的，也可以自定义其他属性用来传递任意想要的数据。  \n```js\n//Action\nconst action = {\n  type: \'ADD_TODO\',\n  payload: \'Learn Redux\'\n};\n```\n当我们想要让Action携带不同的数据的时候（比如上面例子中的`payload`），就可以使用一个函数接收参数，返回一个携带了信息的Action，这样的函数就是 `Action Creator`。\n```js\nconst ADD_TODO = \'添加 TODO\';\n\n//Action Creator\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    payload: text   //将作为参数的text置入对象\n  }\n}\n//返回对象作为Action\nconst action = addTodo(\'Learn Redux\');\n```\n当视图层有所动作，需要触发Action时，需要使用`store.dispatch()`方法（**唯一方法**），将Action作为参数传入；`store.dispatch()`会触发Reducer的自动执行，得到更新后的State。\n```js\nimport { createStore } from \'redux\';\nconst store = createStore(fn);\n\nstore.dispatch({\n  type: \'ADD_TODO\',\n  payload: \'Learn Redux\'\n});\n```\n结合刚才提到的`Action Creator`你可以将代码写作：\n```js\nstore.dispatch(addTodo(\'Learn Redux\'));\n```\n### Reducer\nReducer可能是整个数据流动环节中最为重要的一环，负责根据Action的不同类型，执行不同的操作，更新State。  \n**Reducer的实质是一个函数。他接受当前State和一个Action作为参数，返回一个新的State。**  当没有最初始的State时，也就是第一次调用 Reducer 时，State采用传入的默认值，也就是State的初始值。\n```js\nconst defaultState = 0; //State初始值，以default的形式传给Reducer第一个参数\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case \'ADD\':\n      return state + action.payload;\n    default: \n      return state;\n  }\n};\n```\nstore.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。（串起来了）\n\n> 为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。（参数是state, action且返回新的state）请看下面的例子，一系列 Action 对象按照顺序作为一个数组。\n> ```js\n> const actions = [\n>   { type: \'ADD\', payload: 0 },\n>   { type: \'ADD\', payload: 1 },\n>   { type: \'ADD\', payload: 2 }\n> ];\n> \n> const total = actions.reduce(reducer, 0); // 3\n> ```\n> 上面代码中，0首先作为初始值，传入reducer，相当于`reducer(0, { type: \'ADD\', payload: 0 })`，返回新的state=0+0=0，返回的值0作为当前值，继续调用reducer，相当于`reducer(0, { type: \'ADD\', payload: 1 })`，得到新的state=0+1=1，以此类推。\n\n上面说到 Reducer 的本质是一个函数，这里需要注意的是，Reducer是一个**纯函数**，这就意味着，面对同样的输入，Reducer必然能得到同样的输出。  \n纯函数是函数式编程的概念，必须遵守以下一些约束：\n* 不得改写参数\n* 不能调用系统 I/O 的API\n* 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果\n\n也正因为此，Reducer 函数里面**不能改变 State，必须返回一个全新的对象**，请参考下面的写法。\n```js\n// State 是一个对象\nfunction reducer(state, action) {\n  return Object.assign({}, state, { thingToChange });   //用thingToChange覆盖原state中的key\n  // 或者\n  return { ...state, ...newState }; //同样是覆盖，返回的是全新的对象\n}\n\n// State 是一个数组\nfunction reducer(state, action) {\n  return [...state, newItem];   //返回的是全新的数组\n}\n```\n\n### Reducer的拆分\n整个应用只能有一个Store，这样会导致对于Reducer的管理非常冗杂，我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。\n```js\nconst chatReducer = (state = defaultState, action = {}) => {\n  const { type, payload } = action;\n  switch (type) {\n    case ADD_CHAT:\n      return Object.assign({}, state, {\n        chatLog: state.chatLog.concat(payload)\n      });\n    case CHANGE_STATUS:\n      return Object.assign({}, state, {\n        statusMessage: payload\n      });\n    case CHANGE_USERNAME:\n      return Object.assign({}, state, {\n        userName: payload\n      });\n    default: return state;\n  }\n};\n\n             |\n             | \n             | 改为\n             |\n            \\|/\n\nconst chatReducer = (state = defaultState, action = {}) => {\n  return {\n    chatLog: chatLog(state.chatLog, action),    //每个小的Reducer都返回一个小的state\n    statusMessage: statusMessage(state.statusMessage, action),\n    userName: userName(state.userName, action)\n  }\n};\n```\n\nRedux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。\n```js\nimport { combineReducers } from \'redux\';\n\nconst chatReducer = combineReducers({\n  chatLog,\n  statusMessage,\n  userName\n})\n\nexport default todoApp;\n```\n下面是combineReducer的简单实现。\n```js\nconst combineReducers = reducers => {\n  //返回的是一个大Reducer\n  return (state = {}, action) => {\n    //大Reducer返回的是所有的小state累加  \n    return Object.keys(reducers).reduce(\n      (nextState, key) => {\n        nextState[key] = reducers[key](state[key], action);\n        return nextState;\n      },    //accumulator\n      {}    //初始值\n    );\n  };\n};\n```\n### Redux工作流程\n附上Redux的工作流程\n![Redux工作流程](https://img.foril.space/bg2016091802.jpg)\n## MobX\nMobX也是flux架构的一种实现，但是它凭借更简单的api和更快的速度，得到了很多人的追捧。MobX 是状态管理库中侵入性最小的之一。这使得 MobX的方法不但简单，而且可扩展性也非常好。React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。\n\n> Anything that can be derived from the application state, should be derived. Automatically.  \n> 任何起源于应用状态的数据应该自动获取。\n\nMobX的api非常间接也很符合直觉，如果项目支持装饰器语法，编写会更加简单高效，具体如何配置可参考 [在js中使用装饰器](https://www.foril.space/article/36) 。  \n\n### MobX的使用\n### 核心概念\n#### @observable\n通过使用 @observable 装饰器(ES.Next)来给你的类属性添加注解，可以使被注解的属性作为一个**可观察的状态**，可被外界观测到该状态的变化\n#### @observer\n通过@observer修饰你的组件，可以使组件观测到内部使用的可观测状态(observable)的变化，及时更新。\n#### @action\n通过@action可将你的函数变为一个**动作**，可在其中对状态进行修改，在严格模式下，只有动作才可以修改状态。  \n`action.bound`会绑定this。  \n`runInAction`函数：\n```js\nimport { runInAction } from \'mobx\'\nrunInAction(()=>{\n    store.count=10; //直接调用修改store\n})\n```\n\n#### @computed\n基于某些状态计算出的数据提炼为一个方法。**所依赖的可观测状态没有变化时，多次调用只会执行一次，计算结果会被缓存。（计算属性的好处之一）**\n```js\nimport { computed } from \'mobx\'\nclass Store{\n    @observable count = 0;\n    @computed get doubleCount(){\n        return this.count * 2;\n    }\n} \n```\n***\n### 监视数据\nMobX主要提供了三种方式监视数据：\n#### autorun\n在autorun内部使用到的可观测状态发生改变时，autorun会自动执行；同时autorun默认会在初始时执行一次。\n```js\nautorun(()=>{\n        console.log(store.count)    //依赖了store.count，发生变化时会执行（初始也会执行）\n    }\n)\n```\n\n#### when\n`when(predicate: () => boolean, effect?: () => void, options?)`  \nwhen 观察并运行给定的 predicate，直到返回true。 一旦返回 true，给定的 effect 就会被执行，然后 autorunner(自动运行程序) 会被清理。 该函数返回一个清理器以提前取消自动运行程序。\n```js\n//when两个参数，一个条件，一个操作\n//只会执行一次，若默认符合，一开始就执行\nwhen(\n    ()=>{\n        return store.count > 100\n    },\n    ()=>{\n        cconsole.log(\"条 件符合，进入\")\n    }\n)\n```\n\n#### reaction\nautorun 的变种，对于如何追踪 observable 赋予了更细粒度的控制。 它接收两个函数参数，第一个（**数据函数**）是用来追踪并返回数据，同时作为第二个函数（**效果函数**）的输入。不同于 autorun 的是当创建时效果函数不会直接运行，只有在数据表达式首次返回一个新值后才会运行。在执行效果函数时访问的任何 observable 都不会被追踪。\n```js\n//不同于autorun和when，只有当被观测的数据被改变的时候才会执行（没有autorun的第一次执行）\nreaction(\n    ()=>{\n        //业务操作，返回数据给下一个函数使用\n        return store.count\n    },\n    (countData, reaction)=>{    \n        console.log(countData)\n        reaction.dispose()  //停止当前reaction对数据的监听\n    }\n)\n```\n***\n接下来简单记录MobX的具体使用。\n### 安装\n```bash\nyarn add mobx\n# React 绑定库:\nyarn add mobx-react\n```\n### 初始化MobX容器仓库\n```js\nimport {observable, action} from \'mobx\'\n\nclass Store{\n    @observable count=0\n    @action.bound increment(){\n        this.count++\n    }\n}\n```\n\n### 在组件中使用MobX容器状态\n```js\nReactDOM.render(<App store={new Store()} />, document.getElementById(\'root\'))   //也可以使用Provider\n```\n### 组件中发起action修改容器状态\n```js\nimport {observer} from \'mobx-react\'\n\n@observer\nclass App extends React.Component{\n    render(){\n        const {store} = this.props\n        return(\n            <div>\n                <p>{store.count}</p>\n                <p>\n                    <button onClick={store.increment}>增加</button>\n                </p>\n            </div>\n        )\n    }\n}\n```\n### store间通信\n```js\n//aStore\nclass aStore{\n    @observable abc = []\n    @observable tmp = \'sdaf\'\n    constructor(rootStore){\n        //传入根store使能够找到其他store\n        this.rootStore = rootStore\n    }\n}\n\n//bStore\nclass bStore{\n    @observable asdf = []\n    @observable ddd = \'sdaf\'\n    constructor(rootStore){\n        this.rootStore = rootStore\n    }\n}\n\n//index\nclass rootStore{\n    constructor(){\n        //引入各个小的store\n        this.aStore = new aStore(this)\n        this.bStore = new bStore(this)\n    }\n}\n```\n\n### 将rootStore传递到所有组件\n```js\n//父组件\nimport { Provider } from \'mobx-react\'\nimport RootStore from \'./stores\'\n<Provider {...RootStore}>\n    <App />\n<Provider />\n\n//子组件\nimport { observer, inject } from \'mobx-react\'\n\n@observer\n@inject(\'StoreName\')    //把容器中的数据成员映射进来\nclass MyComponent{  \n    render(){\n        console.log(this.props.StoreName)\n        return(\n            ...\n        ) \n    } \n}\n```\n\n## MobX还是Redux\nMobX和Redux都是应用状态管理库，都适用于React，Angular，VueJs等框架或库，而不局限于某一特定UI库，在项目中应该如何选择呢？  \n从上面的笔记中也可以看出来，MobX的使用比Redux要方便许多，Redux需要写很多繁琐的action和reducer，而MobX是状态管理库中侵入性最小的之一。这使得 MobX的方法不但简单，而且可扩展性也非常好。  \n同时Redux对ts的支持比较困难，而MobX则完美支持ts。\n\n所以，MobX可能更适合在简单的、数据流不太复杂的中小型项目中，但这并不表示其不能支撑大型项目，关键在于大型项目通常需要特别注意可拓展性，可维护性，相比而言，规范的Redux更有优势，而MobX更自由，需要我们自己制定一些规则来确保项目后期拓展，维护难易程度；\n\n## 参考\n\n* [你需要MobX还是Redux？](https://www.cnblogs.com/zhouyangla/p/10165650.html)\n* [React官方文档Context](https://react.docschina.org/docs/context.html)\n* [阮一峰React 技术栈系列教程](http://www.ruanyifeng.com/blog/2016/09/)\n* [React 系列教程之 MobX](https://www.bilibili.com/video/BV1tL4y1h7ND?p=3&spm_id_from=pageDriver)'),(43,'解决electron安装超时的问题',1,'2021-11-08 11:01:49',73,'在运行网上一些开源electron项目以及学习electron的过程中，发现无法正常下载electron，在网上搜索一番后找到了解决方案，以下加以记录。\n\n在安装electron的时候，一直卡在node install.js最终超时，使用npm和yarn都有相同的问题，我遇到的问题是通过在 `.npmrc` 配置文件加入`electron_mirror`解决。\n\n在安装过程中，electron 模块会通过 electron-download 为您的平台下载 Electron 的预编译二进制文件。查阅文档后发现可以配置国内镜像。\n\n<img src=\"https://img.foril.space/electron-download.webp\" style=\"margin:0 auto\" alt=\"electron-download\" width=700px/>\n\nLinux在`~/.npmrc`中修改  \nWindows在`C:\\Users\\{username}\\.npmrc`中修改\n```\nregistry=https://registry.npm.taobao.org/\nelectron_mirror=\"https://npm.taobao.org/mirrors/electron/\"\n```\n\n## 参考\n[解决安装electron卡在node install.js 不动问题](https://www.jianshu.com/p/28a0305ac187)'),(44,'Maven学习笔记',1,'2021-11-10 14:09:06',44,'最近由于考虑毕设可能会用到Java，决定大概复习一下，首先考虑复习一下Maven再去了解一下Gradle，本文是Maven的复习笔记。  \n## Maven简介\n### 简介\nMaven主要服务于基于java平台的**项目构建**，**依赖管理**和**项目信息管理**。  \n\n### 项目构建\n除了编写源代码，我们每天有相当一部分时间花在了编译，运行单元测试，生成文档，打包和部署等繁琐的工作上，这就是构建。  \n如果我们现在还手工这样做，成本太高，于是有人用软件的方法让这一系列工作完全自动化，使得软件的构建可以像全自动流水线一样，只需要一条简单的命令，所有繁琐的步骤都能够自动完成，很快就能得到最终结果。\n\n### 项目构建工具\n* Ant构建  \n最早的构建工具，基于IDE, 大概是2000年有的，当时是最流行java构建工具，不过它的XML脚本编写格式让XML文件特别大。对工程构建过程中的过程控制特别好。\n\n* Maven【JAVA】  \n项目对象模型，通过其描述信息来管理项目的构建，报告和文档的软件项目管理工具。它填补了Ant缺点，Maven第一次支持了从网络上下载的功能，仍然采用xml作为配置文件格式。Maven专注的是依赖管理，使用Java编写。\n\n* Gradle  \n属于结合以上两个的优点，它继承了Ant的灵活和Maven的生命周期管理，它最后被google作为了Android御用管理工具。它最大的区别是不用XML作为配置文件格式，采用了DSL格式，使得脚本更加简洁。  \n\n\n目前市面上Ant比较老, 所以一般是一些比较传统的软件企业公司使用, Maven使用Java编写, 是当下大多数互联网公司会使用的一个构建工具, 中文文档也比较齐全, gradle是用groovy编写, 是目前比较新型的构建工具，一些初创互联网公司会使用, 以后会有很大的使用空间。\n\n### Maven的四大特性\n#### 1. 依赖管理系统  \nMaven为Java世界引入了一个新的依赖管理系统。jar 升级时修改配置文件即可。在Java世界中，可以用groupId、artifactId、version组成的Coordination（**坐标**）唯一标识一个依赖。  \n任何基于Maven构建的项目自身也必须定义这三项属性，生成的包可以是jar包也可以是war包。一个典型的依赖引用如下所示：\n```xml\n<dependency>\n <groupId>javax.servlet</groupId>\n <artifactId>javax.servlet-api</artifactId>\n <version>3.1.0</version>\n</dependency>\n```\n**groupId**  \n定义当前Maven项目隶属的实际项目-公司名称。（jar包所在仓库路径）由于Maven中模块的概念，因此一个实际项目往往会被划分为很多模块。比如spring是一个实际项目，其对应的Maven模块会有很多，如spring-core,spring-webmvc等。\n\n**artifactId**  \n该元素定义实际项目中的一个Maven模块-项目名，推荐的做法是使用实际项目名称作为artifactId的前缀。 比如： spring-bean, spring-webmvc等。\n\n**version**  \n该元素定义Maven项目当前所处的版本。\n\n#### 2. 多模块构建\n在Maven中需要定义一个parent POM作为一组module的聚合POM。在该POM中可以使用标签来定义一组子模块。parent POM不会有什么实际构建产出。而parent POM中的build配置以及依赖配置都会自动继承给子module。\n\n#### 3. 一致的项目结构\n之前，Eclipse或IDEA创建的项目目录结构不一致，Maven制定了一套项目目录结构作为标准的Java项目结构，**解决不同IDE带来的文件目录不一致问题**。\n\n#### 4. 一致的构建模型和插件机制\n依赖和插件配置方法相同。（Maven插件可满足一些特定的运行方式，比如在服务器上运行web项目可用tomcat或jetty插件运行）\n```xml\n<plugin>\n <groupId>org.mortbay.jetty</groupId>\n <artifactId>maven-jetty-plugin</artifactId>\n <version>6.1.25</version>\n <configuration>\n <scanIntervalSeconds>10</scanIntervalSeconds>\n <contextPath>/test</contextPath>\n </configuration>\n</plugin>\n```\n\n## Maven的安装配置和目录结构\n### 安装配置\n* 检查JDK的版本 JDK版本1.7及以上版本\n* 下载Maven\n* 配置Maven环境变量  \n把Maven的根目录配置到系统环境变量`MAVEN_HOME`，将bin目录配置到path变量中。注：maven解压后存放的目录不要包含中文和空格  \n* 检查Maven是否安装成功  \n执行 mvn -v\n\n（以下可选）\n* 修改默认仓库位置  \n打开maven目录 -> conf -> settings.xml 添加仓库位置配置\n```xml\n<localRepository>F:/m2/repository</localRepository>\n<!--注：仓库位置改为自己本机的指定目录，\"/\"不要写反-->\n```\n* 更换阿里镜像,加快依赖下载\n```xml\n<mirror>\n    <id>aliyunmaven</id>\n    <mirrorOf>*</mirrorOf>\n    <name>阿里云公共仓库</name>\n    <url>https://maven.aliyun.com/repository/public</url>\n</mirror>\n```\n\n### 认识Maven目录结构\n* src/main/java 项目的源代码所在的目录\n* src/main/resources 项目的资源文件所在的目录（比如property文件）\n* src/test/java 测试代码所在的目录（比如JUnit代码）\n* src/test/resources 测试相关的资源文件所在的目录\n\n#### 认识POM\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.xxxx</groupId>\n    <artifactId>maven01</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <packaging>jar</packaging>\n    <name>maven01</name>\n    <url>http://maven.apache.org</url>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>3.8.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n#### cmd 下编译并运行\ncmd下面，进入项目的根目录  \n1. 编译java文件  \n```\nmvn compile\n```\n2. 执行main 方法  \n```\nmvn exec:java -Dexec.mainClass=\"com.xxxx.demo.Hello\"\n```\n \n ***\n\n## Maven命令\nMaven命令格式\n```\nmvn [plugin-name]:[goal-name]\n```\n### 常用命令\n|命令 | 描述|\n|:--:|:--|\n|mvn –version | 显示版本信息|\n|mvn clean | 清理项目生产的临时文件,一般是模块下的target目录|\n|mvn compile | 编译源代码，一般编译模块下的src/main/java目录|\n|mvn package | 项目打包工具,会在模块下的target目录生成jar或war等文件|\n|mvn test | 测试命令,或执行src/test/java/下junit的测试用例.|\n|mvn install | 将打包的jar/war文件复制到你的本地仓库中,供其他模块使用|\n|mvn deploy | 将打包的文件发布到远程参考，提供其他人员进行下载依赖|\n|mvn site | 生成项目相关信息的网站|\n|mvn eclipse:eclipse | 将项目转化为Eclipse项目|\n|mvn dependency:tree | 打印出项目的整个依赖树|\n|mvn archetype:generate | 创建Maven的普通java项目|\n|mvn tomcat7:run | 在tomcat容器中运行web应用|\n|mvn jetty:run | 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中|启动 web 应用\n\n### -D传入属性参数\n例如：\n```sh\nmvn package -Dmaven.test.skip=true\n```\n以 -D 开头，将 maven.test.skip 的值设为 true ,就是告诉 maven 打包的时候跳过单元测试。同理，mvn deploy-Dmaven.test.skip=true 代表部署项目并跳过单元测试。\n\n### -P 使用指定的Profile配置\n比如项目开发需要有多个环境，一般为开发，测试，预发，正式4个环境，在pom.xml中的配置如下：\n```xml\n<profiles>\n    <profile>\n        <id>dev</id>\n        <properties>\n            <env>dev</env>\n        </properties>\n        <activation>\n            <activeByDefault>true</activeByDefault>\n        </activation>\n    </profile>\n    <profile>\n        <id>qa</id>\n        <properties>\n            <env>qa</env>\n        </properties>\n    </profile>\n    <profile>\n        <id>pre</id>\n        <properties>\n            <env>pre</env>\n        </properties>\n    </profile>\n    <profile>\n        <id>prod</id>\n        <properties>\n            <env>prod</env>\n        </properties>\n    </profile>\n</profiles>\n......\n<build>\n    <filters>\n        <filter>config/${env}.properties</filter>\n    </filters>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n    ......\n</build>\n```\nprofiles 定义了各个环境的变量 id ， filters 中定义了变量配置文件的地址，其中地址中的环境变量就是上面 profile 中定义的值， resources 中是定义哪些目录下的文件会被配置文件中定义的变量替换。\n\n通过maven可以实现按不同环境进行打包部署，例如：\n```\nmvn package -Pdev -Dmaven.test.skip=true\n```\n表示打包本地环境，并跳过单元测试\n## IDEA编辑器集成Maven环境\n注意修改IDEA设置的Maven，选择要使用的Maven，配置对应的配置文件和仓库位置即可。\n## Maven项目的创建\n创建Maven根据选择的模板（或不选择）会自动创建Mavcen目录结构，建好Maven项目后，可在IDEA右上角运行配置中加入 `compile` 以及 `package` 等需要的运行方式，可随时切换运行。也可以在右侧Maven工具栏中从生命周期随时运行需要的命令。\n## Maven仓库的基本概念\n当第一次运行Maven命令的时候，你需要Internet链接，因为它需要从网上下载一些文件。那么它从哪里下载呢？它是从Maven默认的远程库下载的。这个远程仓库有Maven的核心插件和可供下载的 jar 文件。  \n\n对于Maven来说， 仓库只分为两类： **本地仓库**和**远程仓库**。  \n当Maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在，则直接使用；如果本地没有，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有，Maven就会报错。  \n远程仓库分为三种： **中央仓库**，**私服**，**其他公共库**。  \n中央仓库是默认配置下，Maven下载jar包的地方。私服是另一种特殊的远程仓库，为了节省带宽和时间，应该在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。**内部的项目还能部署到私服上供其他项目使用。**  \n\n***一般来说，在 Maven 项目目录下，没有诸如 lib/ 这样用来存放依赖文件的目录***。 当Maven在执行编译\n或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。  \n默认情况下，每个用户在自己的用户目录下都有一个路径名为.m2/repository/的仓库目录。 有时候，因为某些原因（比如c盘空间不足）,需要修改本地仓库目录地址。\n对于仓库路径的修改，可以通过maven配置文件conf目录下settings.xml来指定仓库路径。  \n其他公共库例如阿里云仓库。\n\n## Maven环境下构建多模块项目\n一个项目下有多个模块（module）时，若A模块依赖B模块，使用 `mvn install` 将模块B复制到本地仓库中，在模块A的pom.xml中加入模块B，便可调用模块B的内容。\n\n## Maven的打包操作\n对于企业级项目，无论是进行本地测试，还是测试环境测试以及最终的项目上线，都会涉及项目的打包操作，对于每个环境下项目打包时，对应的项目所有要的配置资源就会有所区别，实现打包的方式有\n很多种，可以通过ant或者通过idea自带的打包功能实现项目打包，但当项目很大并且需要的外界配置很多时，此时打包的配置就会异常复杂，对于maven项目，我们可以用过pom.xml 配置的方式来实现打包时的环境选择，相比较其他形式打包工具，通过maven 只需要通过简单的配置，就可以轻松完成不同环境先项目的整体打包。\n\n假如一个项目在不同的环境下需要不同的配置文件。\n\n![](https://img.foril.space/maven_switch.jpg?imageView2/1/w/400)\n\n\n可在pom.xml中配置Profiles，应对不同的环境。\n```xml\n<!-- 打包环境配置 开发环境 测试环境 正式环境 -->\n<profiles>\n    <profile>\n        <id>dev</id>\n        <!-- properties可作为变量被外部标签获取 -->\n        <properties>\n            <env>dev</env>\n        </properties>\n        <!-- 未指定环境时，默认打包dev环境 -->\n        <activation>\n            <activeByDefault>true</activeByDefault>\n        </activation>\n    </profile>\n\n    <profile>\n        <id>test</id>\n        <properties>\n            <env>test</env>\n        </properties>\n    </profile>\n\n    <profile>\n        <id>product</id>\n        <properties>\n            <env>product</env>\n        </properties>\n    </profile>\n</profiles>\n ```\n然后在pom.xml中对资源文件进行配置。\n```xml\n<!-- 对于项目资源文件的配置放在build中 -->\n<resources>\n    <resource>\n        <!-- ${}可以获取properties变量 -->\n        <directory>src/main/resources/${env}</directory>\n    </resource>\n    <resource>\n        <directory>src/main/java</directory>\n        <includes>\n            <include>**/*.xml</include>\n            <include>**/*.properties</include>\n            <include>**/*.tld</include>\n        </includes>\n        <filtering>false</filtering>\n    </resource>\n</resources>\n```\n然后就可以通过Maven命令进行打包，`-P`参数选择指定的Profile。  \n如：\n```sh\nmvn package -Pdev -Dmaven.test.skip=true\n```\n\n## Maven依赖的基本概念\n### 依赖范围\n首先需要知道，Maven在编译项目主代码的时候需要使用一套classpath。  \n比如：编译项目代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。  \n其次，Maven在执行测试的时候会使用另外一套classpath。如：junit。  \n最后在实际运行项目时，⼜会使用一套classpath，spring-core需要在该classpath中，而junit不需要。  \n\n那么依赖范围就是用来控制依赖与这三种classpath(编译classpath，测试classpath，运行时classpath)的关系，具体内容见下文。\n\n### 依赖的基本配置\n根元素project下的dependencies可以包含多个dependence元素，以声明多个依赖。每个依赖都应该包含以下元素：\n1. groupId, artifactId, version：**依赖的基本坐标**， 对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。  \n2. Type：依赖的类型，大部分情况下不需要声明。默认值为jar。  \n3. Scope：依赖范围（compile,test,provided,runtime,system）  \n**compile**：**编译依赖范围**。  \n如果没有指定，就会**默认**使用该依赖范围。使用此依赖范围的Maven依赖，对于 *编译、测试、运行* 三种classpath都有效。  \n**test**: **测试依赖范围**。  \n使用此依赖范围的Maven依赖，只对于 *测试* classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。**典型的例子就是JUnit**，它只有在编译测试代码及运行测试的时候才需要。  \n**provided**: **已提供依赖范围**。  \n使用此依赖范围的Maven依赖，对于 *编译和测试* classpath有效，但在运行时无效。**典型的例子是servlet-api**，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍(如：servlet-api)。  \n**runtime**: **运行时依赖范围**。  \n使用此依赖范围的Maven依赖，对于 *测试和运行* classpath有效，但在编译主代码时无效。**典型的例子是JDBC驱动实现**，项目主代码的编译只需要JDK提供的JDBC接⼝，只有在执行测试或者运行项目的时候才需要实现上述接⼝的具体JDBC驱动。  \n**system**: **系统依赖范围**。\n该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，所以一般不使用。 \n\n4. Optional：标记依赖是否可选  \n5. Exclusions： 用来排除传递性依赖。\n\n### 传递性依赖\n传递依赖机制，让我们在使用某个jar的时候就不用去考虑它依赖了什么。也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前项目中。  \n\n***注意： 传递依赖有可能产生冲突！！***  \n冲突场景：  \n```\nA-->B--->C (2.0)\nA-->E--->C (1.0)\n```\n如果A下同时存在两个不同version的C，冲突！！（自动选取同时适合A、B的版本）\n```xml\n<dependencies>\n    <dependency>\n        <groupId>A</groupId>\n        <artifactId>A</artifactId>\n        <version>xxx</version>\n        <exclusions>\n            <exclusion>\n                <groupId>C</groupId>\n                <artifactId>C</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupId>B</groupId>\n        <artifactId>B</artifactId>\n    </dependency>\n</dependencies>\n```\n\n## 参考：\nhttps://www.bilibili.com/video/BV1Fz4y167p5?p=13'),(45,'Gradle学习笔记',1,'2021-11-13 05:26:19',74,'在学习Gradle的过程中遇到了很多不理解的地方，以下是在初步学习中的学习笔记，会在之后逐渐完善勘误。\n## 什么是Gradle\nGradle 是一种开源构建自动化工具，其设计足够灵活，几乎可以构建任何类型的软件。使用基于Groovy的特定领域语言（DSL）来声明项目设置，抛弃了基于XML的各种繁琐配置。面向Java应用为主，当前其支持的语言限于Java，Scala和Groovy，计划未来支持更多语言。 \n\n相比 Ant 的不规范，Maven 的配置复杂、生命周期限制严重，Gradle 既规范也更灵活，可以使用DSL (领域特定语言，如Groovy 或 Kotlin）编写构建脚本，脚本更短小精悍。  \n\n> Ant、Maven 有的 Gradle也有，Gradle有的它们不一定有；  \n> Ant、Maven能干的，Gradle 都能干，而且干得更好\n\n如果你想要做的只是运行一个已经存在的Gradle构建，那么如果构建有一个Gradle wrapper(可以通过构建根目录下的gradlew 和/或 gradlew.bat文件来识别)，你就不需要安装Gradle。您只需要确保您的系统满足Gradle的先决条件（8及以上的JDK）。\n\n## 特性\n### 高性能\nGradle通过只运行那些因为输入或输出改变而需要运行的任务来避免不必要的工作。您还可以使用构建缓存来重用来自先前运行或甚至来自不同机器（具有共享构建缓存）的任务输出。  \nGradle 实施了许多其他优化，开发团队不断努力提高 Gradle 的性能。\n\n### JVM基础\nGradle 在 JVM 上运行，您必须安装 Java 开发工具包 (JDK) 才能使用它。这对于熟悉 Java 平台的用户来说是一个好处，因为您可以在构建逻辑中使用标准 Java API，例如自定义任务类型和插件。它还可以轻松地在不同平台上运行 Gradle。\n\n### 约定\nGradle借鉴了Maven的经验，通过实现约定，使通用类型的项目(如Java项目)易于构建。应用适当的插件，你就可以很容易地为许多项目创建一个轻量级的构建脚本。但这些约定并不会限制你:Gradle允许你重写它们，添加你自己的任务，并对基于约定的构建进行许多其他定制。\n\n### 可扩展性\n你可以很容易地扩展Gradle来提供你自己的任务类型甚至构建模型。Android的构建支持就是一个例子:它添加了许多新的构建概念，比如flavors和构建类型。\n\n### Insight\n构建扫描提供有关构建运行的广泛信息，您可以使用这些信息来识别构建问题。它们特别擅长帮助您识别与构建性能有关的问题。您还可以与他人共享Build Scan，这在您需要咨询修复构建问题的建议时特别有用。\n\n> 推荐阅读：[5 things you need to know about Gradle](https://docs.gradle.org/current/userguide/what_is_gradle.html#five_things)\n\n## The Gradle Wrapper\n执行任何Gradle构建的推荐方法是在Gradle Wrapper的帮助下。\n\nWrapper是一个调用已声明版本的Gradle的脚本，如果需要，可以提前下载该版本。因此，开发人员可以快速启动并运行Gradle项目，而不必遵循手动安装过程。\n\n好处： \n* 在给定的Gradle版本上标准化一个项目，导致更可靠和健壮的构建。  \n* 只需要改变Wrapper的定义就能为不同的用户和执行环境(例如ide或持续集成服务器)提供一个新的Gradle版本。\n\n一个Gradle项目通常为每个子项目提供一个settings.gradle(.kts)文件和一个build.gradle(.kts)文件。Wrapper文件就在gradle目录和项目的根目录中。下面的列表解释了它们的目的。  \n和Wrappr有关的目录结构：\n```\n.\n├── a-subproject\n│   └── build.gradle\n├── settings.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n└── gradlew.bat\n```\n**gradle-wrapper.jar**  \nWrapper JAR文件，包含下载Gradle发行版的代码。\n\n**gradle-wrapper.properties**  \n一个负责配置Wrapper运行时行为的属性文件，例如与此版本兼容的Gradle版本。请注意，更一般的设置，如配置Wrapper以使用代理，需要进入不同的文件。\n\n**gradlew, gradlew.bat**  \n一个shell脚本和一个Windows批处理脚本，用于使用Wrapper执行构建。\n\n### 使用Wrapper\n使用包装器看起来几乎就像在安装了Gradle的情况下运行构建。根据操作系统的不同，你可以运行 `gradlew` 或 `gradlew.bat` 而不是 `gradle` 命令。\n\n\n\n## 使用Gradle构建项目\n### projects 和 tasks\n`projects` 和 `tasks` 是Gradle中最重要的两个概念。\n\n任何一个**Gradle构建**都是由一个project或多个projects组成。每个project或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。\n\n每个project都由多个tasks组成。每个task都代表了构建执行过程中的一个原子性操作。如编译，打包，生成javadoc，发布到某个仓库等操作。\n\n*简单来说，project 相当于一个构建工程的一个模块，而 task 是其中一个模块的一个操作。*\n\n### 调用Groovy\n在 `build.gradle` (*可以称为build script，构建配置脚本*) 中可以调用 Groovy 的类库（也包含 Java 类库），下面是示例：  \n```gradle\n// build.gradle\ntask upper {\n  String str = \'this is a simple test\'\n  println \"原始值：\" + str\n  println \"转大写后：\" + str.toUpperCase()\n}\n```\n执行命令 gradle -q upper\n\n这个构建脚本定义了一个名为upper的task，并向其添加了一个操作。当你运行 `gradle upper` 时，gradle会执行upper task，而upper task又会执行你提供的动作。动作只是一个包含要执行的代码块。\n\n> -q 的作用是静默输出，使输出更加清晰。  \n> Groovy 兼容 Java 语法，我们可以通过在 task 中调用 Groovy 或 Java 的方法来完成想做的操作。  \n\n与其直接操作脚本类路径，建议应用有自己的classpath的插件。对于自定义构建逻辑，建议使用自定义插件。\n\ntask 也可以依赖于其他的 task。\n```gradle\ntasks.register(\'hello\') {\n    doLast {\n        println \'Hello world!\'\n    }\n}\ntasks.register(\'intro\') {\n    dependsOn tasks.hello\n    doLast {\n        println \"I\'m Gradle\"\n    }\n}\n```\n> 许多自带插件预定义了很多你在构建项目中可能遇到的基本操作task，比如 `java` 插件，自带了 `test` 、`classes` 等task，可以直接调用完成测试或编译任务；  \n> `application` 插件（应用`application`插件也会隐式地应用`java`插件）包含了 `run` 等task来运行指定的main类的main方法。\n\n\n### 定义项目version/group\n在 Maven 中，可以明确定义项目版本，构建时会将这个版本包含在 war 或 jar 等制品的文件名称中，推送到 Maven 私服中也需要设置 `group` `artifactId` `version` 信息，那么 Gradle 中如何定义呢？\n\nGradle 中，对应 Maven 的三个参数，将 `artifactId` 变成了 `rootProject.name`，那么只需额外定义 `group` 与 `version`\n```gradle\n//build.gradle\ngroup \'edu.ssdut\'\nversion \'0.0.1\'\n```\n\n## Java 构建入门\n### 生成Java项目\n使用 Maven 时我们可以通过以下命令来创建一个简单的 Java 项目。\n```bash\nmvn archetype:generate -DgroupId=xxx -DartifactId=yyy -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeCatalog=local -DinteractiveMode=false\n```\n使用Gradle创建一个遵循Gradle传统的Java项目，我们可以使用 `gradle init` （built-in task，类似npm init作用）来初始化一个 Java 项目\n> Gradle comes with a built-in task, called init, that initializes a new Gradle project in an empty folder. The init task uses the (also built-in) wrapper task to create a **Gradle wrapper script**, gradlew.\n\n下面我们了解一下生成的东西。\n```\n生成目录结构\n├── gradle ①\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew ②\n├── gradlew.bat ②\n├── settings.gradle ③\n└── app\n    ├── build.gradle ④\n    └── src\n        ├── main\n        │   └── java \n        │       └── demo\n        │           └── App.java\n        └── test\n            └── java \n                └── demo\n                    └── AppTest.java\n```\n① 为wrapper文件生成的文件夹  \n② 启动脚本  \n③ 设置文件，以定义构建名称和子项目  \n④ 构建app项目脚本  \n\n```gradle\n//settings.gradle\nrootProject.name = \'demo\'\ninclude(\'app\')\n```\n`rootProject.name` 为构建分配一个名称，这将重写用其所在目录命名构建的默认行为。建议设置一个固定的名称，因为如果项目是共享的，文件夹可能会改变——例如作为Git仓库的根目录。  \n`include(\"app\")` 定义构建由一个名为app的子项目组成，该子项目包含实际的代码和构建逻辑。可以通过附加的 `include(…)` 语句添加更多子项目。\n\n```gradle\n//app/build.gradle\nplugins {\n    id \'application\' ①\n}\n\nrepositories {\n    mavenCentral() ②\n}\n\ndependencies {\n    testImplementation \'org.junit.jupiter:junit-jupiter:5.7.2\' ③\n\n    implementation \'com.google.guava:guava:30.1.1-jre\' ④\n}\n\napplication {\n    mainClass = \'demo.App\' ⑤\n}\n\ntasks.named(\'test\') {\n    useJUnitPlatform() \n}\n```  \n① 应用`application`插件，增加对在Java中构建命令行应用程序的支持。  \n② 使用Maven中央仓库来解析依赖关系。  \n③ 使用JUnit Jupiter进行测试。   \n④ 这个依赖被`application`使用。   \n⑤ 定义应用程序的主类。\n\n### 运行应用\n由于`application`插件，你可以直接从命令行运行应用程序。`run` 任务告诉Gradle执行分配给mainClass属性的类中的main方法。  \n```cmd\n./gradlew run\n或\ngradle run（不使用Wrapper？）\n```\n<img src=\"https://img.foril.space/gradle_plugin_application.jpg\" width=\'400px\'/>\n\n>当你第一次运行包装器脚本`gradlew`时，可能会有一个延迟，因为这个版本的gradle被下载并存储在本地`~/.gradle/wrapper/dists`文件夹。\n\n### 打包应用\n`application` 插件也可以打包应用程序**及其所有依赖项**。该归档文件还将包含一个脚本，用于使用单个命令启动应用程序。  \n```bash\ngradlew build\n```\n生成`app/build/distributions/app.tar` 和 `app/build/distributions/app.zip`，其中`lib`包含所有的依赖，`bin`包含自动生成的运行脚本。\n\n### 发布一个Build Scan\n构建扫描是用于开发和维护Gradle构建的重要工具。它为你提供了构建的详细信息，并为你识别构建环境、依赖或性能上存在的问题，同时可以帮你更全面地理解并提升构建过程，也便于与他人的合作。  \n在Gradle构建运行时，Build Scans插件会抓取数据，并将数据传送到Build Scans服务端。同时返回一个可被共享的链接，内部包含有用的构建信息。这些信息包含两大类：  \n（1）环境信息，包括操作系统、Java版本和时区；  \n（2）构建相关信息，包含使用的插件、任务、测试以及依赖信息。  \n\n要了解构建在幕后的更多信息，最好的方法就是发布构建扫描。要做到这一点，运行Gradle带`--scan`标志。\n```bash \ngradle build --scan\n```\n\n---\n## 依赖管理\nGradle内置了对依赖项管理的支持，能够满足现代软件项目中遇到的典型场景。  \n依赖关系通常以模块的形式出现。你需要告诉Gradle在哪里可以找到这些模块，以便在构建中使用它们。存储模块的位置称为存储库。通过为构建声明存储库，Gradle将知道如何查找和检索模块。  \n在运行时，如果需要操作特定的任务，Gradle会定位声明的依赖项。依赖关系可能需要从远程存储库下载，从本地目录检索，或者需要在多项目设置中构建另一个项目。这个过程称为依赖关系解析。  \n\n模块可以提供额外的元数据。元数据是更详细地**描述模块**的数据，例如在存储库中**查找模块的坐标、关于项目或其作者的信息**。作为元数据的一部分，模块可以定义需要其他模块才能正常工作。例如，JUnit 5平台模块也需要平台公共模块。Gradle会自动解析这些额外的模块，也就是所谓的**传递依赖**。如果需要，您可以自定义行为来处理项目需求的传递依赖项。\n\n### 声明存储库\nGradle可以解析一个或多个基于Maven、Ivy或flat directory格式的存储库的依赖关系。  \n\nGradle可以同时声明多个存储库按顺序检索，一般情况下只指定`Maven Central`仓库便可以解决大多数情况，具体信息可查看[Gradle官方文档](https://docs.gradle.org/current/userguide/declaring_repositories.html)。\n```gradle\nrepositories {\n    maven {\n        url \'https://maven.aliyun.com/repository/public/\'\n    }\n    mavenLocal()\n    mavenCentral()\n}\n```\n### Configuration\n在学习声明依赖以前，我们需要了解依赖项Configuration的概念。  \nConfiguration为一个Gradle项目声明的每个依赖项都适用于一个特定的**作用域**（对应Maven的`scope`）。例如，一些依赖项应该用于编译源代码，而其他依赖项只需要在运行时可用。Gradle在Configuration的帮助下表示依赖的范围。  \n\n*一般插件都会提前添加好预声明的Configuration。*  \n\n#### Configuration 类型\n在 dependency 前面可指明其依赖类型，可选。常用现成的类型：\n\n|Configuration name|Role|Consumable?|Resolvable?|Description|\n|--|---|--|---|--|\n|api|Declaring API dependencies|no|no|This is where you declare dependencies which are transitively exported to consumers, for compile time and runtime.|\n|implementation|Declaring implementation dependencies|no|no|This is where you declare dependencies which are purely internal and not meant to be exposed to consumers (they are still exposed to consumers at runtime).|\n|compileOnly|Declaring compile only dependencies|no|no|This is where you declare dependencies which are required at compile time, but not at runtime. This typically includes dependencies which are shaded when found at runtime.|\n|compileOnlyApi|Declaring compile only API dependencies|no|no|This is where you declare dependencies which are required at compile time by your module and consumers, but not at runtime. This typically includes dependencies which are shaded when found at runtime.|\n|runtimeOnly|Declaring runtime dependencies|no|no|This is where you declare dependencies which are only required at runtime, and not at compile time.|\n|testImplementation|Test dependencies|no|no|This is where you declare dependencies which are used to compile tests.|\n|testCompileOnly|Declaring test compile only dependencies|no|no|This is where you declare dependencies which are only required at test compile time, but should not leak into the runtime. This typically includes dependencies which are shaded when found at runtime.|\n|testRuntimeOnly|Declaring test runtime dependencies|no|no|This is where you declare dependencies which are only required at test runtime, and not at test compile time.|\n\n#### Configuration 的继承和复合\nConfiguration可以继承其他Configuration以形成继承层次结构。子配置继承任何其超配置声明的整个依赖集。\n```gradle\nconfigurations {\n    smokeTest.extendsFrom testImplementation\n}\n\ndependencies {\n    testImplementation \'junit:junit:4.13\'\n    smokeTest \'org.apache.httpcomponents:httpclient:4.5.5\'\n}\n```\n\n### 声明依赖\n和 Maven 类似，依赖的坐标直接为：group、name、version。此外，引入不同的插件会引入不同的依赖配置类别。\n```gradle\ndependencies {\n    compile group: \'org.apache.commons \', name: \'commons-lang3\', version: \'3.8.1\'\n}\n```\n依赖坐标可以简写（用 : 分隔）：\n```gradle \ndependencies {\n    // Use JUnit Jupiter for testing.\n    testImplementation \'org.junit.jupiter:junit-jupiter:5.7.2\'\n\n    // This dependency is used by the application.\n    implementation \'com.google.guava:guava:30.1.1-jre\'\n}\n```\n\n#### 项目的依赖类型\n* 远程模块依赖：外部仓库  \n* 项目依赖：一个项目依赖另一个项目。如：compile project(\':projectB\')  \n* 文件依赖：依赖本地文件  \n```gradle\ndependencies {\n    //将本地 module library 编译到项目中\n    compile project(\":mylibrary\")\n    //编译远程依赖\n    compile \'com.android.support:appcompat-v7:23.4.0\'\n    //编译本地 jar 包\n    compile fileTree(dir: \'libs\', include: [\'*.jar\'])\n}\n```\n\n## 参考\nhttps://docs.gradle.org/current/userguide/getting_started.html  \nhttps://www.cnblogs.com/hellxz/p/helloworld-gradle.html\nhttps://docs.gradle.org/current/samples/sample_building_java_applications.html\nhttps://www.jianshu.com/p/646deb0010d1  \nhttps://www.jianshu.com/p/642641dc7df3  \nhttps://www.cnblogs.com/quanxi/p/10510142.html'),(46,'Java中的Lambda表达式',1,'2021-12-01 11:51:49',50,'诸多语言中都有自己的Lambda表达式，使用Lambda表达式可以让代码更加紧凑，在很多情况下更便于阅读。  \nLambda 表达式主要用来定义行内执行的方法类型接口，例如一个简单方法接口。\n\n**Java 8中每一个Lambda表达式必须有一个函数式接口与之对应。**  \n如：\n```java\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n## 语法\n```java\n(parameters) -> expression\n或\n(parameters) ->{ statements; }\n```\n* **可选类型声明**：不需要声明参数类型，编译器可以统一识别参数值。\n* **可选的参数圆括号**：一个参数无需定义圆括号，但多个参数需要定义圆括号。\n* **可选的大括号**：如果主体包含了一个语句，就不需要使用大括号。\n* **可选的返回关键字**：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。\n\n可以看出，有了以上特性，对于一个**方法接口**，我们可以用简单的代码表示，使代码更加紧凑简洁。\n```java\ninterface MathOperation {\n    int operation(int a, int b);\n}\n\nMathOperation subtraction = (a, b) -> a - b;\n```\n比如在对数组进行降序排序时，不需要再实现Comparable接口，只需要使用一个Lambda表达式：\n```java\nInteger[] data = {...};\nArrays.sort(data, (v1 , v2) -> v2 - v1);\n```\n## 变量作用域\nLambda 表达式只能引用标记了 final 的外层局部变量（可以不用声明为 final，但是必须不可被后面的代码修改，即隐性的具有 final 的语义），这就是说**不能在 lambda 内部修改定义在域外的局部变量**，否则会编译错误。\n```java\nint num = 1;  \nConverter<Integer, String> s = (param) -> System.out.println(String.valueOf(param + num));\ns.convert(2);\nnum = 5;  \n//报错信息：Local variable num defined in an enclosing scope must be final or effectively final\n```\n此外，Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。'),(47,'Java Optional类学习笔记',1,'2021-12-01 13:49:16',57,'Optional类也是为了Java8引入的重要新特性，主要目的是为了解决臭名昭著的NullPointerException。  \nOptional类是一个泛型类，包装了一个值，既可以含有对象也可以为空。  \n如果不采用Optional的话，要避免不触发NullPointerException，我们需要采用大量的if-else对每一次访问进行检查。  \n而使用Optional的话，我们就可以用**链式编程风格**，一口气间接地写完代码，下面做一个简单比较：\n```java\n// 一般写法\nString version = \"UNKNOWN\";\nif(computer != null){\n  Soundcard soundcard = computer.getSoundcard();\n  if(soundcard != null){\n    USB usb = soundcard.getUSB();\n      if(usb != null){\n        version = usb.getVersion();\n      }\n  }\n}\n// 采用Optional\nString version = Optional.ofNullable(computer)\n                      .map(Computer::getSoundcard) \n                      .map(Soundcard::getUSB)\n                      .map(USB::getVersion)\n                      .orElse(\"UNKNOWN\");\n```\n## 创建实例\n我们可以使用`Optional.of()`或`Optional.ofNullable()`创建一个对象，需要注意的是`of()`方法创建时必须传入一个非空的值，否则还是会报空指针异常，`ofNullable()`方法就没有这个限制，一般我们直接使用后者即可；使用`Optional.empty()`可以直接创建一个内容为空的包装对象。\n```java\n@Test(expected = NoSuchElementException.class)\npublic void whenCreateEmptyOptional_thenNull() {\n    Optional<User> emptyOpt = Optional.empty();\n    emptyOpt.get();\n}\n@Test(expected = NullPointerException.class)\npublic void whenCreateOfEmptyOptional_thenNullPointerException() {\n    Optional<User> opt = Optional.of(user);\n}\n```\n> ### Optional不能序列化，不能作为类的字段(field)  \n> 这点尤为重要，即类要纯粹。如果是POJO就原始类型就可以了，如果是领域对象，则更不应该使用Optional作为field。\n## 访问对象\n可以使用`get()`方法取回Optional实例中的实际值：\n```java\n@Test\npublic void whenCreateOfNullableOptional_thenOk() {\n    String name = \"John\";\n    Optional<String> opt = Optional.ofNullable(name);\n\n    assertEquals(\"John\", opt.get());\n}\n```\n在其中值为空时，`get()`会抛出异常，需要首先判断是否有值：\n```java\n@Test\npublic void whenCheckIfPresent_thenOk() {\n    User user = new User(\"john@gmail.com\", \"1234\");\n    Optional<User> opt = Optional.ofNullable(user);\n    assertTrue(opt.isPresent());\n\n    assertEquals(user.getEmail(), opt.get().getEmail());\n}\n```\n`isPresent()`方法会在值存在时返回true，否则返回false。  \n还有一个方法是`ifPresent()`，这个方法需要传入一个`Consumer`参数，如果对象不为空，就执行传入的参数。\n```java\nopt.ifPresent( u -> assertEquals(user.getEmail(), u.getEmail()));\n```\n> java9中添加了`ifPresentOrElse()` 方法，需要两个参数：一个 Consumer 和一个 Runnable。如果对象包含值，会执行 Consumer 的动作，否则运行 Runnable。\n## 返回默认值\nOptional类提供了API用以返回对象值，或者在对象为空的时候返回默认值。  \n第一个方法是`orElse()`，如果有值则返回该值，没有则返回传递给他的参数。\n```java\n@Test\npublic void whenEmptyValue_thenReturnDefault() {\n    User user = null;\n    User user2 = new User(\"anna@gmail.com\", \"1234\");\n    User result = Optional.ofNullable(user).orElse(user2);\n    assertEquals(user2.getEmail(), result.getEmail());\n}\n```\n还有一个方法是`orElseGet()`，两个方法似乎相同，但对象包含非空值的时候`orElseGet()`方法不会创建参数中的对象（为null时才会调用其中的Lambda参数），在执行较密集的调用时，比如调用 Web 服务或数据查询，这个差异会对性能产生重大影响。\n```java\nUser result = Optional.ofNullable(user).orElse(createNewUser());\nUser result2 = Optional.ofNullable(user).orElseGet(() -> createNewUser());\n```\n## 转换值\n有很多种方法可以转换 Optional  的值。我们从 `map()` 和 `flatMap()` 方法开始。\n先来看一个使用 `map() ` API 的例子：\n```java\n@Test\npublic void whenMap_thenOk() {\n    User user = new User(\"anna@gmail.com\", \"1234\");\n    String email = Optional.ofNullable(user)\n      .map(u -> u.getEmail()).orElse(\"default@gmail.com\");\n\n    assertEquals(email, user.getEmail());\n}\n```\n要注意的是，`map()`方法会把参数mapping返回的值包装在Optional中，而`flatMap()`会直接返回mapping的返回值，如果需要，要自己对mapping包装Optional。  \n\n`map`：*如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。*    \n`flatMap`：*如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。*\n\n```java\npublic class User {    \n    private String position;\n\n    public Optional<String> getPosition() {\n        return Optional.ofNullable(position);   //返回Optional\n    }\n\n    //...\n}\n@Test\npublic void whenFlatMap_thenOk() {\n    User user = new User(\"anna@gmail.com\", \"1234\");\n    user.setPosition(\"Developer\");\n    String position = Optional.ofNullable(user)\n      .flatMap(u -> u.getPosition());\n\n    assertEquals(position, user.getPosition().get());\n}\n```\n此外，Optional  类也提供了按条件“过滤”值的方法。\nfilter() 接受一个 Predicate 参数，返回测试结果为 true 的值。如果测试结果为 false，会返回一个空的 Optional。\n```java\n@Test\npublic void whenFilter_thenOk() {\n    User user = new User(\"anna@gmail.com\", \"1234\");\n    Optional<User> result = Optional.ofNullable(user)\n      .filter(u -> u.getEmail() != null && u.getEmail().contains(\"@\"));\n\n    assertTrue(result.isPresent());\n}\n```\n如果通过过滤器测试，result 对象会包含非空值。\n\n\n## 参考：\n* https://www.cnblogs.com/zhangboyu/p/7580262.html  \n* https://www.jianshu.com/p/21d38afe778d\n* https://blog.csdn.net/lifen0908/article/details/89478904'),(48,'java8 Stream API的使用',1,'2021-12-09 03:45:40',88,'Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中，使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\n\n## 什么是stream\nStream（流）是一个来自数据源的元素队列并支持聚合操作。  \n* **数据源** 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。\n* **聚合操作** 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。\n\n他不是一种数据结构，只是某种数据源的一个视图，数据源可以是一个数组，Java容器或者I/O channel等。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。\n\n### 特征\n和以前的Collection操作不同， Stream操作还有两个基础的特征：\n\n1. **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n2. **内部迭代**： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n\n## 生成流\n通过 `stream()` 方法为集合创建流。\n```java\nList<String> strings = Arrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\");\nList<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());\n```\n## 聚合操作\n### map + collect用法\n获取List列表的所有id\n```java\nList<Long> ids = demos.stream().map(Demo::getId).collect(toList());\n```\nlist变成map\n```java\n Map<Long, Demo> map = demos.stream().collect(toMap(Demo::getId, o -> o));\n```\n### filter\n```java\nDemo target = demos.stream()\n            .filter(d -> targetName.equals.equals(d.getName()))\n            .findFirst()\n            .orElse(null);\n```\n注意`find()`返回的结果是Optional。\n### match\nmatch()是filter()的缩写版本，返回结果只有boolean类型，返回是否匹配。\n```java\nboolean flag = demos.stream()\n            .map(Demo::getName)\n            .anyMatch(condition::contains);\n```\n### distinct\n去重\n```java\nList<Long> ids = demos.map(Demo::getId).distinct().collect(Collectors.toList());\n```\n\n### flatMap\nflatMap方法定义：\n```java\n<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\n```\n参数是一个Function函数式接口，提供T到Stream的转换。其实参考方法实现，flatMap就是将Function转化后的Stream合并成一个Stream。  \n这里举一个我遇到的例子：\n```java\n// private final List<VisFieldNode> fields;\nthis.fields = cd.getFields().stream().map(fd -> fd.getVariables().stream()\n                .map(v -> new VisFieldNode(v,\n                        fd.getAnnotations().stream().map(Objects::toString).collect(Collectors.toList()),\n                        fd.getModifiers().stream().map(Objects::toString).collect(Collectors.toList())\n                )).collect(Collectors.toList()))\n        .flatMap(Collection::stream).collect(Collectors.toList());\n\n/*\n大概就是经历一个\nField->Field->Field \n[Variable,Variable...]->[Variable,Variable...]->[Variable,Variable...]\nVariable->Variable->Variable->Variable->Variable\n[Variable,Variable,Variable,Variable,Variable]\n这样的过程\n*/\n```\n* 对于一个一般的 `List<T>`，经过 `.map()` 后得到 `Stream<R>`，经过 `collect(Collection::toList)`得到List<R>;\n* 若经过 `.map()` 得到 `Stream<List<T>>`，经过 `.collect()` 得到 `List<List<T>>`。\n* 若经过 `.map()` 得到 `Stream<List<T>>`，经过 `.flatMap(Collection::stream)` ，将 `Collection::stream` 得到的 `Stream<Stream<T>>` 合并成一个 `Stream<T>`，最后经过 `.collect()` 得到 `List<T>`。\n\n***\nStream还有一些有用的API比如 `count`、`groupby`、`sorted` 等。可在有需要时查询使用。\n\n## 参考：\n* https://blog.csdn.net/qq_37131111/article/details/99546357  \n* https://www.runoob.com/java/java8-streams.html\n* https://blog.csdn.net/weixin_41835612/article/details/83713891'),(49,'初探Java多线程编程',1,'2021-12-10 02:33:03',23,'多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。\n## 多线程编程的好处\n在多线程程序中，多个线程被**并发**地执行以**提高程序的效率**，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程**共享堆内存**(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。  \n大体来说有以下优点：\n1. 资源利用率更好\n2. 程序设计在某些情况下更简单\n3. 程序响应更快\n## 线程的生命周期\n一个线程从产生到死亡有一个完整的生命周期。\n\n<img width=700 src=\"https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg\"/>\n\n**新建状态**:  \n使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 `start()` 这个线程。\n\n**就绪状态**:  \n当线程对象调用了 `start()` 方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。\n\n**运行状态**:  \n如果就绪状态的线程获取 CPU 资源，就可以执行 `run()`，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。\n\n**阻塞状态**:  \n如果一个线程执行了 `sleep`（睡眠）、`suspend`（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：\n* 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。\n* 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。\n* 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。\n\n**死亡状态**:  \n一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。\n## 创建一个线程\nJava 提供了三种创建线程的方法：\n* 通过实现 Runnable 接口；\n* 通过继承 Thread 类本身；\n* 通过 Callable 和 Future 创建线程。\n\n### 通过实现 Runnable 接口来创建线程\n创建一个新的线程最简单的方法就是创建一个实现Runnable接口的类。  \nRunnable是一个方法接口（所以可以使用lambda表达式），一个类只需要执行一个方法调用 `run()`。  \n```java\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。  \n\n在有了实现了Runnable接口的类后，你就可以在你的代码里实例化线程对象（Thread）了，Thread定义了几个构造方法，常用：\n```java\nThread(Runnable threadOb,String threadName);    // threadName指定新线程的名字\n```\n### 通过继承Thread来创建线程\n创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。  \n继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。  \n该方法尽管被列为一种多线程实现方式，但是***本质上也是实现了 Runnable 接口的一个实例。***\n\nThread类有一些重要的方法和静态方法，可以参考这个链接：[Thread方法](https://www.runoob.com/java/java-multithreading.html.reference)。\n\n>  **可以直接调用Thread类的run()方法么？**  \n当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法使该线程开始执行，JVM会调用该线程的 run() 方法\n\n### 通过Callable和Future创建线程\n1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且**有返回值**。\n\n2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。\n\n3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。\n\n4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。\n\n<img src=\"https://img.foril.space/FutureTask%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpg\"/>\n\n上图展示了FutureTask的继承实现结构，实质上是对Runnable的一个封装。\n\n```java\n@Test\n@DisplayName(\"thread test\")\npublic void testTest() throws ExecutionException, InterruptedException {\n    class IC implements Callable<Integer>{\n        @Override\n        public Integer call() throws Exception {\n            return 1;\n        }\n    }\n    IC ic = new IC();\n    FutureTask<Integer> ft = new FutureTask<>(ic);\n    new Thread(ft).start();\n    System.out.println(ft.get());\n}\n```\n\n### 使用Callable的好处\nRunnable缺少的一项功能是，当线程终止时（即run()完成时），我们无法使线程返回结果。为了支持此功能，Java中提供了Callable接口。  \n而且Callable及Future能抛出异常，Runnable则不行。\n\n## 参考\n* https://www.runoob.com/java/java-multithreading.html\n* https://www.cnblogs.com/dolphin0520/p/3932934.html\n* https://www.cnblogs.com/guanbin-529/p/11784914.html'),(51,'Java中JSON的使用',1,'2021-12-13 07:59:59',142,'Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。\n\n下面是几个常用的 JSON 解析类库：\n\n* Gson: 谷歌开发的 JSON 库，功能十分全面。\n* FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。\n* Jackson: 社区十分活跃且更新速度很快。\n\n以下内容基于 `Jackson` 。\n\n## Jackson简介\nJackson 是当前用的比较广泛的，用来序列化和反序列化 json 的 Java 的开源框架。Jackson 社区相对比较活跃，更新速度也比较快， 从 Github 中的统计来看，Jackson 是最流行的 json 解析器之一 。 Spring MVC 的默认 json 解析器便是 Jackson。 Jackson 优点很多。 Jackson 所依赖的 jar 包较少 ，简单易用。与其他 Java 的 json 的框架 Gson 等相比， Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。\n\nJackson 的核心模块由三部分组成：\n1. jackson-core，核心包，提供基于\"流模式\"解析的相关 API，它包括 JsonPaser 和 JsonGenerator。 Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。\n2. jackson-annotations，注解包，提供标准注解功能。\n3. jackson-databind ，数据绑定包， 提供基于\"对象绑定\" 解析的相关 API （ ObjectMapper ） 和\"树模型\" 解析的相关 API （JsonNode）；基于\"对象绑定\" 解析的 API 和\"树模型\"解析的 API 依赖基于\"流模式\"解析的 API。\n\n> jackson-databind 依赖 jackson-core 和 jackson-annotations，当添加 jackson-databind 之后， jackson-core 和 jackson-annotations 也随之添加到 Java 项目工程中。在添加相关依赖包之后，就可以使用 Jackson。\n\n## 依赖安装\n在 Maven 构建的项目中，在 pom.xml 文件中加入以下依赖即可。（在 `gradle.build` 中 `dependencies` 内直接粘贴Mavan依赖xml可自动转化为gradle形式）\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.5</version>\n</dependency>\n```\n## 序列化：Java对象转换为JSON\nJackson 最常用的 API 就是基于\"对象绑定\" 的 `ObjectMapper`。\n\nObjectMapper 通过 writeValue 系列方法将 java 对象序列化为 json，并将 json 存储成不同的格式：String（writeValueAsString）、Byte Array（writeValueAsBytes）、Writer、File、OutStream、DataOutput。  \nObjectMapper 通过 readValue 系列方法从不同的数据源： String、Byte Array、Reader、File、URL、InputStream 中反序列化为 java 对象。\n\n常用序列化API：\n```java\nwriteValue()\nwriteValueAsString()\nwriteValueAsBytes()\n```\n以下是一个简单的例子：\n```java\n@Test\n@DisplayName(\"jacksonTest\")\npublic void jsonTest() throws IOException {\n    ObjectMapper mapper = new ObjectMapper();\n    List<Person> list = new ArrayList<>();\n    list.add(new Person(\"foril\", 22));\n\n    String s = mapper.writeValueAsString(list);     //转换为String\n    s = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(list);    //prettyPrint\n    mapper.writeValue(new FileOutputStream(\"out/output.json\"), list);   //写入文件\n    byte[] bytes = mapper.writeValueAsBytes(list);  //转换为Bytes\n\n    System.out.printf(s);\n}\n/**\n* 实例所用类\n*/\nclass Person {\n    private String name;\n    private Integer age;\n    private Date birthday;\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public Person() {\n    }\n\n    public Person(String name, Integer age, Date date) {\n        this.name = name;\n        this.age = age;\n        this.birthday = date;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n\n//output\n// [ {\n//   \"name\" : \"foril\",\n//   \"age\" : 22\n// } ]\n```\n## 反序列化：JSON转换为Java对象\n使用 `readValue()` 方法来从JSON转换为Java对象：\n```java\nPerson p = new Person(\"xk\", 22, new Date());\ns = mapper.writeValueAsString(p);\nPerson p2 = mapper.readValue(s, Person.class);  //从字符串转换\n\nReader reader = new StringReader(s);\np2 = mapper.readValue(reader, Person.class);    //从Reader转换\n\nFile f = new File(\"data/p.json\");\np2 = mapper.readValue(f, Person.class);         //从文件转换\n\nURL url = new URL(\"file:data/p.json\");\np2 = mapper.readValue(url, Person.class);       //从网络文件地址转换\n\nInputStream input = new FileInputStream(\"data/p.json\");\np2 = mapper.readValue(input, Person.class);     //从流中转换\n\nbyte[] bytes = mapper.writeValueAsBytes(p);\np2 = mapper.readValue(bytes, Person.class);     //从字节数组中读取\n```\n> * 需要注意的是反序列化时需要对应的类有默认构造函数，Jackson通过默认构造函数以及setter来构造新的对象。  \n> * 目前Jackson似乎不能正确处理内部类以及匿名类，详见[这里](https://stackoverflow.com/questions/28418564/jackson-deserialization-with-anonymous-classes)\n\n### 反序列化为不同类型\n```java\nString s = mapper.writeValueAsString(list);\n\n//转换为数组\nPerson[] people = mapper.readValue(s, Person[].class);\n\n//转换为集合\nList<Person> people  = mapper.readValue(s, new TypeReference<List<Person>>(){});\n\n//转换为Map\nMap<String, Object> jsonMap = mapper.readValue(s, new TypeReference<Map<String,Object>>(){});\n```\n\n## ObjectMapper配置\n在调用 writeValue 或调用 readValue 方法之前，往往需要设置 ObjectMapper 的相关配置信息。这些配置信息应用 java 对象的所有属性上。示例如下：\n```java\n//在反序列化时忽略在 json 中存在但 Java 对象不存在的属性 \nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n   false); \n//在序列化时日期格式默认为 yyyy-MM-dd\'T\'HH:mm:ss.SSSZ \nmapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false) \n//在序列化时忽略值为 null 的属性 \nmapper.setSerializationInclusion(Include.NON_NULL); \n//忽略值为默认值的属性 \nmapper.setDefaultPropertyInclusion(Include.NON_DEFAULT);\n```\n### 时间类型格式化\nJackson 默认会将java.util.Date对象转换成long值（时间戳）,同时也支持将时间转换成格式化的字符串。\n```java\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\nobjectMapper.setDateFormat(dateFormat);\n\nString json = objectMapper.writeValueAsString(对象);\n```\n\n## Using Optional with Jackson\n一般注意不要将Optional作为field，可将getter返回值改为`Optional<T>`作为代替，在这种情况下，我们若直接将对象序列化，会得到一个含有`empty`和`present`字段的JSON，而不是包含我们存放的数据。  \n```json\n{\n  \"name\" : {\n    \"empty\" : true,\n    \"present\" : false\n  },\n  \"age\" : 12,\n  \"birthday\" : \"2010-01-28\"\n}\n```\n而将JSON反序列化时，我们会得到一个` JsonMappingException`异常。  \n\n而我们实际想要的结果，就是Jackson能将一个空的Optional对象视为null，从非空的Optional中直接拿出实际数据。  \n幸运的是，Jackson拥有一套能够解决JDK8数据类型的模块，这其中也包括Optional。  \n我们只需要加入依赖，再将这个模块注册给`ObjectMapper`即可。  \n```gradle\nimplementation \'com.fasterxml.jackson.datatype:jackson-datatype-jdk8:2.9.6\'\n```\n```java\nObjectMapper mapper = new ObjectMapper();\nmapper.registerModule(new Jdk8Module());\n```\n\n## 参考\n* https://blog.csdn.net/psh18513234633/article/details/88599509\n* https://blog.csdn.net/wangxuelei036/article/details/107360975/\n* https://www.baeldung.com/jackson-optional'),(52,'Java中的日志配置',1,'2021-12-19 08:57:34',133,'## 什么是日志\n什么是日志？日志就是Logging，它的目的是为了取代`System.out.println()`。  \n输出日志，而不是用System.out.println()，好处众多\n1. 可以设置输出样式，避免自己每次都写\"ERROR: \" + var；\n2. 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；\n3. 可以被重定向到文件，这样可以在程序运行结束后查看日志；\n4. 可以按包名控制日志级别，只输出某些包打的日志；\n5. ...\n\n## 日志接口和日志实现\n首先需要区分的概念是**日志接口**和**日志实现**。\n\n### 日志接口(slf4j)\nslf4j是对所有日志框架制定的一种规范、标准、接口，并不是一个框架的具体的实现，因为接口并不能独立使用，需要和具体的日志框架实现配合使用（如log4j、logback）。\n\n### 日志实现(log4j、logback、log4j2)\nlog4j是apache实现的一个开源日志组件。  \nlogback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架，是slf4j的原生实现。  \nLog4j2是log4j 1.x和logback的改进版，据说采用了一些新技术（无锁异步、等等），使得日志的吞吐量、性能比log4j 1.x提高10倍，并解决了一些死锁的bug，而且配置更加简单灵活，[官网地址](http://logging.apache.org/log4j/2.x/manual/configuration.html)。\n\n## 为什么需要日志接口，而不直接使用具体的实现\n接口用于定制规范，可以有多个实现，使用时是面向接口的（导入的包都是slf4j的包而不是具体某个日志框架中的包），即直接和接口交互，不直接使用实现，所以可以任意的更换实现而不用更改代码中的日志相关代码。\n\n比如：slf4j定义了一套日志接口，项目中使用的日志框架是logback，**开发中调用的所有接口都是slf4j的，不直接使用logback**，调用是自己的工程调用slf4j的接口，slf4j的接口去调用logback的实现，可以看到整个过程应用程序并没有直接使用logback，当项目需要更换更加优秀的日志框架时（如log4j2）只需要引入Log4j2的jar和Log4j2对应的配置文件即可，完全不用更改Java代码中的日志相关的代码logger.info(“xxx”)，也不用修改日志相关的类的导入的包（import org.slf4j.Logger; import org.slf4j.LoggerFactory;）\n\n***使用日志接口便于更换为其他日志框架。***\n\nlog4j、logback、log4j2都是一种日志具体实现框架，所以既可以单独使用也可以结合slf4j一起搭配使用）\n\n## 在项目中配置日志\n我们在项目中使用slf4j作为日志接口，log4j2作为日志实现。  \n首先需要加入依赖：\n```groovy\ndependencies {\n    //log4j核心\n    implementation group: \'org.apache.logging.log4j\', name: \'log4j-api\', version: \'2.17.0\'\n    implementation group: \'org.apache.logging.log4j\', name: \'log4j-core\', version: \'2.17.0\'\n    //slf4j-api\n    implementation \'org.slf4j:slf4j-api:1.7.25\'\n    //桥接包log4j-slf4j-impl起到适配的作用，因为市面上的日志实现互不兼容，日志框架slf4j要想适用于日志实现log4j2，就需要使用桥接包\n    implementation \'org.apache.logging.log4j:log4j-slf4j-impl:2.9.1\'\n}\n```\n在代码中我们只需要用slf4j的接口便可打印日志。\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass Main {\n    final Logger logger = LoggerFactory.getLogger(getClass());\n    public void logTest(){\n        logger.info(\"xxxxxxxx\");\n    }\n}\n```\n此时我们还没有配置日志的配置文件，具体关于log4j2的配置文件可以参考[这里](https://blog.csdn.net/zheng0518/article/details/69558893)。  \n### 关于配置文件的名称以及在项目中的存放位置\nlog4j 2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为\".xml\",\".json\"或者\".jsn\"。  \n\n系统选择配置文件的优先级(从先到后)如下：\n1. `.classpath`下的名为`log4j2-test.json`或者`log4j2-test.jsn`的文件；\n2. `.classpath`下的名为`log4j2-test.xml`的文件；\n3. `.classpath`下名为`log4j2.json`或者`log4j2.jsn`的文件；\n4. `.classpath`下名为`log4j2.xml`的文件。\n\n我们一般默认使用`log4j2.xml`进行命名。如果本地要测试，可以把`log4j2-test.xml`放到`classpath`，而正式环境使用`log4j2.xml`，则在打包部署的时候不要打包`log4j2-test.xml`即可。\n\n可在resources下加入配置文件，以xml为例：\n```xml\n<!-- log4j2.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration status=\"OFF\">\n    <appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <!--只接受程序中DEBUG级别的日志进行处理-->\n            <ThresholdFilter level=\"DEBUG\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/>\n            <PatternLayout pattern=\"[%d{HH:mm:ss.SSS}] %-5level %class{36} %L %M - %msg%xEx%n\"/>\n        </Console>\n        <!--处理DEBUG级别的日志，并把该日志放到logs/debug.log文件中-->\n        <!--打印出DEBUG级别日志，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档-->\n        <RollingFile name=\"RollingFileDebug\" fileName=\"./logs/debug.log\"\n                     filePattern=\"logs/$${date:yyyy-MM}/debug-%d{yyyy-MM-dd}-%i.log.gz\">\n            <Filters>\n                <!--只接受DEBUG级别的日志，其余的全部拒绝处理-->\n                <ThresholdFilter level=\"DEBUG\"/>\n                <ThresholdFilter level=\"INFO\" onMatch=\"DENY\" onMismatch=\"NEUTRAL\"/>\n            </Filters>\n            <!--输出日志的格式-->\n            <PatternLayout\n                    pattern=\"[%d{yyyy-MM-dd HH:mm:ss}] %-5level %class{36} %L %M - %msg%xEx%n\"/>\n            <Policies>\n                <SizeBasedTriggeringPolicy size=\"500 MB\"/>\n                <TimeBasedTriggeringPolicy/>\n            </Policies>\n        </RollingFile>\n        <!--处理INFO级别的日志，并把该日志放到logs/info.log文件中-->\n        <RollingFile name=\"RollingFileInfo\" fileName=\"./logs/info.log\"\n                     filePattern=\"logs/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log.gz\">\n            <Filters>\n                <!--只接受INFO级别的日志，其余的全部拒绝处理-->\n                <ThresholdFilter level=\"INFO\"/>\n                <ThresholdFilter level=\"WARN\" onMatch=\"DENY\" onMismatch=\"NEUTRAL\"/>\n            </Filters>\n            <PatternLayout\n                    pattern=\"[%d{yyyy-MM-dd HH:mm:ss}] %-5level %class{36} %L %M - %msg%xEx%n\"/>\n            <Policies>\n                <SizeBasedTriggeringPolicy size=\"500 MB\"/>\n                <TimeBasedTriggeringPolicy/>\n            </Policies>\n        </RollingFile>\n        <!--处理WARN级别的日志，并把该日志放到logs/warn.log文件中-->\n        <RollingFile name=\"RollingFileWarn\" fileName=\"./logs/warn.log\"\n                     filePattern=\"logs/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log.gz\">\n            <Filters>\n                <ThresholdFilter level=\"WARN\"/>\n                <ThresholdFilter level=\"ERROR\" onMatch=\"DENY\" onMismatch=\"NEUTRAL\"/>\n            </Filters>\n            <PatternLayout\n                    pattern=\"[%d{yyyy-MM-dd HH:mm:ss}] %-5level %class{36} %L %M - %msg%xEx%n\"/>\n            <Policies>\n                <SizeBasedTriggeringPolicy size=\"500 MB\"/>\n                <TimeBasedTriggeringPolicy/>\n            </Policies>\n        </RollingFile>\n        <!--处理error级别的日志，并把该日志放到logs/error.log文件中-->\n        <RollingFile name=\"RollingFileError\" fileName=\"./logs/error.log\"\n                     filePattern=\"logs/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log.gz\">\n            <ThresholdFilter level=\"ERROR\"/>\n            <PatternLayout\n                    pattern=\"[%d{yyyy-MM-dd HH:mm:ss}] %-5level %class{36} %L %M - %msg%xEx%n\"/>\n            <Policies>\n                <SizeBasedTriggeringPolicy size=\"500 MB\"/>\n                <TimeBasedTriggeringPolicy/>\n            </Policies>\n        </RollingFile>\n        <!--druid的日志记录追加器-->\n        <RollingFile name=\"druidSqlRollingFile\" fileName=\"./logs/druid-sql.log\"\n                     filePattern=\"logs/$${date:yyyy-MM}/api-%d{yyyy-MM-dd}-%i.log.gz\">\n            <PatternLayout pattern=\"[%d{yyyy-MM-dd HH:mm:ss}] %-5level %L %M - %msg%xEx%n\"/>\n            <Policies>\n                <SizeBasedTriggeringPolicy size=\"500 MB\"/>\n                <TimeBasedTriggeringPolicy/>\n            </Policies>\n        </RollingFile>\n    </appenders>\n    <!--     然后定义logger，只有定义了logger并引入的appender，appender才会生效 -->\n    <loggers>\n        <!--默认的root的logger-->\n        <root level=\"DEBUG\">\n            <appender-ref ref=\"Console\"/>\n            <appender-ref ref=\"RollingFileInfo\"/>\n            <appender-ref ref=\"RollingFileWarn\"/>\n            <appender-ref ref=\"RollingFileError\"/>\n            <appender-ref ref=\"RollingFileDebug\"/>\n        </root>\n        <!--额外配置的logger-->\n        <!--记录druid-sql的记录-->\n        <logger name=\"druid.sql.Statement\" level=\"debug\" additivity=\"false\">\n            <appender-ref ref=\"druidSqlRollingFile\"/>\n        </logger>\n        <!--log4j2 自带过滤日志-->\n        <Logger name=\"org.apache.catalina.startup.DigesterFactory\" level=\"error\"/>\n        <Logger name=\"org.apache.catalina.util.LifecycleBase\" level=\"error\"/>\n        <Logger name=\"org.apache.coyote.http11.Http11NioProtocol\" level=\"warn\"/>\n        <logger name=\"org.apache.sshd.common.util.SecurityUtils\" level=\"warn\"/>\n        <Logger name=\"org.apache.tomcat.util.net.NioSelectorPool\" level=\"warn\"/>\n        <Logger name=\"org.crsh.plugin\" level=\"warn\"/>\n        <logger name=\"org.crsh.ssh\" level=\"warn\"/>\n        <Logger name=\"org.eclipse.jetty.util.component.AbstractLifeCycle\" level=\"error\"/>\n        <Logger name=\"org.hibernate.validator.internal.util.Version\" level=\"warn\"/>\n        <logger name=\"org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration\" level=\"warn\"/>\n        <logger name=\"org.springframework.boot.actuate.endpoint.jmx\" level=\"warn\"/>\n        <logger name=\"org.thymeleaf\" level=\"warn\"/>\n    </loggers>\n</configuration>\n```\n之后便可以愉快地使用日志了！\n\n## 参考：\n* https://www.liaoxuefeng.com/wiki/1252599548343744/1264738568571776 （推荐阅读）\n* https://blog.csdn.net/vbirdbest/article/details/71751835'),(53,'2021年度总结',2,'2022-01-01 01:09:23',24,'前半年，卷  \n后半年，摆烂'),(54,'JCommander的使用',1,'2022-02-14 15:27:25',37,'当我们自己开发的Java程序希望通过命令行(CLI)调用时，可以自己在main函数的参数args中解析，但这样的做法极其复杂且常常缺乏鲁棒性。为了不在这里浪费时间，JCommander应运而生。  \n> \"Because life is too short to parse command line parameters\" \n\n## 什么是JCommander\nJCommander是Java解析命令行参数的工具，能够帮助我们快速开发CLI程序，Java在命令行交互的应用，还有很多工具。另一个使用比较广泛的是[Apache Commons CLI](http://commons.apache.org/proper/commons-cli/index.html)，它比JCommander支持更多的命令行风格，但是扩展能力不够。  \n\nJCommander特点主要有：\n* **注解驱动**  \n它的核心功能**命令行参数定义**是基于注解的，这也是选择用它的主要原因。我们可以轻松做到命令行参数与属性的映射，属性除了是String类型，还可以是Integer、Boolean，甚至是File、集合类型。\n* **功能丰富**  \n它同时支持 `POSIX` 和 `Java` 两种风格的两种命令行风格，并且提供了输出帮助文档的能力(`usage()`)，还提供了国际化的支持。\n* **高度扩展**  \n可高度自定义所需要的各类选项以及对域的限制。\n\n## 基本使用\n一般来说，你只需要给你的fields加入注解，就可以使用JCommander来解析命令行：定义一个类，给有需要的field加入`@Parameter`注解。\n```java\nimport com.beust.jcommander.Parameter;\n\npublic class Args {\n  @Parameter\n  private List<String> parameters = new ArrayList<>();\n\n  @Parameter(names = { \"-log\", \"-verbose\" }, description = \"Level of verbosity\")\n  private Integer verbose = 1;\n\n  @Parameter(names = \"-groups\", description = \"Comma-separated list of group names to be run\")\n  private String groups;\n\n  @Parameter(names = \"-debug\", description = \"Debug mode\")\n  private boolean debug = false;\n}\n```\n然后只需要让JCommander去解析：\n```java\nclass Main {\n    @Parameter(names={\"--length\", \"-l\"})\n    int length;\n    @Parameter(names={\"--pattern\", \"-p\"})\n    int pattern;\n\n    public static void main(String ... argv) {\n        Main main = new Main();\n        JCommander.newBuilder()\n            .addObject(main)\n            .build()\n            .parse(argv);\n        main.run();\n    }\n\n    public void run() {\n        System.out.printf(\"%d %d\", length, pattern);\n    }\n}\n```\n## 参数类型\n代表参数的字段可以是任何类型。基本类型（Integer、Boolean等……）默认支持，您可以编写**类型转换器**来支持任何其他类型（File等……）。\n### Boolean\n对于Boolean类型的域，JCommander默认其参数数量（arity）为0，就是说只要有这个参数就默认为true，没有就为false。\n```java\n@Parameter(names = \"-debug\", description = \"Debug mode\")\nprivate boolean debug = false;\n```\n如果向指定这个参数默认为true，可以将他的参数数量设置为1，这样就需要明确指出这个参数值的值才可以运行。\n```java\n@Parameter(names = \"-debug\", description = \"Debug mode\", arity = 1)\nprivate boolean debug = true;\n```\n需要使用`program -debug true`或`program -debug false`来调用。\n\n> 当被装饰的域的类型是String、Integer、int、Long或者long时，JCommander会自动将值转化为对应的类型。当传入的参数不能被转化为对应类型时，会抛出异常。\n\n### Lists\n当域的类型是List时，JCommander会将其转为一个可出现多次的选项。比如：\n```java\n@Parameter(names = \"-host\", description = \"The host\")\nprivate List<String> hosts = new ArrayList<>();\n```\n可以使用以下命令来向hosts传入两个值：\n```java\njava Main -host host1 -verbose -host host2\n```\n### 密码\n如果您的参数之一是密码或您不希望在命令行历史记录中显示的其他值，则可以将其声明为密码类型，然后 JCommander 将要求您在控制台中输入它。\n```java\npublic class ArgsPassword {\n  @Parameter(names = \"-password\", description = \"Connection password\", password = true)\n  private String password;\n}\n```\n当你在程序中运行时，你会得到如下的提示：\n```sh\nValue for -password (Connection password):\n```\n需要在输入密码后才能继续，在Java5及以前版本中，密码会被回显，需要设置`echoInput=false`来取消回显；而在Java6及之后版本中密码默认不会显示。\n\n## 自定义类型\n### Single value\nJCommander提供IStringConverter和IParameterSplitter两个接口来将参数绑定到自定义类型或更改JCommander拆分参数的方式（默认为逗号拆分）。  \n很多时候，我们的应用程序需要通过命令行解析更复杂的类型（例如文件、主机名、列表等）。为此，您可以通过实现以下接口来编写类型转换器：\n```java\npublic interface IStringConverter<T> {\n  T convert(String value);\n}\n// 例如\npublic class FileConverter implements IStringConverter<File> {\n  @Override\n  public File convert(String value) {\n    return new File(value);\n  }\n}\n```\n然后只需要在对应的域上加上注解，并加入converter属性。\n```java\n@Parameter(names = \"-file\", converter = FileConverter.class)\nFile file;\n```\n### List value\n如果是一个List域，默认会调用List<>中的泛型类的converter，并以逗号为分隔符，将字符串拆分后一个个作为输入得到List。\n```java\n@Parameter(names = \"-files\", converter = FileConverter.class)\nList<File> files;\n```\n应该使用如下命令调用。\n```sh\n$ java App -files file1,file2,file3\n```\n也可以IStringConverter中的泛型改为List，例如`IStringConverter<List<File>>`，然后手动解析字符串中的逗号等分隔符，然后加入List中返回。\n\n如果觉得在每一个域上都需要加入converter很麻烦，可以用ConverterFactory在JCommander实例上加入一个实现了指定接口的工厂类实例，详细看[这里](http://jcommander.org/#single-value)。\n\n### 分隔符\n给`@Parameter`的`splitter=`属性传入一个实现了`IParameterSplitter`接口的类，可以自定义分隔符。\n```java\npublic interface IParameterSplitter {\n  List<String> split(String value);\n}\n```\n如下是一个以分号为分隔符的接口实现：\n```java\npublic static class SemiColonSplitter implements IParameterSplitter {\n    public List<String> split(String value) {\n      return Arrays.asList(value.split(\";\"));\n    }\n}\n\n/************/\n\n@Parameter(names = \"-files\", converter = FileConverter.class, splitter = SemiColonSplitter.class)\nList<File> files;\n```\n## 参数校验\n### 单个参数校验\n单个参数校验用于那些指定参数有一定限制的情况，比如用Integer记录年龄必须为非负数，String的长度必须小于10等限制。  \n只需要在`@Paramter`注解中加入`validateWith=`属性，传入一个实现了`IParameterValidator`接口的类即可。\n```java\n// 接口\npublic interface IParameterValidator {\n /**\n   * Validate the parameter.\n   *\n   * @param name The name of the parameter (e.g. \"-host\").\n   * @param value The value of the parameter that we need to validate\n   *\n   * @throws ParameterException Thrown if the value of the parameter is invalid.\n   */\n  void validate(String name, String value) throws ParameterException;\n}\n\n/************/\n\n// 实现\npublic class PositiveInteger implements IParameterValidator {\n public void validate(String name, String value)\n      throws ParameterException {\n    int n = Integer.parseInt(value);\n    if (n < 0) {\n      throw new ParameterException(\"Parameter \" + name + \" should be positive (found \" + value +\")\");\n    }\n  }\n}\n\n/************/\n\n// 调用\n@Parameter(names = \"-age\", validateWith = PositiveInteger.class)\nprivate Integer age;\n\n@Parameter(names = \"-count\", validateWith = { PositiveInteger.class, CustomOddNumberValidator.class })\nprivate Integer value;\n```\n### 全局参数验证\n全局参数验证用于多个参数之间的限制关系，比如不能同时出现的参数等情况。这种情况下就不能单纯利用注解中的参数验证来实现，需要自行通过获得参数后在代码中加入限制。\n\n## 主参数\n到目前为止，我们看到的所有`@Parameter`注解都定义了一个名为`names`的属性。您可以定义一个（**最多一个**）参数而不使用任何此类属性。此参数可以是列表或单个字段（例如字符串或具有转换器的类型，例如文件），在这种情况下，只需要一个主要参数。\n```java\n@Parameter(description = \"Files\")\nprivate List<String> files = new ArrayList<>();\n\n@Parameter(names = \"-debug\", description = \"Debugging level\")\nprivate Integer debug = 1;\n```\n这样可以允许你解析以下命令：\n```bash\n$ java Main -debug file1 file2\n```\nfiles域就会得到`file1`和`file2`两个字符串。\n\n## 参数分隔符\n默认情况下，参数由空格分隔，但您可以更改此设置以允许使用不同的分隔符：\n```java\n@Parameters(separators = \"=\")\npublic class SeparatorEqual {\n  @Parameter(names = \"-level\")\n  private Integer level = 2;\n}\n```\n之后便可以使用\n```bash\n$ java Main -log:3\n$ java Main -level=42\n```\n## 帮助属性\n如果您的参数之一用于显示一些帮助或用法，则需要使用`help`属性：\n```java\n@Parameter(names = \"--help\", help = true)\nprivate boolean help;\n```\n如果您省略此布尔值，JCommander将在尝试验证您的命令并发现您未指定某些必需参数时发出错误消息。\n\n## 使用文档\n您可以在用于解析命令行的 JCommander 实例上调用`.usage()`以生成程序理解的所有选项的摘要：\n```bash\nUsage: <main class> [options]\n  Options:\n    -debug          Debug mode (default: false)\n    -groups         Comma-separated list of group names to be run\n  * -log, -verbose  Level of verbosity (default: 1)\n    -long           A long number (default: 0)\n```\n您可以通过在 JCommander 对象上调用`.setProgramName()`来自定义程序的名称。前面有星号的选项是必需的。您还可以通过设置`@Parameter`注解的`order`属性来指定调用`.usage()`时每个选项的显示顺序：\n```java\nclass Parameters {\n    @Parameter(names = \"--importantOption\", order = 0)\n    private boolean a;\n\n    @Parameter(names = \"--lessImportantOption\", order = 3)\n    private boolean b;\n```\n\n## 参考：\n* https://blog.csdn.net/adalf90/article/details/80492795\n* http://jcommander.org/#_overview'),(55,'为什么logger不采用单例模式',1,'2022-02-15 14:35:21',17,'在对日志logger的学习使用中想到，为什么每次构造logger实例都需要传入类的类型。比如\n```java\n Logger logger = Logger.getLogger(\"com.foo.Bar\");\n ```\n就在思考为什么一定要传入一个类？为什么不使用一个单例模式，声明一个public static的logger，只需要在其他地方引入然后直接使用就行，在实际试验后发现这样似乎也没有什么显式的问题，所有日志都能够正常记录，也不会显示出这个logger究竟是传入了什么类，然后就在网上搜索相关问题。\n\n```java\n//private final static Logger logger = LoggerFactory.getLogger(javaParserUtils.class);\nprivate final static Logger logger = LoggerFactory.getLogger(\"sdafas\");\n```\n得到的答案大概就是这个可以作为一个习惯做法，log4j和其他日志框架的约定是为每个类定义一个静态日志logger。  \n1. 你完全可以不使用类作为logger的名称，传入任何一个字符串都可以。\n2. 传入一个类的好处可以总结为：\n   * 使用方便。在复杂的Java EE应用程序中，您不必担心logger名称重复。如果其他人也使用你的logger名称，你可能有一个不仅包括你的类的输出的日志文件；\n   * 易于检查logging类，因为**logger名称将显示在日志文件中**。您可以快速导航到特定的课程；\n   * 当你分发你的类时，人们可能希望从你的class直接重定向到一个特定的文件。在这种情况下，如果您使用特殊的logger名称，我们可能需要检查源代码，如果源代码不可用，则无法执行此操作。\n\n## 参考\n* https://stackoverflow.com/questions/14596690/why-log4js-logger-getlogger-need-pass-a-class-type'),(56,'Java遍历时删除',1,'2022-03-04 02:06:39',64,'之前写代码时遇到过在遍历时需要删除对象元素的问题，也记得看到过好多解决方案，这里做一个整理。  \n\n## 两种常见错误方法\n```java\n@Test void concurrentTest(){\n    List<Integer> list = new ArrayList<>();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n    list.add(4);\n    list.add(5);\n    for(Integer i: list){\n        if(i.equals(3)){\n            list.remove(i);\n        }\n    }\n}\n```\n在以上代码中，需要在遍历集合的同时删除其中的一个元素，但是这样的删除方式会抛出`ConcurrentModificationException`的运行时异常，使用IDEA也会同时提醒The loop can be replaced with \'Collection.removeIf\'。\n\nJDK的API中对该异常的描述是：  \n当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。\n例如，**某个线程在 Collection 上进行迭代时，通常不允许另一个线程修改该 Collection**。通常在这些情况下，迭代的结果是不确定的。如果检测到这种行为，一些迭代器实现（包括 JRE 提供的所有通用 collection 实现）可能选择抛出此异常。执行该操作的迭代器称为快速失败迭代器，因为迭代器很快就完全失败，而不会冒着在将来某个时间任意发生不确定行为的风险。\n注意，此异常不会始终指出对象已经由不同 线程并发修改。如果单线程发出违反对象协定的方法调用序列，则该对象可能抛出此异常。例如，如果线程使用快速失败迭代器在 collection 上迭代时直接修改该 collection，则迭代器将抛出此异常。\n注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败操作会尽最大努力抛出 ConcurrentModificationException。因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。\n\n若使用索引来删除元素，如以下代码\n```java\n @Test void concurrentTest(){\n    List<Integer> list = new ArrayList<>();\n    list.add(1);\n    list.add(2);\n    list.add(2);\n    list.add(4);\n    list.add(5);\n    for(int i = 0;i<list.size();i++){\n        if(2== list.get(i)){\n            list.remove(i);\n        }\n    }\n    System.out.println(list);\n}\n```\n得到的结果是\n```\n[1, 2, 4, 5]\n```\n只删除了一个2，是因为list删除了一个元素后，其他元素向前补齐，第二个2被遗漏。\n\n## 常见解决方案\n在对Java集合进行遍历同时删除必须要使用迭代器。  \n第一种解决方案就是使用迭代器：\n```java\nIterator<Integer> it = list.iterator();\nwhile(it.hasNext()){\n    if(2==it.next()){\n        it.remove();\n    }\n}\n```\n使用迭代器遍历且使用迭代器自己的`remove`方法，这个迭代器仍然是合法的。这里需要注意的是每次调用迭代器的`next`只能调用一次`remove`方法，连续调用会抛出`UnsupportedOperationException`，切调用`remove`前必须调用过一次`remove`。\n\n第二种解决方案就是利用IDEA的推荐，修改为\n```java\nlist.removeIf(i -> i.equals(3));\n```\n调用接口来删除集合中的元素，也是一种解决方案。\n\n\n\n## 参考\n* https://www.cnblogs.com/jinglecode/p/5603545.html\n* https://www.cnblogs.com/goody9807/p/6432904.html'),(58,'在前端项目中使用ESLint，Prettier与EditorConfig的笔记',1,'2022-03-28 13:26:41',40,'最近在前端项目编写过程中为了统一代码风格以及实现编辑器中对代码风格的提示，尝试了linter和Prettier等工具，在应用过程中发现了很多没明白的配置，花了很长时间才有了一个大概理解。\n\n## 他们都是什么？\n### ESLint\n<img src=\"https://d33wubrfki0l68.cloudfront.net/204482ca413433c80cd14fe369e2181dd97a2a40/092e2/assets/img/logo.svg\" width=80px style=\"float:right\" >\n\n是一个开源的 JavaScript 的 linting 工具，使用 espree 将 JavaScript 代码解析成**抽象语法树(AST)**，然后通过AST来**静态分析**我们的代码，从而给予我们两种提示：  \n1. 代码质量问题：使用方式有可能有问题(problematic patterns)\n2. 代码风格问题：风格不符合一定规则 (doesn’t adhere to certain style guidelines)\n\n许多大公司都有自己关于js项目的ESLint代码标准，认可度比较高的是[Airbnb的标准](https://www.npmjs.com/package/eslint-config-airbnb)，你可以通过`yarn add -D eslint-config-airbnb`，然后在`.eslintrc.json`加入：`\"extends\": [\"airbnb\"]`（可省略`eslint-config-`）来完成对于代码风格的配置。\n\n### Prettier\n<img src=\"https://prettier.io/icon.png\" width=80px style=\"float:right\" />\n\nPrettier 的格式化代码的功能与 ESLint 的非常相似，但是它并**不检查代码质量问题**。它只是作为一个代码格式化工具（Code Formatter），是 js **特有的**格式化工具，里面很多配置项是 js 这门语言特有的规范。对于它原生支持的 JavaScript 而言，它做的非常好。然而，同时它也支持 JSX、Flow、TypeScript、HTML、JSON、CSS 等其他众多语言。\n\n### EditorConfig\n<img src=\"https://editorconfig.org/logo.png\" width=80px style=\"float:right\" />\n\nEditorConfig 既不检测也不格式化你的代码。它仅仅在开发者团队内部使用的所有 IDE 和编辑器之间定义了一份标准的代码风格指南（**提供一个统一的设置和标准，而且通过各个主流编辑器和 IDE 可以自动同步设置，在不同的文件自动更改尾行配置或者是缩进编码等问题**）。比如，一个团队主要使用 Sublime Text 和 VSCode，EditorConfig 能够使得它们在单个文件内定义公共的缩进模式（空格或制表符）。  \nEditorConfig 配置的是比较基础的东西，基本上你用编辑器本身能干的操作就可以用它来干。比如 Tab 变几个空格啊、换行符是 CR 还是 CRLF 啊、文件编码是不是 UTF-8 啊这种问题。  \n而且它不只局限于格式化，名字也能看出来是“Config”（配置）而不是“Formatter”（格式化器）。你也可以用它来配置诸如让 IDE 忽略特定的编译警告错误之类的。\n\n所以你会发现它跟编程语言本身没什么关系，各个语言的项目都能看到 `.editorconfig` 的身影，它更多地干的是当你用特定 IDE 时能配置的那些东西，好让那些不用这个 IDE 的、或者它 IDE 配置跟你不一样的开发者也能使用相同的编辑器方案。当然了它确实可以通过插件的形式去支持一些其他语言特有的格式化方案，不过并不常用。\n\n## 为什么我要用三者，其中一个不行吗？\n上文所说，ESLint能够应用**代码质量规则**和**格式化规则**这两种规则，如果可以的话，它还能自动修复代码。另一方面，Prettier 只能检查代码中的格式错误，但是在这一方面上，它却比 ESLint 更专业。\n\n因此，为了在代码质量和格式化方面达到最佳检测体验，你确实应该同时使用这两个工具。\n\n至于有关 EditorConfig 和 Prettier 的第二个灵魂拷问，答案很简单，它们谁都替代不了对方。**EditorConfig 的作用是配置你的编辑器，以便你所编写的代码已经是格式良好的了，而 Prettier 要做的则是格式化你已经编写的代码。**与 Prettier 相比，EditorConfig 可用于更多的语言和项目。\n\n***\n所以总结来说，虽然这三者的目的趋同，但是它们仍是**术业有专攻**的。\n\n### 解决模式\n所以我们想使用 *专事专办* 的方法。在这种情况下，ESLint 成为了我们的代码质量检测器，Prettier 充当代码格式化工具，而 EditorConfig 将为每个人提供正确的编辑器配置。\n\n* 与编辑器相关的所有配置（结尾行、缩进风格、缩进大小等等）应该由 EditorConfig 来处理。\n* 和代码格式相关的一切事物应该由 Prettier 处理。\n* 剩下的（代码质量）则由 ESLint 负责。\n\n## 如何友好使用三者结合\n项目中我采用了next.js作为开发框架，项目中默认配置了ESLint，提供一个开箱即用的ESLint体验，默认下载`eslint`和`eslint-config-next`作为项目开发依赖，只要你在`.eslintrc.json`中配置extend一个rule set，就可以完成需要的规则集合的配置。  \n\n> Prerequisite：\n> * 本地或全局安装 Prettier 和 eslint\n> * 编辑器支持 EditorConfig 或安装插件\n\n想要加入 Prettier， 就需要我们首先停用可能与 Prettier 冲突的所有 ESLint 规则（仅指代码格式规则）。幸运地是，`eslint-config-prettier` 包已经帮我们做了这件事。\n```bash\nyarn add -D eslint-config-prettier\n```\n接下来我们重写 `.eslintrc.json` 文件，把 prettier 添加到 extends 数组中，并移除我们全部已有的代码格式规则：\n```json\n{\n  \"extends\": [\"eslint:recommended\", \"prettier\"],\n  \"env\": {\n    \"es6\": true,\n    \"node\": true\n  }\n}\n```\nprettier 配置会覆盖先前 extends 数组中一些配置，禁掉所有 ESLint 的代码格式规则。有了这个配置，Prettier 和 ESLint 就可以相安无事地**独自运行**了。这意味着我们需要运行 `npx eslint main.js` 和 `npx prettier main.js --write` 这样的两个命令来检测与格式化文件，这样非常不方便，我们将通过添加 eslint-plugin-prettier 包来让 ESLint 集成 Prettier。\n```bash\nyarn add -D eslint-plugin-prettier\n```\n接着重写 `.eslintrc.json` 文件，在 plugins 数组中添加 prettier 插件，并设置新建的 prettier 规则为 error，从而达到 prettier 格式错误被当作 ESLint 错误的效果。\n```json\n{\n  \"extends\": [\"eslint:recommended\", \"prettier\"],\n  \"env\": {\n    \"es6\": true,\n    \"node\": true\n  },\n    \"plugins\": [\n    \"prettier\"\n  ],\n  \"rules\": {\n    \"prettier/prettier\": \"error\"\n  }\n}\n```\n接下来就可以通过`npx eslint main.js`得到输出了，输出会将prettier标记的格式错误通过ESLint输出，所有的问题一次性全部输出。\n\n`eslint-plugin-prettier` 提供了这样一个配置 plugin:prettier/recommended，具体内容如下:\n> 注意：使用 eslint-plugin-prettier 和 --fix 时开启 arrow-body-style & prefer-arrow-callback 可能会导致 issue，因此建议关闭这两条规则。\n```json\n{\n  \"extends\": [\"prettier\"],\n  \"plugins\": [\"prettier\"],\n  \"rules\": {\n    \"prettier/prettier\": \"error\",\n    \"arrow-body-style\": \"off\", \n    \"prefer-arrow-callback\": \"off\"\n  }\n}\n```\n\n因此我们的 .eslintrc.js 可以直接简化为：\n```json\n{\n  \"extends\": [\"plugin:prettier/recommended\"]\n}\n```\n这样配置结束后，你就可以在 Prettier 的配置文件 `.prettierrc.json` 中配置你想要的代码格式化规则了：\n```json\n{\n  \"semi\": true\n}\n```\n这样我们每次写完代码格式化都可以将代码按照配置的规范进行优化，但每次都需要将设置编辑器中空格数量，尾行配置，编码等代码风格设置重新配置。\n\n这时我们就需要引入 EditorConfig，让我们无论使用什么编辑器都可以拥有相同的编辑器配置（VS Code需要安装[插件](https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig)，可以根据文件类型自动更新编辑器配置，这一点很有用）。  \n这也意味着 Prettier 和 EditorConfig 共享一些配置项，我们需要**避免在两个单独的文件中重复这些配置项**，并让二者保持同步（比如：尾行配置）。  \n***Prettier 的最新版本通过解析 .editorconfig 文件来确定要使用的配置选项解决了此问题。***\n\n这些选项仅限于：\n```sh\n# .editorconfig\nend_of_line\nindent_style\nindent_size/tab_width\nmax_line_length\n```\n这些配置选项将覆盖以下 Prettier 选项（**如果未在 `.prettierrc` 中定义它们**）：\n```json\n// .prettierrc\n\"endOfLine\"\n\"useTabs\"\n\"tabWidth\"\n\"printWidth\"\n```\n与 ESLint 和 Prettier 一样，如果要更改配置，规则就是检查它是否是 EditorConfig 或 Prettier 的相关配置，然后在适当的文件中进行更改。这 4 个选项之外的先前配置选项仅只写到 `.editorconfig` 中。\n\n配置完成后，与代码风格相关的简单配置就可以直接在 `.editorconfig` 中配置，与 js 代码风格相关的一些配置（如行末分号等）可以在 `.prettierrc.json` 中修改，其他与代码质量息息相关的复杂问题配置可在 `.eslintrc` 中通过配置规则集合或手动覆盖规则。  \n\n有了三个工具的结合，确实可以在很大程度上提高你的开发体验。\n\n## 参考：\n\n[为什么你要用ESLint，Prettier和EditorConfig](https://juejin.cn/post/6924249306039844872)\n\n[无冲突设置ESLint，Prettier和EditorConfig](https://juejin.cn/post/6924546232945737742)\n\n[ Prettier 和 EditorConfig](https://segmentfault.com/q/1010000040744932)\n\n[搞懂 ESLint 和 Prettier](https://zhuanlan.zhihu.com/p/80574300)'),(239,'使用Electron以及Next.js踩坑记录',1,'2022-04-12 12:48:25',69,'最近毕设准备采用 Electron 将 Web 项目迁移到本地应用，Next.js 相比 CRA 封装了很多开箱即用功能，但在学习过程中还是踩了一些坑，以下做一个记录。\n\n当我想利用 `next export` 生成静态文件并用 Electron 直接 `loadFile()` 来显示页面时，发现生成的页面没有任何样式和 js 脚本，通过 Chrome 开发者工具检查发现生成的资源路径全部都是 `/_next/...` 这种形式。\n\n<img src=\"https://img.foril.space/next_export_bug.png\" width=600px style=\"margin:10px auto\"/>\n<img src=\"https://img.foril.space/next_export_bug2.png\" width=600px style=\"margin:10px auto\"/>\n\n在网上搜索解决方案后发现这个问题早在2019年就有在社区[讨论](https://github.com/vercel/next.js/issues/8158)过，主要出现在不使用服务器而是直接单独使用 html。\n\n根据官网介绍，`next export` 允许你将 Next.js 应用程序导出到静态 HTML，这样可以独立运行，而**不需要 Node.js 服务器**。  \n`next export` 构建了一个 HTML 版本的应用程序。在 `next build` 过程中，`getStaticProps` 和 `getStaticPaths` 将为页面目录中的每个页面生成一个 HTML 文件(动态路径会更多)。然后，`next export`将把已经导出的文件 **拷贝** 到正确的目录中。\n\n也许由于是面向服务器的原因，所有的静态文件资源路径都是`/_next/...` 的形式，导致的问题就是生成的静态文件用于 Electron 时所有资源请求失败。\n\n## 思考\n\nNext.js 官方并没有给出网上的解决方案，大概是通过 Next.js 等服务器没有这样的根路径问题，在企图与 Electron 配合 `loadFile` 使用时就会出现<u>请求地址并不是对于操作系统而言的相对路径而是绝对路径</u>。这一点我们也可以通过使用 `serve` 来验证。\n\n```bash\n# yarn global add serve\nserve ./out/\n```\n\n启动 serve 服务，这时候打开对应端口，我们可以发现请求地址变为了类似 `http://localhost:3000/_next/static/chunks/webpack-cb7634a8b6194820.js` 这样的地址，对于这样的地址，服务器就可以正确匹配到静态资源（而Electron 无法通过本地资源在根目录下找到匹配），则可以正确加载资源。\n\n所以接下来如果想要使用 Electron 和 Next.js 结合，你可以：\n\n1. 手动将生成的所有 `html` 文件中的资源路径修改，加入 `.`（不推荐）\n2. 在 `next.config.js` 中加入\n   ```js\n   module.exports = {\n     assetPrefix: \".\",\n   };\n   ```\n   可以在生成的资源路径中自动加入前缀`.`\n3. 继续使用 Next.js 服务器，转而在 `Electron` 中使用 `loadURL` 解决问题。\n\n## 注意\n同时需要注意的一点是 `electron export` 后不能使用 `API Routes`，这一点在[官方文档](https://nextjs.org/docs/api-routes/introduction#caveats)中也有提及。\n\n## 参考\n* https://simonallen.coderbridge.io/2021/07/15/nextjs-export-static/\n* https://github.com/vercel/next.js/issues/8158\n* https://nextjs.org/docs/advanced-features/static-html-export\n* https://nextjs.org/docs/api-routes/introduction'),(240,'Java项目中由于依赖导致的日志冲突Warning',1,'2022-04-19 06:05:45',56,'在 Gradle 项目中安排了两个子模块，一个负责提供核心功能包以及 CLI API，另一个 Spring Boot 负责提供作为REST服务器为前端提供服务。在运行时发现警告：\n`org.apache.logging.log4j.LoggingException: log4j-slf4j-impl cannot be present with log4j-to-slf4j`，在查阅[ slf4j 文档 ](https://www.slf4j.org/codes.html#multiple_bindings)后大意是说SLF4J API 被设计为一次绑定一个且只绑定一个日志框架。如果class path上存在多个绑定，SLF4J 将发出警告，列出这些绑定的位置。  \n思考后应该是 Spring Boot **以核心包模块作为依赖**，而这个包里使用了 `log4j2` 作为日志实现以便于在 CLI API 使用时输出日志，而 Spring Boot 本身也提供日志实现，两个日志实现发生冲突，则报出上述警告。  \n\n> 需要注意的是，SLF4J 发出的警告仅仅是一个警告。即使存在多个绑定，SLF4J 也将选择一个日志框架/实现并与其绑定。SLF4J 选择绑定的方式是由 JVM 决定的，出于所有实际目的，应该认为是随机的。从版本1.6.6开始，SLF4J 将命名它实际绑定到的框架/实现类。\n\n我想要达到的效果是：\n* 在 CLI API 上使用对应模块的日志输出，也就是log4j-slf4j-impl，按照配置将日志输出到文件中\n* 在服务器中按照 Spring Boot 的默认日志配置，将日志打印到控制台\n\n那么我只需要在 Spring Boot 模块中排除核心模块的日志框架即可，在 `build.gradle` 中加入\n```groovy\nconfigurations {\n    ...\n    all {\n        // avoid two bindings of slf4j\n        exclude group: \'org.apache.logging.log4j\', module: \'log4j-slf4j-impl\'\n    }\n}\n```\n即可实现不同的API方式使用不同的日志输出方法；  \n\n如果要在服务器提供服务过程中同样使用核心包的日志输出配置，那么就可以改为\n```groovy\nexclude group: \'org.springframework.boot\', module: \'spring-boot-starter-logging\'\n```\n这样在服务器运行过程中生成的日志也会和 CLI 一样被记录在文件中。\n\n## 参考：\n* https://stackoverflow.com/questions/59629214/caused-by-org-apache-logging-log4j-loggingexception-log4j-slf4j-impl-cannot-be\n* https://blog.csdn.net/supingemail/article/details/112944282\n* https://www.slf4j.org/codes.html#multiple_bindings'),(244,'P 问题与 NP 问题',1,'2022-11-21 07:06:54',5,'最近多次在各个领域上听到 P 问题和 NP 问题等论述，于是打算自己浅浅了解一下有关方面的内容。以下内容多来自于网络博客的摘抄总结，原文章见参考章节。\n\n## P 问题\n当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。  \n自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至是不可解的。\n\n针对能够找到多项式级复杂度的问题，我们引入 P 类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题。P 是英文单词多项式的第一个字母。\n\n## NP 问题\n接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调，**NP问题不是非P类问题**。NP问题是指可以在多项式的时间里**验证**一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。  \n比方说，我 RP 很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于 100 个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我 RP 很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度 98，比 100 小。于是答案出来了，存在比 100 小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比 100 小的解。  \n在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要 $O(n)$ 的时间复杂度，也就是说我可以花 $O(n)$ 的时间把我猜的路径的长度加出来。那么，只要我 RP 好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。  \n这就是 NP 问题。当然有不是 NP 问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。  \n下面要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的 Hamilton 回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在 Hamilton 回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有 Hamilton 回路”。\n\n### 为什么要定义 NP 问题\n之所以要定义 NP 问题，是因为通常只有 NP 问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“ NP 问题”，实际上是在探讨 NP 问题与 P 类问题的关系。\n\n### P 问题和 NP 问题的关系\n很显然，所有的 P 类问题都是 NP 问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的 NP 问题都是 P 类问题。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有 P=NP ？通常所谓的“ NP 问题”，其实就一句话：证明或推翻 P=NP。  \n\n目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP 不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的 NP 问题。人们如此坚信 P≠NP 是有原因的，就是在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也即所谓的 NP-Complete 问题。正是 NPC 问题的存在，使人们相信 P≠NP。下文将花大量篇幅介绍 NPC 问题，你从中可以体会到 NPC 问题使 P=NP 变得多么不可思议。\n\n## NPC 问题\n### 约化\n为了说明 NPC 问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。  \n简单地说，一个问题 A 可以约化为问题 B 的含义即是，可以用问题 B 的解法解决问题 A，或者说，问题 A 可以“变成”问题 B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。  \n“问题 A 可约化为问题 B”有一个重要的直观意义：**B 的时间复杂度高于或者等于 A 的时间复杂度**。也就是说，问题 A 不比问题 B 难。这很容易理解。既然问题 A 能用问题 B 来解决，倘若 B 的时间复杂度比 A 的时间复杂度还低了，那 A 的算法就可以改进为 B 的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。  \n很显然，约化具有一项重要的性质：约化具有传递性。如果问题 A 可约化为问题 B，问题 B 可约化为问题 C，则问题 A 一定可约化为问题 C。  \n\n现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序 A 的输入，都能按这个法则变换成程序 B 的输入，使两程序的输出相同，那么我们说，问题 A 可约化为问题 B。\n当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。\n\n 好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的 P 和 NP 问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小 NP 问题的一个稍复杂的大 NP 问题，那么**最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP 问题的这样一个超级 NP 问题？**答案居然是肯定的。  \n 也就是说，存在这样一个 NP 问题，所有的 NP 问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的 NP 问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的 NPC 问题，也就是 NP-完全问题。NPC 问题的出现使整个 NP 问题的研究得到了飞跃式的发展。我们有理由相信，NPC 问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于 NPC 问题”。\n\nNPC 问题的定义非常简单。同时满足下面两个条件的问题就是 NPC 问题：\n* 它得是一个 NP 问题；\n* 所有的 NP 问题都可以约化到它。\n\n证明一个问题是 NPC 问题也很简单：\n* 先证明它至少是一个NP问题；\n* 再证明其中一个已知的 NPC 问题能约化到它（由约化的传递性，则 NPC 问题定义的第二条也得以满足；至于第一个 NPC 问题（逻辑电路问题）是怎么来的，下文将介绍），这样就可以说它是 NPC 问题了。\n既然所有的 NP 问题都能约化成 NPC 问题，那么只要任意一个 NPC 问题找到了一个多项式的算法，那么所有的 NP 问题都能用这个算法解决了，NP 也就等于 P 了。因此，给 NPC 找一个多项式算法太不可思议了。因此，前文才说，“正是 NPC 问题的存在，使人们相信 P≠NP”。我们可以就此直观地理解，NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。\n\n## NP-Hard 问题\n顺便讲一下 NP-Hard 问题。NP-Hard 问题是这样一种问题，它满足 NPC 问题定义的第二条但不一定要满足第一条（就是说，NP-Hard 问题要比 NPC 问题的范围广）。  \nNP-Hard 问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为**它不一定是 NP 问题**。*即使 NPC 问题发现了多项式级的算法，NP-Hard 问题有可能仍然无法得到多项式级的算法*。事实上，由于 NP-Hard 放宽了限定条件，<u>它将有可能比所有的 NPC 问题的时间复杂度更高从而更难以解决</u>。\n\n## 逻辑电路问题\n不要以为 NPC 问题是一纸空谈。NPC 问题是存在的。确实有这么一个非常具体的问题属于 NPC 问题。下文即将介绍它。\n下文即将介绍逻辑电路问题。这是**第一个 NPC 问题**。其它的 NPC 问题都是由这个问题约化而来的。因此，逻辑电路问题是 NPC 类问题的“鼻祖”。\n\n逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。\n\n逻辑电路问题属于 NPC 问题。这是有严格证明的。它显然属于 NP 问题，并且可以直接证明所有的 NP 问题都可以约化到它（不要以为 NP 问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个 NP 问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0 和 1 的运算），因此对于一个 NP 问题来说，问题转化为了求出满足结果为 True 的一个输入（即一个可行解）。\n\n有了第一个 NPC 问题后，一大堆 NPC 问题就出现了，因为再证明一个新的 NPC 问题只需要将一个已知的 NPC 问题约化到它就行了。后来，Hamilton 回路成了 NPC 问题，TSP 问题也成了 NPC 问题。现在被证明是 NPC 问题的有很多，任何一个找到了多项式算法的话所有的 NP 问题都可以完美解决了。因此说，正是因为 NPC 问题的存在，P=NP 变得难以置信。P=NP 问题还有许多有趣的东西，有待大家自己进一步的挖掘。\n\n## 参考\n* [什么是P问题、NP问题和NPC问题](http://www.matrix67.com/blog/archives/105)'),(245,'Java 内部类',1,'2022-11-21 08:32:55',3,'之前关于 Java 的内部类的具体使用，以及外部类和内部类的数据互访的问题上总有一些模糊，这里对 CSDN 上写的比较好的一篇文章做一个简单的记录。Java 内部类可以分为 4 类：\n* 普通内部类\n* 静态内部类\n* 匿名内部类\n* 局部内部类\n\n## 普通内部类\n直接作为一个类的字段声明一个内部类。\n```java\npublic class OuterClass {\n\n    public class InnerClass {\n        \n    }\n}\n```\n在这种定义方式下，普通内部类对象依赖外部类对象而存在，即在创建一个普通内部类对象时 **首先需要创建其外部类对象** 。  \n这样生成的内部类对象就像是外部类对象的一个属性，可以访问外部类的所有属性。\n\n## 静态内部类\n静态内部类作为一个外部类的静态成员而存在，创建一个类的静态内部类对象 **不需要依赖其外部类对象** 。但同时，静态内部类中也无法访问外部类的 **非静态成员**。\n```java\npublic class OuterClass {\n\n    /**\n     * 静态内部类\n     */\n    static class InnerClass{\n        private int number;\n        public InnerClass(int num){\n            this.number = num;\n        }\n        public void print(){\n            System.out.println(\"num = \" + this.number);\n        }\n    }\n\n    public static void main(String[] args) {\n        new InnerClass(1).print();\n    }\n}\n```\n\n## 匿名内部类\n匿名内部类有多种形式，其中最常见的一种形式莫过于在方法参数中新建一个接口 / 类对象，并且实现这个接口 / 类中原有的方法了：\n```java\npublic class OuterClass {\n\n    public static void main(String[] args) {\n        Square[] list = new Square[3];\n        // 这里直接 new 一个接口并给出实现\n        Arrays.sort(list, new Comparator<Square>() {\n            @Override\n            public int compare(Square o1, Square o2) {\n                return 0;\n            }\n        });\n    }\n}\nclass Square {\n    double width;\n    double length;\n}\n```\n上面的代码中展示了常见的两种使用匿名内部类的情况：  \n1. 直接 new 一个接口，并实现这个接口声明的方法。  \n   在这个过程其实会 **创建一个匿名内部类** 实现这个接口，并重写接口声明的方法，然后再创建一个这个匿名内部类的对象并赋值给声明的对象。\n2. new 一个已经存在的类 / 抽象类，并且选择性的实现这个类中的一个或者多个非 final 的方法，这个过程会创建一个匿名内部类对象**继承对应的类 / 抽象类**，并且重写对应的方法。\n\n在匿名内部类中可以使用外部类的属性，但是外部类却不能使用匿名内部类中定义的属性，因为是匿名内部类，因此在外部类中无法获取这个类的类名，也就无法得到属性信息。\n\n## 局部内部类\n局部内部类使用的比较少，其**声明在一个方法体 / 一段代码块的内部**，而且不在定义类的定义域之内便无法使用，其提供的功能使用匿名内部类都可以实现，而本身匿名内部类可以写得比它更简洁，因此局部内部类用的比较少。\n```java\npublic class InnerClassTest {\n\n    public int field1 = 1;\n    protected int field2 = 2;\n    int field3 = 3;\n    private int field4 = 4;\n\n    public InnerClassTest() {\n        System.out.println(\"创建 \" + this.getClass().getSimpleName() + \" 对象\");\n    }\n    \n    private void localInnerClassTest() {\n	    // 局部内部类 A，只能在当前方法中使用\n        class A {\n	        // static int field = 1; // 编译错误！局部内部类中不能定义 static 字段\n            public A() {\n	            System.out.println(\"创建 \" + A.class.getSimpleName() + \" 对象\");\n                System.out.println(\"其外部类的 field1 字段的值为: \" + field1);\n                System.out.println(\"其外部类的 field2 字段的值为: \" + field2);\n                System.out.println(\"其外部类的 field3 字段的值为: \" + field3);\n                System.out.println(\"其外部类的 field4 字段的值为: \" + field4);\n            }\n        }\n        A a = new A();\n        if (true) {\n	        // 局部内部类 B，只能在当前代码块中使用\n            class B {\n                public B() {\n	                System.out.println(\"创建 \" + B.class.getSimpleName() + \" 对象\");\n                    System.out.println(\"其外部类的 field1 字段的值为: \" + field1);\n                    System.out.println(\"其外部类的 field2 字段的值为: \" + field2);\n                    System.out.println(\"其外部类的 field3 字段的值为: \" + field3);\n                    System.out.println(\"其外部类的 field4 字段的值为: \" + field4);\n                }\n            }\n            B b = new B();\n        }\n//        B b1 = new B(); // 编译错误！不在类 B 的定义域内，找不到类 B，\n    }\n\n    public static void main(String[] args) {\n        InnerClassTest outObj = new InnerClassTest();\n        outObj.localInnerClassTest();\n    }\n}\n```\n在局部内部类里面可以访问外部类对象的所有访问权限的字段，而外部类却不能访问局部内部类中定义的字段，因为局部内部类的定义只在其特定的方法体 / 代码块中有效，一旦出了这个定义域，那么其定义就失效了。\n\n## 内部类的嵌套\n内部类的嵌套，即内部类中再定义内部类，这个问题从内部类的分类角度去考虑比较合适：\n* 普通内部类：  \n  在这里我们可以把它看成一个外部类的普通成员方法，在其内部可以定义普通内部类（嵌套的普通内部类），但是无法定义 static 修饰的内部类，*就像你无法在成员方法中定义 static 类型的变量一样*，当然也可以定义匿名内部类和局部内部类；\n* 静态内部类：  \n  因为这个类独立于外部类对象而存在，我们完全可以将其拿出来，去掉修饰它的 static 关键字，他就是一个完整的类，因此在静态内部类内部可以定义普通内部类，也可以定义静态内部类，同时也可以定义 static 成员；\n* 匿名内部类：  \n  和普通内部类一样，定义的普通内部类只能在这个匿名内部类中使用，定义的局部内部类只能在对应定义域内使用；\n\n* 局部内部类：  \n  和匿名内部类一样，但是嵌套定义的内部类只能在对应定义域内使用。\n## 参考\n[CSDN：详解 Java 内部类](https://blog.csdn.net/Hacker_ZhiDian/article/details/82193100?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166901405816800182763306%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166901405816800182763306&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82193100-null-null.142^v66^control,201^v3^control_2,213^v2^t3_control2&utm_term=%E5%86%85%E9%83%A8%E7%B1%BB&spm=1018.2226.3001.4187)'),(246,'Git-reset 你需要知道的',1,'2022-11-22 04:54:17',40,'在工作中总是容易弄混 `reset` 和 `checkout` 各种用法的区别，《Pro Git》第 7.7 节对 `reset` 命令做了很详细的讲解，在这里做一个简单的学习记录。\n\n## Git 中的三棵树\n要更好地理解 `reset` 命令，需要先对如何通过管理“三棵树”来实现版本控制有所了解。\n\n|树|用途 |\n|--|----|\n|HEAD|上一次提交的快照，下一次提交的父结点|\n|Index|预期的下一次提交的快照|\n|Working Directory| 沙盒|\n\n简单来说就是 HEAD 指向提交历史中的最后一次提交，Index 可以理解为暂存区，`git add` 后会把工作区下的文件同步到暂存区，`git commit` 后会把暂存区的内容作为新的提交放入提交历史中，同时 HEAD 指向最新的提交。\n\n![理解三棵树](https://git-scm.com/book/en/v2/images/reset-start.png)\n\n## reset 如何操纵三棵树\n### Step 1: 移动 HEAD\n`reset` 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（`checkout` 所做的）；`reset` 移动 HEAD 指向的分支。  \n如果使用 `git reset --soft` 命令，那么操作将停止在这一步。\n![](https://git-scm.com/book/en/v2/images/reset-soft.png)\n\n### Step 2: 更新 Index\n第二步中，git 会将 HEAD 指向的内容同步到 Index，这样的操作等价于取消了暂存，使我们回到了 `add` 和 `merge` 之前。  \n如果使用 `git reset --mixed` 命令，那么操作将停止在这一步。这也是 `reset` 的默认效果。\n![](https://git-scm.com/book/en/v2/images/reset-mixed.png)\n\n### Step 3: 更新工作目录\n第三步就是让工作目录看起来像暂存区，使用 `git reset --hard` 命令才会进行这一步操作。需要注意 `--hard` 会让你丢失工作区的所有修改，确保在之前做好记录或 `stash` 你的工作。\n\n## 通过路径来 reset\n如果给 `reset` 命令制定了一个文件路径或文件集，如 `git reset file.txt` （其实是 `git reset --mixed HEAD file.txt` 的简写形式），`reset` 将会跳过 Step 1，并且将它的作用范围限定为指定的文件或文件集合。因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过 Index 和工作目录可以部分更新，所以重置会继续进行第 2、3 步。所以**本质上只是将 file.txt 从 HEAD 复制到索引中**。相当于 **取消暂存文件** 的实际效果。\n\n![](https://git-scm.com/book/en/v2/images/reset-path1.png)\n当然这个命令也可以用于让暂存区和任意提交同步，如 `git reset eb43bf file.txt`。\n\n## checkout 和 reset 之间的区别\n和 `reset` 一样，`checkout` 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n### 不带路径\n运行 `git checkout [branch]` 与运行 `git reset --hard [branch]` 非常相似，它会更新所有三棵树使其看起来像 `[branch]`，不过有两点重要的区别。\n1. 首先不同于 `reset --hard`，`checkout` 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有 还未修改过的 文件都会被更新。 而 `reset --hard` 则会不做检查就全面地替换所有东西。\n2. 第二个重要的区别是 `checkout` 如何更新 HEAD。 `reset` 会移动 HEAD 分支的指向，而 `checkout` 只会移动 HEAD 自身来指向另一个分支。\n   \n![](https://git-scm.com/book/en/v2/images/reset-checkout.png)\n\n### 带路径\n运行 `checkout` 的另一种方式就是指定一个文件路径，这会像 `reset` 一样不会移动 HEAD。 它就像 `git reset [branch] file` 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 `git reset --hard [branch] file`（如果 `reset` 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。\n\n此外，同 `git reset` 和 `git add` 一样，`checkout` 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n## 参考\n* https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86#_git_reset'),(247,'《一个叫欧维的男人决定去死》读后感',2,'2022-11-22 05:07:45',4,'那个叫欧维的固执男人终于如愿以偿了。\n\n那个固执的男人，一生倔强，用最粗俗的话，用沉默、固执和死板以及一颗表面坚如磐石实而柔软的内心走完了自己的最后时光。\n\n也许他并非完全如愿，如果他知道了葬礼上来了至少三百人，他一定会恨死，他真会。  \n那些都是他在生命最后时光中帮助过的人。\n\n任何人若要经历了欧维所经历的一切，十六岁父母双亡，一次次失去自己所爱之物之人，或许都会变得沉默孤僻。生活让他从小就饱受磨练，在我眼前浮现的，是一个结实得像一块石头一样，与人打交道更像石头一样的固执老头。他坚守着自己的“原则”，以近乎偏执的态度对待自己的生活，苛刻地遵守着自己的规则：他能为了一克朗与售货员争执不下，能坚持数十年如一日早起在社区“巡逻”，在昏倒从医院醒来后关心的第一件事是救护车有没有进入小区，因为“社区里禁止车辆通行”。  \n人们说他刻薄，他们也许是对的。当索雅这样一束光照进他的生活时，我也便能够理解为什么欧维决定结束自己的生命：妻子离世后，他就不再活着。他的生活非黑即白，而索雅是他的色彩，他的全部色彩。\n\n> 死亡是一桩奇怪的事情。人们终其一生都在假装它并不存在，尽管这是生\n命的最大动机之一。我们其中一些人有足够时间认识死亡，他们得以活得\n更努力、更执着、更壮烈。有些人却要等到它真正逼近时才意识到它的反\n义词有多美好。另一些人深受其困扰，\n在它宣布到来之前就早早地坐进等\n候室。我们害怕它，但我们更害怕它发生在身边的人身上。对死亡最大的\n恐惧，在于它与我们擦肩而过，留下我们独自一人。\n\n一切也都变得合理，他讨厌那些秉公办事、冷冰冰的白衬衫，当他失去了孩子、在他最爱的人悲痛欲绝时，他依旧用无言的守护与不公的生活较量。他不明白为什么上天要让他的一生经历这一切，他变得越来越固执，抨击他看不惯的一切。\n\n而他又是心口不一的，一个顽固到让人难以靠近的外表下，是一颗善良的心。他总是将自己帮助别人的原因归结到妻子一定会因为自己感到开心的借口上，总是嘴硬着带给身边的人自己默默的关心。这让我联想到了许多固执倔强的老一辈人。可经可怜的中国式家长，他们也许不善于表达自己的情感，但却以自己的沉默扛起了家庭，卑微地伟大着。\n\n欧维是幸运的，在绝望时，他遇到了身边那么多美好的、形形色色性格不一的人，让书中的社区一下充满了生气。好像总是很向往书中北欧这样热闹的邻里关系，更是十分佩服巴克曼有力的笔触，用一个个看似古怪又合理的比喻，让独特的人物形象跃然纸上，不一而足。网友说巴克曼总是很擅长书写这样温馨治愈的故事，也许会在之后看看《外婆的道歉信》和《焦虑的人》。\n\n> 爱上一个人就像搬进一座房子，开始你会爱上新的一切，陶醉于拥有它的每一个\n清晨，就好像害怕会有人突然冲进房门指出这是个错误，你根本不该住得那么好。但经年累月房子的外墙开始陈旧，木板七翘八裂，你会因为它本该完美的不完美而渐渐不再那么爱它。然后你渐渐谙熟所有的破绽和瑕疵。天冷的时候，如何避免钥匙卡在锁孔里;哪块地板踩上去的时候容易弯曲;怎么打开一扇橱^门又恰好可以不让它嘎吱作响。这些都是会赋予你归属感的小秘密。\n\n读完全书，温馨又治愈，这样深邃又简单的故事，让我愿意倾尽一切去爱身边的人。\n\n<img alt=\"20220801215758\" src=\"https://img.foril.space/20220801215758.png\" width=600px style=\"margin:10px auto; display: block;\"/>'),(248,'力扣刷题笔记（五）',1,'2022-11-28 12:34:15',0,'第五篇刷题笔记。\n\n\n## 剑指 Offer 56 - I. 数组中数字出现的次数\n### 题目　　\n一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n\n输入：nums = [1,2,10,4,1,4,3,3]\n输出：[2,10] 或 [10,2]\n\n### 思路：\n其他数字出现两次，只有两个数字出现一次，很自然地想到`两个相同的数字异或为0`，记两个数字为`a`和`b`，可以通过这个方法抵消两个相同数字，整个数组全部异或的结果就是两个只出现一次的数字异或的结果`a^b`，我们需要分别列出`a`和`b`，那么显然还缺乏一个信息。官方题解的思路是**分组异或**，理解后确实觉得很妙。  \n首先我们找到`a^b`最后一个1，也`a`和`b`最低位不同的数字。之后我们将这一位不同的数字单独异或，两组答案就分别是`a`和`b`了（相同的数字必在同一组）。\n```cpp\nclass Solution {\npublic:\n    vector<int> singleNumbers(vector<int>& nums) {\n        int ret = 0;\n        for(int num:nums){\n            ret^=num;\n        }\n        ret = ret^(ret&(ret-1));    //得到最后一位1的数\n        int a = 0, b = 0;\n        for(int num:nums){\n            if(ret&num){\n                a^=num;\n            }else{\n                b^=num;\n            }\n        }\n        return {a,b};\n    }\n};\n```\n\n## 133. 克隆图\n### 题目　　\n给你无向`连通`图中一个节点的引用，请你返回该图的`深拷贝`（克隆）。\n\n### 思路：\n#### 方法一：DFS\n对于本题而言，我们需要明确图的深拷贝是在做什么，对于一张图而言，它的深拷贝即构建一张与原图结构，值均一样的图，但是其中的节点不再是原来图节点的引用。因此，为了深拷贝出整张图，我们需要知道整张图的结构以及对应节点的值。　　\n由于题目只给了我们一个节点的引用，因此为了知道整张图的结构以及对应节点的值，我们需要从给定的节点出发，进行**图的遍历**，并在遍历的过程中完成图的深拷贝。  \n\n为了防止多次遍历同一个节点，陷入死循环，我们需要用一种数据结构记录已经被克隆过的节点。  \n从给定节点开始遍历图。如果某个节点已经被访问过，则返回其克隆图中的对应节点。  \n\n\n如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。**注意**：在进入递归之前，必须先创建克隆节点并保存在哈希表中。***如果不保证这种顺序，可能会在递归中再次遇到同一个节点，再次遍历该节点时，陷入死循环。***\n\n```cpp\nclass Solution {\npublic:\n    unordered_map<Node*, Node*> visited;\n    Node* cloneGraph(Node* node) {\n        if (node == nullptr) {\n            return node;\n        }\n\n        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回\n        if (visited.find(node) != visited.end()) {\n            return visited[node];\n        }\n\n        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表\n        Node* cloneNode = new Node(node->val);\n        // 哈希表存储\n        visited[node] = cloneNode;\n\n        // 遍历该节点的邻居并更新克隆节点的邻居列表\n        for (auto& neighbor: node->neighbors) {\n            cloneNode->neighbors.emplace_back(cloneGraph(neighbor));\n        }\n        return cloneNode;\n    }\n};\n```\n\n#### 方法二：BFS\n要使用BFS，需要使用一个队列，保存接下来需要访问的节点，注意队列中每次取出的节点一定会给他加上所有的邻居（访问过的直接加入，没有的递归加入）。\n```cpp\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        if (node == nullptr) {\n            return node;\n        }\n\n        unordered_map<Node*, Node*> visited;\n\n        // 将题目给定的节点添加到队列\n        queue<Node*> Q;\n        Q.push(node);\n        // 克隆第一个节点并存储到哈希表中\n        visited[node] = new Node(node->val);\n\n        // 广度优先搜索\n        while (!Q.empty()) {\n            // 取出队列的头节点\n            auto n = Q.front();\n            Q.pop();\n            // 遍历该节点的邻居\n            for (auto& neighbor: n->neighbors) {\n                if (visited.find(neighbor) == visited.end()) {\n                    // 如果没有被访问过，就克隆并存储在哈希表中\n                    visited[neighbor] = new Node(neighbor->val);\n                    // 将邻居节点加入队列中\n                    Q.push(neighbor);\n                }\n                // 更新当前节点的邻居列表\n                visited[n]->neighbors.emplace_back(visited[neighbor]);\n            }\n        }\n\n        return visited[node];\n    }\n};\n```\n\n## 102. 二叉树的层序遍历\n### 题目　　\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n示例：\n二叉树：[3,9,20,null,null,15,7],\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n返回其层序遍历结果：\n```\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\n### 思路：\n这个题如果不要求层序，直接使用一个队列输出即可，但是他要求按照层序组织成不同数组，那么我们需要保存每一层的数量，最初我的想法是保存当前层和下一层的数量，当前层每有一个孩子，下一层数量加一，当前层数量减为零时，开始遍历下一层，下一层数量作为当前层数量，下一层数量清零。  \n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(!root) return {};\n        int currNum=1, nextNum=0;\n        queue<TreeNode*> que;\n        que.push(root);\n        vector<vector<int>> res;\n        vector<int> once;\n        while(!que.empty()||once.size()){\n            if(currNum--){\n                TreeNode* cur = que.front();\n                que.pop();\n                once.push_back(cur->val);\n                if(cur->left){\n                    nextNum++;\n                    que.push(cur->left);\n                }\n                if(cur->right){\n                    nextNum++;\n                    que.push(cur->right);\n                }\n            }else{\n                res.push_back(once);\n                once.clear();\n                currNum=nextNum;\n                nextNum = 0;\n            }\n        }\n        return res;\n    }\n};\n```\n看官方题解意识到其实每一层遍历结束时队列中剩余的节点数量，就是下一层的数量，只需要维护一个当前层的数量即可。  \n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector <vector <int>> ret;\n        if (!root) {\n            return ret;\n        }\n\n        queue <TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            int currentLevelSize = q.size();    //遍历完一层时队列剩余的数量就是下一层的数量\n            ret.push_back(vector <int> ());\n            for (int i = 1; i <= currentLevelSize; ++i) {\n                auto node = q.front(); q.pop();\n                ret.back().push_back(node->val);\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n        }\n        \n        return ret;\n    }\n};\n```\n\n## 105. 从前序与中序遍历序列构造二叉树\n### 题目　　\n给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。\n\n Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  \nOutput: [3,9,20,null,null,15,7]\n\n### 思路\n可以使用分治的思想，把问题分解。其实这种问题自己手做的方法也就是类似一个分解的过程，分治也就是模拟了手做这种题目的过程。非常容易出错的十是各种各样的边界问题，一不小心就容易写错、越界。  \n```cpp\nclass Solution {\npublic:\n	TreeNode* my_buildTree(vector<int>& preorder, vector<int>& inorder, int pre_s, int pre_e, int in_s, int in_e) {\n		if (pre_e - pre_s < 0) return nullptr;\n		if (pre_e - pre_s == 0) return new TreeNode(preorder[pre_s]);\n		int root_num = preorder[pre_s];\n		int index = find(inorder.begin() + in_s, inorder.begin() + in_e, root_num) - inorder.begin();\n		int left_size = index - in_s;\n		int right_size = in_e - index;\n		TreeNode * left = my_buildTree(preorder, inorder, pre_s + 1, pre_s + left_size, in_s, in_s + left_size - 1);\n		TreeNode * right = my_buildTree(preorder, inorder, pre_s + left_size + 1, pre_e, index + 1, in_e);\n		return new TreeNode(root_num, left, right);\n	}\n	TreeNode * buildTree(vector<int> & preorder, vector<int> & inorder) {\n		return my_buildTree(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);\n	}\n};\n```\n\n## 761. 特殊的二进制序列\n### 题目\n特殊的二进制序列是具有以下两个性质的二进制序列：\n\n* 0 的数量与 1 的数量相等。\n* 二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。\n   \n给定一个特殊的二进制序列 S，以字符串形式表示。定义一个 *操作* 为首先选择 S 的两个**连续且非空的特殊的**子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)\n\n在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？\n\n**示例 1:**  \n输入: S = \"11011000\"  \n输出: \"11100100\"  \n解释:  \n将子串 \"10\" （在S[1]出现） 和 \"1100\" （在S[3]出现）进行交换。\n这是在进行若干次操作后按字典序排列最大的结果。\n\n说明:  \n1. S 的长度不超过 50。\n2. S 保证为一个满足上述定义的特殊 的二进制序列。\n\n题解来自力扣[官方题解](https://leetcode.cn/problems/special-binary-string/solution/te-shu-de-er-jin-zhi-xu-lie-by-leetcode-sb7ry/)\n\n### 思路：分治\n#### 前言\n对于本题而言，将 $1$ 看成左括号 ‘(’，$0$ 看成右括号 ‘)’，那么一个特殊的二进制序列就可以看成一个合法的括号序列。（这样就很好理解）这种「映射」有助于理解题目中的操作，即交换两个相邻且非空的合法括号序列。但为了与题目保持一致，下面的部分仍然使用 1/0 进行叙述。\n\n这个题目关键的是抓住特殊序列的性质：对于一个特殊的二进制序列，其\n* 要么不能拆分，作为一个完整的特殊序列，要么可以拆分成几段连续的特殊序列；\n* 它一定以 1 开始，以 0 结束。\n\n如果题目给定的字符串是一个不可再拆分的特殊序列，也就是说，它无法完整地拆分成多个特殊序列，那么它的首位 1 和末位 0 是不可能在任何交换操作中出现的。证明见[官方题解](https://leetcode.cn/problems/special-binary-string/solution/te-shu-de-er-jin-zhi-xu-lie-by-leetcode-sb7ry/)。 因此，我们可以将开头的 1 和结尾的 0 拆去后考虑中间的部分（不可拆分的序列任意前缀一定 1 的数量多于 0 的数量，去头去尾后中间的部分一定也是一个特殊序列，我们递归考虑这个去头去尾的子字符串可以拆分与不可拆分两种情况即可递归完成整个字符串的拆分）。  \n如果给定的是一个可拆分的特殊序列，那么整个序列都可拆分为极端连续的特殊序列，将其拆分为多端子序列。\n\n对于拆分出的子序列，我们利用字典序将其排序，排序后拼接即是交换后可得到的最大序列结果。\n```java\nclass Solution {\n    public static String makeLargestSpecial(String s) {\n        // 对于一个特殊二进制序列，要么整体是二进制特殊序列，要么可以拆分为多个最小二进制特殊序列\n        if(s.length()<=2) return s;\n\n        List<String> subs = new ArrayList<>();\n        int count = 0, left = 0;\n        for(int i = 0; i<s.length();i++){\n            if(s.charAt(i)==\'1\'){\n                count++;\n            }else{\n                count--;\n                if(count==0){   // 碰到一个特殊前缀\n                    // 去掉1和0将问题转化为子问题\n                    subs.add(\"1\"+makeLargestSpecial(s.substring(left+1, i))+\"0\");\n                    left=i+1;\n                }\n            }\n        }\n        subs.sort((a, b)->{\n            return b.compareTo(a);\n        });\n        StringBuilder builder = new StringBuilder();\n        for(String sub: subs){\n            builder.append(sub);\n        }\n        return builder.toString();\n    }\n\n}\n```\n\n\n## 827. 最大人工岛\n### 题目\n给你一个大小为 $n \\times n$ 二进制矩阵 `grid` 。最多只能将一格 0 变成 1 。\n\n返回执行此操作后，grid 中最大的岛屿面积是多少？\n\n岛屿 由一组上、下、左、右四个方向相连的 1 形成。\n\n### 思路\n容易想到利用「并查集」来维护不同的连接分量，我们将二维数组展平来利用并查集，首先完成并查集的基本操作：初始化、查询、合并，注意可以用一个 `size` 数组来维护不同分量的面积大小（只有访问帮助节点才有意义）。  \n在遍历过整个 `grid` 后，已经将同一个连通分量维护起来了，接着我们需要再次遍历 `grid`，将其中潜在的翻转点（值为0）上下左右四个位置的连通分量面积和加起来（如果多个方向上是同一个连通分量只计算一次，可以用set实现），记录遍历过程的最大值即是答案。\n```java\nclass Solution {\n    int n;\n    int[] p;\n    int[] size;\n    int[][] dirs = new int[][]{{0,1}, {0,-1}, {-1,0}, {1,0}};\n\n    private int find(int a){\n        if(p[a] == a) return a;\n        return p[a] = find(p[a]);    // 压缩路径\n    }\n    private void merge(int a, int b){\n        int pa = find(a); int pb = find(b);\n        if(pa == pb) return;\n        if(size[pa] <= size[pb]){\n            p[pa] = pb;\n            size[pb] += size[pa];\n        }else{\n            merge(b, a);\n        }\n    }\n\n    public int largestIsland(int[][] grid) {\n        this.n = grid.length;\n        // init \n        p = new int[n*n];   size = new int[n*n];\n        for(int i = 0; i < n*n; i++){\n            p[i] = i;\n        }\n        Arrays.fill(size,1);\n        \n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                // 遍历\n                if(grid[i][j]==1){\n                    for(int[] dir: dirs){ // 四个方向\n                        int x = i+dir[0]; int y = j+ dir[1];\n                        if(x<0 || x==n || y<0 || y==n || grid[x][y]==0) continue;\n                        merge(x*n + y, i*n + j);\n                    }\n                }\n            }\n        }\n        \n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j]==1){\n                    res = Math.max(res, size[find(i*n + j)]);\n                }else{\n                    // 候选翻转点\n                    int area = 1;\n                    Set<Integer> seen = new HashSet<>();\n                    for(int[] dir: dirs){ // 四个方向\n                        int x = i + dir[0]; int y = j + dir[1];\n                        if(x<0 || x==n || y<0 || y==n || grid[x][y]==0) continue;\n                        int root = find(x*n + y);\n                        if(seen.contains(root)) continue;\n                        seen.add(root);\n                        area += size[root];\n                    }\n                    res = Math.max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n## 750. Pow(x, n)\n### 题目\n实现 `pow(x, n)` ，即计算 `x` 的整数 `n` 次幂函数（即，$x^n$ ）\n\n### 思路\n直接使用 $O(n)$ 的暴力算法会超时，考虑降低时间复杂度，最直接的思路就是找到 $O(logn)$ 的算法，自然就想到了二分。\n\n我们将幂运算化解成两个子幂相乘，如：\n$$\nx^{78} \\rightarrow x^{39} \\rightarrow x^{19} \\rightarrow x^{9} \\rightarrow x^{4} \\rightarrow xA^{2} \\rightarrow x^{1}\n$$\n对于负数次幂，只需要将运算结果放在分母上，将 `n` 转化为 `-n` 即可。\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        long N = n;\n        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n\n    public double quickMul(double x, long N) {\n        // 注意题目中 n 为 int，这里用 N 接收，防止 Integer.MIN_VALUE乘-1后向上溢出\n        if (N == 0) {\n            return 1.0;\n        }\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    }\n}\n```'),(249,'快速判断素数',1,'2022-11-28 12:34:57',2,'当给定一个数字 $n$ 时，我们如何能够快速判断这个数字是否是一个素数呢？  \n\n最朴素的方式当然是将小于 $n$ 且大于等于 $2$ 的所有数字除 $n$，若余数全部为 $0$，则说明是素数。但这样的方法时间复杂度在 $O(n)$，以下对算法进行改进。\n\n## 改进一：修改除数范围\n这里的一个关键观察在于：如果一个数字可以进行因数分解，那么一定有一个数字小于等于 $\\sqrt{n}$，而另一个数大于等于 $\\sqrt{n}$，带着这个观察，我们可以把遍历的范围改为 $[2, \\sqrt{n}]$，得到一个时间复杂度为 $O(\\sqrt{n})$ 的算法。\n```java\nboolean prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```\n\n## 改进二：缩小检查范围\n这里的关键观察来源于：大于等于 $5$ 的质数一定和 $6$ 的倍数相邻。  \n证明如下：  \n令 $x \\geq 1$；  则大于等于5的自然数表示如下：\n$$\n...,6x−1,6x,6x+1,6x+2,6x+3,6x+4,...\n$$\n可以看到，不在6的倍数两侧的数：$6x,2(3x+1),3(2x+1),2(3x+2)$ 都不是素数。  \n可能为素数的就只有：$6x−1$ 和 $6x+1$。\n\n因此，得到一个数字 $n$ 后，我门首先判断他是否和 $6$ 的倍数相邻，如果是，继续检查，否则直接判定为非素数。\n```java\nboolean prime(int n) {\n    if (n == 2 || n == 3) {\n        return true;\n    }\n    if (n % 6 != 1 && n % 6 != 5) {\n        return false;\n    }\n    for (int i = 5; i <= Math.floor(Math.sqrt(n)); i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```'),(250,'LaTeX',1,'2022-11-28 12:36:15',3,'## What is Latex\n不同于像 Word 这样的所见即所得的文本编辑器，latex 文档是一个包括诸多 latex 命令的纯文本，之后送进 *TeX engine* 输出 PDF 文档。\n\n## 下载配置 latex\n关于这部分我目前还有很多疑问，尤其是关于不同 tools 生成的文件类型和在 VS Code 中的配置内容，每次编译 latex 后会在目录下生成一堆杂七杂八的东西还不甚了解，打算之后慢慢研究，这里附上我采用的一篇在 Mac 上安装 Latex 以及配置 VS Code 的[文章](https://zhuanlan.zhihu.com/p/165411114)\n\n## 从文档来学 latex\n```latex\n\\documentclass{article}\n\\usepackage[UTF8, scheme = plain]{ctex}\n\\begin{document}\n测试中文sdfasd\n\\end{document}\n```\n第一行 `\\documentclass{article}` 声明了文档类型（class），不同的文档类型（简历、书、报告）可能会用到不同的 class（如 report/book 等）。  \n文章的正文在 `\\begin{document}` 和 `\\end{document}` 之间，\n\n## Preamble\n在文章正文之前的内容都叫做 preamble，用来作为文档的 “setup”。  \n在 preamble 中你可以：\n* 定义文档的 class 以及编写文档时要使用的语言等细节；\n* 加载您想要使用的包；\n* 应用其他类型配置。\n\n一个最简单的 preamble 如图所示\n```latex\n\\documentclass[12pt, letterpaper]{article}\n\\usepackage{graphicx}\n```\n方括号中的是对于这个 article 实例的参数，在这个例子中\n* 12pt 设置了字体大小（默认10pt）\n* letterpaper 设置纸张大小（[其他选项](https://www.overleaf.com/learn/latex/Page_size_and_margins) 如 a4paper/legalpaper）\n\n```latex\n\\usepackage{graphicx}\n```\n是加载一个外部包(这里是 graphicx )以扩展 LATEX 的功能，使其能够导入外部图形文件的示例。更多关于包的讨论见 [这里](https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes#Finding_and_using_LaTeX_packages)。\n\n## 标题、作者和日期信息\n在 preamble 中多加三行\n```latex\n\\title{My first LaTeX document}\n\\author{Hubert Farnsworth\\thanks{Funded by the Overleaf team.}}\n\\date{August 2022}\n```\n之后为了排版标题内容，只需要在 **正文** 中加入\n```latex\n\\maketitle\n```\n## 注释\nLatex 作为一种负责排版的编程语言，也有自己的注释，在行前加入 `%` 便可以注释整行代码。\n\n## 粗体 斜体 下划线\n* 粗体： `\\textbf{...}` \n* 泄题: `\\textit{...}`\n* 下划线：`\\underline{...}`\n\n## 加入图片\n如下命令可在文档中加入图片。\n```latex\n\\documentclass{article}\n\\usepackage{graphicx} % 导入图片的库\n\\graphicspath{{images/}} %configuring the graphicx package\n \n\\begin{document}\nThe universe is immense and it seems to be homogeneous, \non a large scale, everywhere we look.\n\n% The \\includegraphcs command is \n% provided (implemented) by the \n% graphicx package\n\\includegraphics[width=0.75\\textwidth]{universe}\n\n \nThere\'s a picture of a galaxy above.\n\\end{document}\n```\n\n## 图例、标签和参考\n```latex\n\\begin{document}\n\\maketitle\n测试中文sdfasdasdf\n\n% 这里的图片和下面的列表都需要在一个 \\begin 环境中\n\\begin{figure}[h]\n    \\centering\n    \\includegraphics[width=0.75\\textwidth]{test}\n    \\caption{A nice plot.} % 这里是图名\n    \\label{fig:anyName} % 这里是标签内容，会自动分配图号以及引用的图号\n\\end{figure}\n\nAs you can see in figure \\ref{fig:anyName}, the function grows near the origin. This example is on page \\pageref{fig:anyName}.\n\\end{document}\n```\n## 列表\n```latex\n% 无序列表\n\\begin{itemize}\n    \\item The individual entries are indicated with a black dot, a so-called bullet.\n    \\item The text in the entries may be of any length.\n\\end{itemize}\n\n% 有序列表\n\\begin{enumerate}\n    \\item This is the first entry in our list.\n    \\item The list numbers increase with each entry we add.\n\\end{enumerate}\n```\n\n## 加入公式\n### 行内公式\n`\\( ... \\)`、 `$ ... $` 或 `\\begin{math} ... \\end{math}` 都可以表示行内公式。\n### 展示模式\n`\\[ ... \\]`、 `\\begin{displaymath} ... \\end{displaymath}` 或 ``\\begin{equation} ... \\end{equation}`都可以使用展示模式展示公式。之前，`$$ ... display math here ...$$` 也可以展示公式，但已不再被推荐。\n```latex\n\\documentclass[12pt, letterpaper]{article}\n\\begin{document}\nThe mass-energy equivalence is described by the famous equation\n\\[ E=mc^2 \\] discovered in 1905 by Albert Einstein. \n\nIn natural units ($c = 1$), the formula expresses the identity\n\\begin{equation}\nE=m\n\\end{equation}\n\\end{document}\n```\n\n\n\n## 基本文档结构\n### Abstracts\n学术论文通常都要写摘要：\n```latex\n\\documentclass{article}\n\\begin{document}\n\\begin{abstract} % 摘要\nThis is a simple paragraph at the beginning of the \ndocument. A brief introduction about the main subject.\n\\end{abstract}\n\\end{document}\n```\n\n### 段落和换行\n* 两次 `回车` 结束此段落并开始下一段落。\n* 使用 `\\\\` 或 `\\newline` 手动加入断行但不开始下一个段落（定格开始下一行）。\n\n```latex\n\\documentclass{article}\n\\begin{document}\n\n\\begin{abstract}\nThis is a simple paragraph at the beginning of the \ndocument. A brief introduction about the main subject.\n\\end{abstract}\n\nAfter our abstract we can begin the first paragraph, then press ``enter\'\' twice to start the second one.\n\nThis line will start a second paragraph.\n\nI will start the third paragraph and then add \\\\ a manual line break which causes this text to start on a new line but remains part of the same paragraph. Alternatively, I can use the \\verb|\\newline|\\newline command to start a new line, which is also part of the same paragraph.\n\\end{document}\n```\n\n## Chapters and sections\nLaTeX 还提供文档结构命令，但是可用的命令及其实现（它们做什么）可以依赖于所使用的文档类。举例来说，使用 book 类创建的文档可以分为部分、章节、节、子节等等，但是 letter 类不提供任何命令来实现这一点。\n```latex\n\\documentclass{book}\n\\begin{document}\n\n\\chapter{First Chapter}\n\n\\section{Introduction}\n\nThis is the first section.\n\nLorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  \nelit. Etiam  lobortisfacilisis sem.  Nullam nec mi et \nneque pharetra sollicitudin.  Praesent imperdietmi nec ante. \nDonec ullamcorper, felis non sodales...\n\n\\section{Second Section}\n\nLorem ipsum dolor sit amet, consectetuer adipiscing elit.  \nEtiam lobortis facilisissem.  Nullam nec mi et neque pharetra \nsollicitudin.  Praesent imperdiet mi necante...\n\n\\subsection{First Subsection}\nPraesent imperdietmi nec ante. Donec ullamcorper, felis non sodales...\n\n\\section*{Unnumbered Section}\nLorem ipsum dolor sit amet, consectetuer adipiscing elit.  \nEtiam lobortis facilisissem...\n\\end{document}\n```\n常用命令：\n* \\part{part}\n* \\chapter{chapter}\n* \\section{section}\n* \\subsection{subsection}\n* \\subsubsection{subsubsection}\n* \\paragraph{paragraph}\n* \\subparagraph{subparagraph}\n\n每个标签开头的数字标号都是自动的，可以使用 `*` 如 `\\section*{}` 来禁用自动编号。  \n> 注意，`\\part` 和 `\\chapter` 命令只在 report 和 book 类中可用。\n\n## 表格\n### 一个基本表格\n```latex\n\\begin{center}\n\\begin{tabular}{c c c} % c 表示居中 l/r 表示居左或居右，三个 c 表示每行三列\n cell1 & cell2 & cell3 \\\\ % & 表示一个的结束， \\\\ 换行\n cell4 & cell5 & cell6 \\\\  \n cell7 & cell8 & cell9    \n\\end{tabular}\n\\end{center}\n```\n\n### 边框\n在 tabular 参数中加入 `|` 表示竖直线，`\\hline` 表示水平线，两个 `hline` 表示双线/\n```latex\n\\begin{center}\n\\begin{tabular}{|c|c|c|} \n \\hline\n cell1 & cell2 & cell3 \\\\ \n \\hline\\hline\n cell4 & cell5 & cell6 \\\\ \n cell7 & cell8 & cell9 \\\\ \n \\hline\n\\end{tabular}\n\\end{center}\n```\n\n### 表名\n和 `\\begin{figure}` 类似，只不过换用 `\\begin{table}`。\n```latex\nTable \\ref{table:data} shows how to add a table caption and reference a table.\n\\begin{table}[h!]\n\\centering\n\\begin{tabular}{||c c c c||} \n \\hline\n Col1 & Col2 & Col2 & Col3 \\\\ [0.5ex] \n \\hline\\hline\n 1 & 6 & 87837 & 787 \\\\ \n 2 & 7 & 78 & 5415 \\\\\n 3 & 545 & 778 & 7507 \\\\\n 4 & 545 & 18744 & 7560 \\\\\n 5 & 88 & 788 & 6344 \\\\ [1ex] \n \\hline\n\\end{tabular}\n\\caption{Table to test captions and labels.}\n\\label{table:data}\n\\end{table}\n```');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `articlecate`
--

DROP TABLE IF EXISTS `articlecate`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `articlecate` (
  `cateID` int NOT NULL AUTO_INCREMENT,
  `cateName` varchar(255) NOT NULL,
  PRIMARY KEY (`cateID`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articlecate`
--

LOCK TABLES `articlecate` WRITE;
/*!40000 ALTER TABLE `articlecate` DISABLE KEYS */;
INSERT INTO `articlecate` VALUES (1,'学习笔记'),(2,'随笔而写'),(3,'力扣专题笔记');
/*!40000 ALTER TABLE `articlecate` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user` (
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES ('foril','WCX990824wcx'),('wrf','wangruifeng0001');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-11-28 12:46:16
