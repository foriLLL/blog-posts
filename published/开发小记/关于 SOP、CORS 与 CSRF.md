---
description: 本文主要介绍了浏览器的同源策略（SOP）、跨域资源共享（CORS）以及跨站请求伪造（CSRF）攻击。三者关系密切，是前端开发中必须了解的内容。
time: 2024-03-16T10:48:43+08:00
tags: 
heroImage: 
---

## 同源策略 (SOP)

谈及 CORS 之前，必须先了解浏览器的同源策略（SOP）。同源策略是浏览器的核心安全功能，其主要目的是阻止来自一个源（如 `a.com`）的脚本读取对另一个源（如 `b.com`）发出的 HTTP 请求的响应。这项策略旨在提高网站的安全性，减少跨站脚本（XSS）等安全风险，例如阻止恶意脚本窃取用户的 cookies。

如果 `b.com` 的服务器收到来自 `a.com` 的请求（请求的 `Origin` 头为 `a.com`）并且不允许 `a.com` 的跨域请求，那么它的响应中将不会包含 `Access-Control-Allow-Origin` 头，或者这个头的值不匹配请求的源。浏览器将拒绝访问这个响应，并显示一个跨域错误。

**重要的是要理解，这并不意味着服务器 「拒绝」 了请求；实际上，服务器已经处理并响应了请求，只是浏览器出于安全考虑，阻止了脚本访问这些数据。**

> 浏览器会有一个 「预检请求」，即在发送真正的请求之前，先发送一个 OPTIONS 请求，以确定服务器是否允许跨域请求。这个请求中会包含一个 `Access-Control-Request-Method` 头，用于告知服务器真正请求的方法。服务器收到这个请求后，如果允许跨域请求，会在响应中包含 `Access-Control-Allow-Methods` 头，告知浏览器允许的跨域请求方法。

## CORS

CORS 是一种策略，允许网站绕过 SOP 的限制，但前提是得到服务器的明确允许。当从 `a.com` 向 `b.com` 发送 AJAX 请求时，浏览器会自动在 HTTP 头信息中添加 `Origin` 头，其值为请求发起的源（即 `a.com`）。如果 `b.com` 的服务器配置为允许来自 `a.com` 的请求，它将在响应中包含 `Access-Control-Allow-Origin` 头，其值设置为 `a.com` 或通配符 `*`，表示接受任何域的请求。这样，浏览器就可以正常处理响应了。如果 `b.com` 不允许来自 `a.com` 的请求，浏览器将拒绝访问响应，并显示跨域错误。

### 跨域解决方案

#### 代理

通过在服务器端设置代理，可以绕过 SOP 限制。这个代理会向其他域的资源发起请求，并在响应中将 `Access-Control-Allow-Origin` 设置为 `*`，再返回给浏览器，从而允许浏览器访问这个响应。

代理服务器部署的好处包括：
- **集中处理跨域请求**：方便跨域请求的策略和安全设置的维护更新。
- **安全性**：可以在服务器端进行额外的安全检查和日志记录。
- **性能**：通过实现缓存策略，提高响应速度。

#### 设置 CORS 头

服务器端通过设置 CORS 响应头允许跨域请求，是最推荐的解决方案。例如：

```javascript
// 允许来自特定域的跨域请求
res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');
// 允许跨域请求携带的头
res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
// 允许的跨域请求方法
res.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
```

#### JSONP

JSONP 是一项比较老的技术，是利用 `<script>` 标签 `src` 属性的无跨域限制特性，通过动态创建 `<script>` 标签请求 JSON 数据的技术。服务器返回的数据作为回调函数的参数，客户端通过定义回调函数处理返回的数据。

## CSRF

尽管 SOP 提供了强大的安全保护，但它并不能完全防止跨站攻击，特别是 **跨站请求伪造（CSRF）**。CSRF 攻击主要通过利用网站的认证机制，**在用户不知情的情况下代表用户发起请求**。

### 为什么 SOP 不能阻止 CSRF

SOP 限制了不同源的网站访问或修改彼此的数据，但并未阻止向其他源发送携带用户凭证（如 cookies）的请求。因此，恶意网站可以诱导用户的浏览器向目标网站发送请求，目标网站可能误认为这些请求是用户自愿发起的。

> 简单来说就是 SOP 虽然阻止了 `a.com` 直接访问 `b.com` 的响应内容，但是并没有阻止 `a.com` 向 `b.com` 发送请求。因此，如果用户已经在 `b.com` 登录，浏览器会自动携带 `b.com` 的 cookie 随请求发送，因为 cookie 是自动随每个请求发送到对应域名的，而这恰恰是 CSRF 攻击所利用的。

### 防御 CSRF 攻击

为了防御 CSRF 攻击，需要在应用层面采取措施，例如：

- 使用 `Anti-CSRF Token`：服务器向客户端提供一个唯一的、随机的 token，该 token 不会被第三方网站知道。客户端每次提交请求时都需要包含这个 token，服务器验证 token 的有效性。因为恶意网站无法获取这个 token，所以这种方法可以有效防止 CSRF 攻击。
- `SameSite` cookie 属性：设置 cookie 的 `SameSite` 属性可以限制 cookie 随跨站请求发送。例如，设置为 `Strict` 或 `Lax`，可以减少 CSRF 攻击的风险。
- 验证 `Referer` 和 `Origin` 头部：通过验证 HTTP 请求的 `Referer` 或 `Origin` 头部信息，来确保请求是从受信任的源发起的。
- 使用自定义 HTTP 头：自定义的 HTTP 头部不会随浏览器自动发送，因此可以作为检测非法站点请求的手段。

简单总结就是在浏览器自动发送请求携带的内容里加入一些额外的验证信息，这样就不会因为浏览v器自动携带对于域的 cookie 而导致 CSRF 攻击。
