---
description: Trie树，即字典树，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。
time: 2023-11-04T20:45:29+08:00
tags: 
heroImage: https://img.foril.fun/字典树.png
---

字典树，顾名思义，就是一个像字典一样的树。

<img alt="字典树" src="https://img.foril.fun/字典树.png" width=400px style="display: block; margin:10px auto"/>

Trie 的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

> Trie 树实际上是一个确定有限状态自动机(DFA)，通常用转移矩阵表示。行表示状态，列表示输入字符，（行，列）位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。也可以采用压缩的存储方式（即链表）来表示状态转移，但由于要线性查询，会造成效率低下。

### 基本性质

前缀树的 3 个基本性质：

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符都不相同。

## Trie 树的实现

实现字典树，需要定义如何插入新的字符串以及如何查找字符串。

### 实现一：

字典树的第一种实现方式是利用一个类或结构体，每个节点需要记录下一个转移的所有可能的字符，以及是否是一个单词的结尾。

```cpp
class Trie {
private:
    vector<Trie*> children;
    bool isEnd;

public:
    Trie() : children(26), isEnd(false) {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;
    }

    bool search(string word) {
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                return nullptr;
            }
            node = node->children[ch];
        }
        return node != nullptr && node->isEnd;
    }
};
```

### 实现二：

Trie 树的第二种实现方案，是利用一个二维数组，数组的每一行表示一个节点，每一列表示一个转移，如果某个节点有一个转移，那么就在对应的列上标记为下一个节点的编号，如果没有转移，就标记为 0。

```cpp
struct trie {
  int nex[100000][26], cnt;
  bool exist[100000];  // 该结点结尾的字符串是否存在

  void insert(char *s, int l) {  // 插入字符串
    int p = 0;
    for (int i = 0; i < l; i++) {
      int c = s[i] - 'a';
      if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点
      p = nex[p][c];
    }
    exist[p] = 1;
  }

  bool find(char *s, int l) {  // 查找字符串
    int p = 0;
    for (int i = 0; i < l; i++) {
      int c = s[i] - 'a';
      if (!nex[p][c]) return 0;
      p = nex[p][c];
    }
    return exist[p];
  }
};
```

## Trie 树的应用

字典树的常见应用包括 **检索字符串**（查找一个字符串是否在「字典」中出现过）、**维护异或极值**（在一组数中，找出与给定数异或值最大的数）以及 **维护异或和**（在一组数中，找出与给定数异或值最小的数）等，也可以用在自动补全、拼写检查、IP 路由等领域。

## 参考

* [Wiki](https://zh.wikipedia.org/wiki/Trie)
* [知乎：数据结构与算法：字典树（前缀树）](https://zhuanlan.zhihu.com/p/28891541)
* [OI Wiki](https://oi-wiki.org/string/trie/)