回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  

这里列出我接触的两个利用了典型的回溯思想解决的问题：
* [96. 不同的二叉搜索树II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)　　
* [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

## 个人简单总结

从这两个题中我个人感觉到的规律就是这类问题 ***相较于原问题是一个序列长度缩小的子问题，因此可以用回溯的方法来解决。*** 通过将一个根问题化解为若干个规模变小的子问题，便可以使用递归解决问题。  
在 **递归函数中** 需要注意的几点有：  
1. 先定义判断结束的返回，即出口  
2. 将问题化解为小问题  
3. 此时递归回溯阶段，之前的问题已经得到解决，在这里根据之前的结果加以处理返回  

读者可以根据以上总结来阅读以下代码：
```cpp
class Solution {
private: 
    vector<TreeNode*> generateTrees(int start, int end){
        //定义出口
        if(start>end){
            return {nullptr};
        }
        vector<TreeNode*> res;
        for(int i = start ;i<=end;i++){
            /****化解为小问题******/
            vector<TreeNode*> lefts = generateTrees(start,i-1);//递归
            vector<TreeNode*> rights = generateTrees(i+1,end);
            /*******************/

            //这里已经进入回溯阶段
            //利用结果分解当前问题
            for(auto left:lefts){
                for(auto right:rights){
                    TreeNode* node = new TreeNode(i, left, right);
                    res.push_back(node);
                }
            }
        }
        return res;
    }
public:
    vector<TreeNode*> generateTrees(int n) {
        //回溯法
        return generateTrees(1,n);  //问题所求
    }
};
```
接下来是学习笔记。  

## 定义
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

> 白话：回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。  

## 典型问题

### N皇后问题

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。（不能处在同一行，同一列，同一条斜线）

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

在实际撰写的过程中，发现思路并不难，但想要写出高效的题解不是一件非常轻松的事情。  


