-- MySQL dump 10.13  Distrib 8.0.21, for Linux (x86_64)
--
-- Host: localhost    Database: foril_blog
-- ------------------------------------------------------
-- Server version	8.0.21

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `about`
--

DROP TABLE IF EXISTS `about`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `about` (
  `content` text NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `about`
--

LOCK TABLES `about` WRITE;
/*!40000 ALTER TABLE `about` DISABLE KEYS */;
INSERT INTO `about` VALUES ('# About\r\n<hr />\r\n\r\n## 关于我\r\n\r\n* 大连理工大学软件工程在读本科生\r\n* 大数据技术与应用方向\r\n* 喜欢音乐、电影、摄影\r\n\r\n## 联系方式\r\n* QQ：1571825323\r\n* 邮箱：  <a href=\"mailto:1571825323@qq.com\" title=\"邮件\">点击发送邮件</a>  \r\n* <a target=\"_blank\" rel=\"noopener noreferrer\" href=\'https://gitee.com/foril\' title=\"gitee\">gitee</a>\r\n* <a target=\"_blank\" rel=\"noopener noreferrer\" href=\'https://github.com/foriLLL\' title=\"github\">github</a>\r\n\r\n## 有关本站\r\n\r\n本站建立于2021年4月，前后端均由个人独立开发，用于分享记录我在学习过程中所想所得，以便日后复习回顾查看，不保证内容正确性。所有内容由个人维护，如有疑问，请及时联系。欢迎志同道合的小伙伴随时跟我联系！  \r\n\r\n* 本站内容只代表个人观点\r\n* 部分内容、图片来源网络，如有侵权，决非恶意，请联系删除\r\n* 如内容有误，欢迎及时联系向我反馈  \r\n\r\n### 开发技术栈  \r\n|网站部分  |所用技术栈  |  \r\n|:-----:|:----:|\r\n|前端  |React.js + TypeScript |  \r\n|部分组件  |antDesign  |  \r\n|内容编写  |markdown + LaTeX |  \r\n|后端  |express + mysql  |  \r\n\r\n> 向光生长  \r\n> Forever, foriL  \r\n');
/*!40000 ALTER TABLE `about` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `articleID` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `cateID` int NOT NULL,
  `time` timestamp NOT NULL,
  `views` int NOT NULL DEFAULT '0',
  `content` text,
  PRIMARY KEY (`articleID`),
  UNIQUE KEY `article_title_uindex` (`title`)
) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (7,'力扣刷题笔记（一）',1,'2021-04-24 12:02:08',140,'决定用leetcode刷刷算法题，有些题写完后有些个人的理解和想法在当时顺便写下，便有了这篇笔记。  \n## 1 两数之和  \n### 题目  \n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n你可以按任意顺序返回答案。\n\n### **思路：**  \n这个题最简单的思路就是遍历，通过一个复杂度为N²的遍历，但要注意每次遍历只需要从选定的下标的下一个开始寻找，因为之前的都已经尝试过，不需要再次验证。  \n第二种解法始于对于N²的复杂度的优化，这时可以利用哈希表，快速的找到是否存在对应的下标变量  \n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n    for (int i = 0; i < nums.length; ++i) {\n        if (hashtable.containsKey(target - nums[i])) {\n            return new int[]{hashtable.get(target - nums[i]), i};\n        }\n        hashtable.put(nums[i], i);\n    }\n    return new int[0];\n    }\n```\n这样我们创建一个哈希表，对于每一个 x，我们**首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中**，即可保证不会让 x 和自己匹配。  \n***  \n\n## 21 合并两个有序链表\n### 题目   \n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n![题图](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg )  \n\n其思路类似于大小个两排排队，每次两排中大个先出列，一排为空时直接接上另一排，可使用递归的思想解决问题。  \n```java\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    //判断是否有一队为空\n    if (l1 == null) {   \n        return l2;\n    } else if (l2 == null) {\n        return l1;\n    } else if (l1.val < l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2;\n    }\n\n}\n```  \n---  \n## 705 设计哈希集合\n### 题目  \n \n不使用任何内建的哈希表库设计一个哈希集合（HashSet）。\n\n实现 MyHashSet 类：\n\n* void add(key) 向哈希集合中插入值 key 。\n* bool contains(key) 返回哈希集合中是否存在这个值 key 。\n* void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  \n\n\n### **思路：**  \n要解决这个题目的前提是明白哈希是什么，以我的理解就是很多个桶，拿到值后先算出hash值，然后就知道要放进哪个桶里，有这个理解后，就可以写出初步题解。  \n**链地址法**   \n\n![思路图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzA1LzcwNV9saW5rZWRfbGlzdC5wbmc?x-oss-process=image/format,png)  \n\n```java\nclass MyHashSet {\n	private static final int BASE = 769;\n	private LinkedList<Integer>[] list;\n\n	public MyHashSet() {\n		// 初始化\n		list = new LinkedList[BASE];\n		for (int i = 0; i < BASE; i++) {\n			list[i] = new LinkedList<Integer>();\n		}\n	}\n\n	public void add(int key) {\n		int hash = hash(key);\n		if (!list[hash].contains(key)) {\n			list[hash].push(key);\n		}\n	}\n\n	public void remove(int key) {\n		int hash = hash(key);\n		if (list[hash].contains(key)) {\n			list[hash].remove((Integer) key);\n		}\n	}\n\n	public boolean contains(int key) {\n		int hash = hash(key);\n		return list[hash].contains(key);\n	}\n\n	private static int hash(int key) {\n		return key % BASE;\n	}\n}\n```  \n需要注意这里相当于取了769个桶，这是一个素数，取这个数的原因是利用了同余的概念：当元素是个有规律的等差数列时，并且和基数（数组大小）最大公约数不为1时，就会造成哈希映射时冲突变高（数组某些位置永远不会有值）。  \n比如数列0,6,12,18,24,30...，base为10，取模(0,6,2,8,4,0...)后，放入哈希表中位置将只能在0,2,4,6,8这几个数组位置上；\n但我们如果把base取7（数组大小甚至比10小），同样数列取模后(0,6,5,4,3,2,1,0,...)，可以分布在哈希表中的0,1,2,3,4,5,6所有位置上；  \n### 改进\n有了初步的思路以后，想要改进就要考虑如果大量值的hash值重复，会造成一个桶里东西太多，到头还还是等同于遍历，可以优化哈希算法，包括开放地址法、再哈希法等等。\n\n*** \n\n## 706 设计哈希映射\n### 题目\n不使用任何内建的哈希表库设计一个哈希映射（HashMap）。\n\n实现 MyHashMap 类。  \n\n### **思路：**  \n这题与705相差不多，代码热热还能用。  \n上代码\n```java\nclass MyHashMap {\n\n	class Pair {\n		private int key;\n		private int value;\n\n		public Pair(int key, int value) {\n			this.key = key;\n			this.value = value;\n		}\n\n		public int getKey() {\n			return this.key;\n		}\n\n		public void setValue(int value) {\n			this.value = value;\n		}\n	}\n\n	private LinkedList[] list;\n	private static final int BASE = 769;\n\n	public MyHashMap() {\n		list = new LinkedList[BASE];\n		for (int i = 0; i < BASE; i++) {\n			list[i] = new LinkedList<Pair>();\n		}\n	}\n\n	public void put(int key, int value) {\n		int hash = hash(key);\n		Iterator<Pair> it = list[hash].iterator();\n		while (it.hasNext()) {\n			Pair existed = it.next();\n			if (existed.getKey() == key) {\n				existed.setValue(value);\n				return;\n			}\n		}\n		list[hash].add(new Pair(key, value));\n	}\n\n	public int get(int key) {\n		int hash = hash(key);\n		Iterator<Pair> it = list[hash].iterator();\n		while (it.hasNext()) {\n			Pair existed = it.next();\n			if (existed.getKey() == key) {\n				return existed.value;\n			}\n		}\n		return -1;\n	}\n\n	public void remove(int key) {\n		int hash = hash(key);\n		Iterator<Pair> it = list[hash].iterator();\n		while (it.hasNext()) {\n			Pair existed = it.next();\n			if (existed.getKey() == key) {\n				list[hash].remove(existed);\n                return;\n			}\n		}\n	}\n\n	private static int hash(int key) {\n		return key % BASE;\n	}\n}\n```\n\n## 54 螺旋矩阵\n### 题目：  \n给你一个 `m` 行 `n` 列的矩阵 matrix ，请按照**顺时针螺旋顺序** ，返回矩阵中的所有元素。\n\n### **思路：** \n第一次拿到这个题我的想法是循环套循环，外层循环判断是否上下左右可以前进，内层循环按照先向右走到头，下、左、上同理的顺序来保证顺时针螺旋顺序，这里用一个boolean列表用来记录是否走过对应的格子\n\n```java\n	private boolean[][] printed;\n	private int rowNow = 0, colNow = 0;\n\n    //判断是否能向对应方向走\n	private boolean up() {\n		if (rowNow == 0)\n			return false;\n		if (!printed[rowNow - 1][colNow])\n			return true;\n		return false;\n	}\n\n	private boolean down() {\n		if (rowNow == printed.length - 1)\n			return false;\n		if (!printed[rowNow + 1][colNow])\n			return true;\n		return false;\n	}\n\n	private boolean left() {\n		if (colNow == 0)\n			return false;\n		if (!printed[rowNow][colNow - 1])\n			return true;\n		return false;\n	}\n\n	private boolean right() {\n		if (colNow == printed[0].length - 1)\n			return false;\n		if (!printed[rowNow][colNow + 1])\n			return true;\n		return false;\n	}\n\n	public List<Integer> spiralOrder(int[][] matrix) {\n		List<Integer> list = new ArrayList<Integer>();\n		int rows = matrix.length;\n		int cols = matrix[0].length;\n		printed = new boolean[rows][cols]; // 初始化都为false\n		list.add(matrix[rowNow][colNow]); // 第一个\n		printed[rowNow][colNow] = true;\n\n		while (right()) {\n			// 有路可走\n			while (right()) {\n				// 能向右走\n				colNow++;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n\n			while (down()) {\n				// 能向下走\n				rowNow++;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n\n			while (left()) {\n				// 能向左走\n				colNow--;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n\n			while (up()) {\n				// 能向上走\n				rowNow--;\n				list.add(matrix[rowNow][colNow]);\n				printed[rowNow][colNow] = true;\n			}\n		}\n		return list;\n	}\n```\n\n\n\n## 59 螺旋矩阵II\n### 题目：\n给你一个正整数 `n` ，生成一个包含 1 到 `n²` 所有元素，且元素按**顺时针顺序螺旋排列**的 `n x n` 正方形矩阵 matrix 。\n\n### **思路：** \n思路同54  \n上代码\n```java\npublic int[][] generateMatrix(int n) {\n    int[][] matrix = new int[n][n];\n    int left = 0, right = n - 1, top = 0, bottom = n - 1;\n    int count = 1;\n    while (count <= n * n) {\n        // 右\n        for (int col = left; col <= right; col++) {\n            matrix[top][col] = count++;\n        }\n        // 下\n        for (int row = top + 1; row <= bottom; row++) {\n            matrix[row][right] = count++;\n        }\n        if (left < right && top < bottom) {\n            // 左\n            for (int col = right - 1; col >= left; col--) {\n                matrix[bottom][col] = count++;\n            }\n            // 上\n            for (int row = bottom - 1; row > top; row--) {\n                matrix[row][left] = count++;\n            }\n        }\n        top++;\n        bottom--;\n        right--;\n        left++;\n    }\n    return matrix;\n}\n```\n\n基本思路大同小异，下面提供一种官方更简洁的方法：\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int maxNum = n * n;\n        int curNum = 1;\n        int[][] matrix = new int[n][n];\n        int row = 0, column = 0;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // 右下左上\n        int directionIndex = 0;\n        while (curNum <= maxNum) {\n            matrix[row][column] = curNum;\n            curNum++;\n            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];\n            if (nextRow < 0 || nextRow >= n || nextColumn < 0 || nextColumn >= n || matrix[nextRow][nextColumn] != 0) {\n                directionIndex = (directionIndex + 1) % 4; // 顺时针旋转至下一个方向\n            }\n            row = row + directions[directionIndex][0];\n            column = column + directions[directionIndex][1];\n        }\n        return matrix;\n    }\n}\n```\n\n## 115 不同的子序列\n### 题目： \n给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。\n\n字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\"ACE\" 是 \"ABCDE\" 的一个子序列，而 \"AEC\" 不是）\n\n题目数据保证答案符合 32 位带符号整数范围。\n\n### **思路：**\n这个题目很明显是一个动态规划的题目，利用空间保存之前的计算结果，通过状态转移公式得到下一状态的结果并保存。\n\n假设字符串 s(sentence) 和 t(target) 的长度分别为 m 和 n。\n建立一个(m+1)*(n+1)的数组dp：  \n> 通过`dp[i][j]`来保存`s[i:]`的子序列中 `t[j:]` 出现的个数  \n\n其中下表为m,n的分别表示最后为空字符串\"\"的结果。  \n\n首先考虑几个初始状态，并初始化：  \n* 当 j=n 时，t[j:] 为空字符串，由于空字符串是任何字符串的子序列，因此对任意 0≤i≤m，有 `dp[i][n]` = 1；\n\n* 当 i=m 且 j<n 时，s[i:] 为空字符串，t[j:] 为非空字符串，由于非空字符串不是空字符串的子序列，因此对任意 0≤j<n，有 `dp[m][j]` = 0。\n\n得到状态转移方程\n$$\ndp[i][j] =\n\\begin{cases}\ndp[i+1][j+1]+dp[i+1][j], & \\ s[i]=t[j]  \\\\[2ex]\ndp[i+1][j], & \\ s[i]\\ne t[j]\n\\end{cases}\n$$\n\n于是可得到代码：\n```java\n public int numDistinct(String s, String t) {\n        int m = s.length(), n = t.length(); //便于之后使用\n        //不可能情况\n        if (m < n) {\n            return 0;\n        }\n        //dp\n        int[][] dp = new int[m + 1][n + 1];\n        //初始化边界情况\n        for (int i = 0; i <= m; i++) {\n            dp[i][n] = 1;\n        }\n        \n        for (int i = m - 1; i >= 0; i--) {\n            char sChar = s.charAt(i);\n            for (int j = n - 1; j >= 0; j--) {\n                char tChar = t.charAt(j);\n                if (sChar == tChar) {\n                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];\n                } else {\n                    dp[i][j] = dp[i + 1][j];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n```\n\n\n## 206 反转列表\n### 题目：\n反转一个单列表\n\n### **思路：** \n最一般的方法是使用迭代将每一个指针指向前一个。  \n这种链表的题最容易想错的地方是改变了指向后忘记把原来存在的指针删除，导致思路出错。通俗来想是把这个节点的指向`“掰”`向另一个节点。  \n所以做链表的题应该先沉下心来，把思路完全想清楚了，然后用几行代码解决问题，而不是修修补补。  \n\n* 第一种迭代的思路：\n  共使用三个指针，一个记录当前节点curr，一个记录前一个节点prev，一个记录下一个节点next。每一次将当前节点的next指向前一个节点，直至当前节点为null。  \n  每次迭代的开始先记录下一个节点（块内变量），prev的初始值为null，刚好作为返还后的结束，之后每次迭代后要将prev的值改为curr。\n    \n```java\n    class Solution {\n        public ListNode reverseList(ListNode head) {\n            ListNode prev = null;   //初始值为null作为结束的指向\n            ListNode curr = head;\n            while (curr != null) {\n                ListNode next = curr.next; //可在每次迭代时再声明临时变量保存\n                curr.next = prev;\n                prev = curr;\n                curr = next;\n            }\n            return prev;\n        }\n    }\n```\n\n\n* 第二种递归的思路：  \n  这种思路比较难理解，但设计非常巧妙。其关键在于反向工作。**假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？**    \n  主要难以理解的地方在于：真正修改指向的操作在递归之后，也就是说是在***回溯***的阶段从后往前修改指向的，\n  上代码理解：\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) { //包括一个节点的情况\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;  //后面的节点转向\n        head.next = null;   //前面的节点指向null\n        return newHead; //新的head依次传递回来\n    }\n}\n```\n\n\n## 191 位1的个数\n### 题目：\n\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 \'1\' 的个数（也被称为汉明重量）。\n\n提示：\n\n请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。  \n在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n### **思路：** \n解法1：  \n最简单直接的、不用位运算的思路就是使用`Integer.toBinaryString(n)`将十进制整数n转换成二进制字符串，然后遍历串的每一位检查是否为1  \n```java\npublic int hammingWeight(int n) {\n    String a = Integer.toBinaryString(n);   //Integer内置函数\n    int count = 0;\n    for(int i = 0; i < a.length(); i++){\n        if(a.charAt(i)==\'1\') {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n但这样效率比较低，如果可以直接操作二进制数，效率会高很多。  \n解法2：  \n使用位操作符，循环i从0到31，利用 `n&(1<<i)` 对比是否第i位上为1。  \n```java\npublic int hammingWeight(int n) {\n    int count = 0;\n    for(int i = 0;i<32;i++) {\n        if((n&(1<<i))!=0) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n解法3：  \n对于位运算的优化——注意到`n&(n-1)`可以让`n`最后一位1变为0，于是循环直至`n==0`。  \n```java\npublic int hammingWeight(int n) {\n    int count = 0;\n    while(n!=0) {\n        n = n&(n-1);\n        count++;\n    }\n    return count;\n}\n```\n\n## 73 矩阵置零\n### 题目：\n\n给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 ***原地*** 算法。\n### **思路：** \n这是我第一次听说原地算法，说白了就是不利用或只利用固定的少量空间来完成题解，对于这个题，就是在原矩阵中做出标记完成理解。  \n对于这个题来说，如果某行某列是0，那么该行该列都要置为0，那么我们可以利用 **第一行**（第一列）来保存是否该行（该列）要置为0。  \n其原理就在于反正这一块要被污染，就利用他来保存需要的标记。  \n存在的问题是需要额外的变量来保存是否第一行（第一列）本身需要被全部置零。可用`[0,0]`来保存是否第一行要被置零，这样就只需要一个额外的变量来保存是否第一列要被置零。\n```java\npublic void setZeroes(int[][] matrix) {\n    boolean ifCol1Z = false; // 用来记录第一列是否需要置空\n    int m = matrix.length, n = matrix[0].length;\n    for (int i = 0; i < m; i++) {\n        if (matrix[i][0] == 0) {\n            // 第一列为0\n            ifCol1Z = true;\n        }\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[0][j] = matrix[i][0] = 0;\n            }\n        }\n    }\n    // 填充\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = 1; j <= n - 1; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n        if (ifCol1Z) {\n            matrix[i][0] = 0;\n        }\n    }\n}\n```\n\n## 456 132模式\n### 题目：\n给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。\n\n如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。\n\n进阶：很容易想到时间复杂度为 $O(n^2)$ 的解决方案，你可以设计一个时间复杂度为 $O(n logn)$ 或 $O(n)$ 的解决方案吗？\n### **思路：**   \n如题所说，很容易想到时间复杂度为$O(n^2)$的思路，以i, j, k标识，即遍历j，i保存为j以前最小的数，每一次遍历j都内部循环j右侧次大的数k（或比i最大的数中最小的那个）。  \n这样的算法问题出在每次求k都需要遍历，所以想到改进得到$O(nlogn)$的算法：使用平衡树记录j右边的数每次通过logn的复杂度获得j右侧次大的数k（或比i最大的数中最小的那个）。  \n> 这里用到的数据结构是TreeMap。用到的方法有：  \n> * put \n> * ceilingKey\n> * remove\n> * getOrDefault\n\n\n```java\npublic boolean find132pattern(int[] nums) {\n    int n = nums.length;\n    if (n < 3)\n        return false;\n\n    // 至少3个\n    int leftMin = nums[0];\n    TreeMap<Integer, Integer> right = new TreeMap<Integer, Integer>();\n\n    // 扫描从2开始右侧的所有，建立\n    for (int k = 2; k < n; k++) {\n        right.put(nums[k], right.getOrDefault(nums[k], 0) + 1);\n    }\n\n    for (int j = 1; j < n - 1; j++) {\n        if (leftMin < nums[j]) {\n            Integer tmp = right.ceilingKey(leftMin + 1);\n            if (tmp != null && tmp < nums[j])\n                return true;\n        }\n        // 为下一次循环更新\n        // 计数减一\n        right.put(nums[j + 1], right.get(nums[j + 1]) - 1);\n        if (right.get(nums[j+1]) == 0)\n            right.remove(nums[j+1]);\n        leftMin = Math.min(leftMin, nums[j]);\n    }\n    return false;\n}\n```\n\n\n## 61 旋转链表\n### 题目：\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。  \n注意k可能大于链表的长度\n### **思路：**   \n解法1：  \n对于链表的循环，我初步的想法是因为链表循环n次会回到初始情况，所以实际上只需要移动k%n个位置，这样我第一遍得到链表的长度n，之后通过几个变量移动k%n次即可。  \n```java\npublic ListNode rotateRight(ListNode head, int k) {\n    ListNode header = new ListNode(0,head);\n    ListNode pre = header,pio = header;\n    int count = 0;\n    while(head!=null){\n        head = head.next;\n        count++;\n    }\n    if(count == 0 || count == 1) return header.next;\n\n    for(int i = 0; i<k%count;i++){\n        pio = pio.next;\n    }\n    while(pio.next!=null){\n        pio = pio.next;\n        pre = pre.next;\n    }\n    pio.next = header.next;\n    header.next = pre.next;\n    pre.next = null;\n    return header.next;\n}\n```\n\n解法2：  \n后来看到官方题解**闭合为环**，觉得很有意思，在这里分享一下。  \n首先遍历到链表尾部，顺便得到链表的长度n，这样便只需要移动k%n次。  \n新的头部则在原头部`n-k%n`处，若`n-k%n`等于`n`，则返回原头部。  \n```java\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter->next = head;\n        while (add--) {\n            iter = iter->next;\n        }\n        ListNode* ret = iter->next;\n        iter->next = nullptr;\n        return ret;\n    }\n```\n这里还有一个很有意思的循环a次的方法`while(a-- > 0)`\n\n## 190 颠倒二进制位\n### 题目：\n颠倒给定的 32 位无符号整数的二进制位。\n### **思路：**   \n在刚拿到这个题时本想偷个懒，利用`Integer.toBinaryString`得到字符串再乘加权简单通过，然后发现当使用`Math.pow`数字太大（比如$2^{31}$）时，java的double会变得不够精确，会有1的偏差，导致得到的结果会有差距而失败。只能通过位运算。  \n除了基本的解题方法（见代码）外，题解中的`位运算分治`方法思路比较清奇，在这里都贴出来。\n\n```java\npublic int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; i++) {\n        res |= (n&1)<<31-i;\n        n>>=1;\n    }\n    return res;\n}\n```\n方法2（位运算分治）：\n```java\nclass Solution {\nprivate:\n    const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101\n    const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011\n    const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111\n    const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111\n\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        n = n >> 1 & M1 | (n & M1) << 1;\n        n = n >> 2 & M2 | (n & M2) << 2;\n        n = n >> 4 & M4 | (n & M4) << 4;\n        n = n >> 8 & M8 | (n & M8) << 8;\n        return n >> 16 | n << 16;\n    }\n};\n```'),(10,'Nginx学习笔记（简单理论篇）',1,'2021-05-03 02:48:39',136,'Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。在之前部署上一个项目配置Nginx的过程中，很多操作并不熟悉，感觉只是做一步查一部，对于真正的用法和原理并没有深究，本文记录了最近对于Nginx的进一步学习的笔记，图片和部分内容来源网络。\n\n下图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。\n![架构图](https://pic1.zhimg.com/80/v2-e1826bab1d07df8e97d61aa809b94a10_1440w.jpg)  \n\n\n接下来需要区分清楚正向代理和反向代理的区别。  \n## 正向代理：\n正向代理“代理”的是客户端，而且**客户端是知道目标的**，而**目标是不知道客户端是通过VPN访问的**。  \n\n<img src=\"http://img.foril.fun/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpg\" width=500/>\n\n\n## 反向代理：\n**反向代理“代理”的是服务器端**，而且这一个过程对于客户端而言是透明的。\n\n<img src=\"http://img.foril.fun/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.jpg\" width=500/>  \n\n## Master-Worker模式\n启动Nginx后，其实就是在80端口启动了Socket服务进行监听。  \nNginx采用**Master-Worker模式**  \n\n### Master的作用：\n* Master负责管理Worker进程  \n* 读取并验证配置文件`nginx.conf`；\n\n### Worker的作用：\n* 每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；\n* Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。\n\n***\n上文基本描述了Nginx如何处理具体的请求。接下来考虑下一个深入一步问题：  \n### Nginx如何做到高并发下的高效处理？  \nNginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。\n> **思考：Nginx如果挂了怎么办？**  \n> Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。  \n> 一般的处理是使用进程管理工具**守护进程**。  \n> 题外话：  \n> **本站并未对Nginx采用进程守护**    \n> **但对后端服务器通过pm2守护进程并使用监听模式**  \n> 监听模式启用后，编辑后端时，对应常采取的方式是VSCode远程编辑后端代码，每次更新都会自动刷新，存在的小问题是每次编辑都会刷新后端的缓存，所有的session都会失效，可以用持久化存储解决这个小问题（在后端代码之前的版本里启用了持久化存储到文件里，后来看着文件太多心烦就注释了），但我也只有自己一个用户，影响不大  \n> pm2是一个进程管理工具,可以用它来管理你的node进程，并查看node进程的状态，当然也支持性能监控，进程守护，负载均衡等功能  \n  \n之后将会在操作篇进入对Nginx配置的实际操作学习。\n\n## 参考：\n- [1] [知乎：8分钟带你深入浅出搞懂Nginx](https://zhuanlan.zhihu.com/p/34943332)'),(13,'力扣刷题笔记（二）',1,'2021-05-13 06:10:42',158,'第二篇leetcode刷题笔记  。\n\n## 7. 整数反转　　\n### 题目　　\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。　　\n\n如果反转后整数超过 32 位的有符号整数的范围 [$−2^{31}$,  $2^{31} − 1$] ，就返回 0。　　\n\n假设环境不允许存储 64 位整数（有符号或无符号）。　　\n\n### 思路：　\n这是一道简单题，之所以放在这里，是因为其中题解提供的一些思路很值得学习，并且在其中我遇到的一些小问题也很值得记录下来以便以后回忆。  \n\n#### 不借助栈的“弹出”和“推入”  \n首先这个题第一思路是需要借助栈翻转，但作为数字，我们可以不使用栈就对其数字加以翻转。这是值得记录回忆的小技巧之一。  \n\n```java\n// 弹出 x 的末尾数字 digit\ndigit = x % 10\nx /= 10\n\n// 将数字 digit 推入 rev 末尾\nrev = rev * 10 + digit\n```\n\n其次需要判断反转后的数字是否溢出，因为我们只能使用32位整型，所以不能使用`rev*10+digit >　Integer.MAX_VALUE`这样的语句来判断，但我们可以反其道而行，对`Integer.MAX_VALUE`除10来判断，这里题解中有一个值得学习的推导思路：  \n\n考虑 x>0 的情况，记 $INT\\_MAX=2^{31}-1=2147483647$ ，由于\n\n$$\n\\begin{aligned} \\textit{INT\\_MAX}&=\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor\\cdot10+(\\textit{INT\\_MAX}\\bmod10)\\\\ &=\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor\\cdot10+7 \\end{aligned}\n$$\n\n则不等式$rev⋅10+digit≤INT\\_MAX$\n\n等价于\n\n$$\n\\textit{rev}\\cdot10+\\textit{digit}\\le\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor\\cdot10+7\n$$\n\n移项得\n\n$$\n(\\textit{rev}-\\lfloor\\dfrac{\\textit{INT\\_MAX}}{10}\\rfloor)\\cdot10\\le7-\\textit{digit}\n$$\n\n讨论该不等式成立的条件：\n\n若 $rev>\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$ ，由于 ${digit}\\ge0$，不等式不成立。  \n\n若 $rev=\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$\n ，当且仅当 ${digit}\\le7$ 时，不等式成立。  \n\n\n若 $rev<\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$\n​，由于 ${digit}\\le9$，不等式成立。\n\n**注意**：这里需要注意如果$rev=\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$时仍然能够推入数字，说明 x 和$INT\\_MAX$的位数相同，digit 为 x 的首位，因为$x<0$，所以$digit\\le2$，\n因此判定条件可简化为：当且仅当 $rev\\le\\lfloor\\cfrac{{INT\\_MAX}}{10}\\rfloor$ 时，不等式成立。\n\nx<0 的情况类似.\n\n**综上所述**，判断不等式\n\n$$\n-2^{31}\\le\\textit{rev}\\cdot10+\\textit{digit}\\le2^{31}-1\n$$\n\n是否成立，可改为判断不等式\n$$\n\\lfloor\\cfrac{-2^{31}}{10}\\rfloor\\le\\textit{rev}\\le\\lfloor\\dfrac{2^{31}-1}{10}\\rfloor\n$$\n\n是否成立，若不成立则返回 0。\n\n---\n\n解决了边界问题这个重点问题，剩余的部分就很简单了，需要判断结尾的`0`以及开头的`-`，在这里就不详细分析了。\n\n\n\n## 1310. 子数组异或查询  　\n### 题目　　\n有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。\n\n对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。\n\n并返回一个包含给定查询 queries 所有结果的数组。\n\n输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]  \n输出：[2,7,14,8]   \n解释：  \n数组中元素的二进制表示形式是：  \n1 = 0001  \n3 = 0011  \n4 = 0100  \n8 = 1000  \n查询的 XOR 值为：  \n[0,1] = 1 xor 3 = 2   \n[1,2] = 3 xor 4 = 7   \n[0,3] = 1 xor 3 xor 4 xor 8 = 14   \n[3,3] = 8  \n\n\n### 思路：\n最初写了一个最简单的遍历想解决问题，设`arr`的长度为`n`，`queries`的长度为`m`，这样时间复杂度为$O(mn)$，结果运行超时，我开始思考怎么解决问题。  \n\n后来看到题解“前缀异或”，突然想到，异或和加减有很多相似的性质，看到异或，又看到连续数组，应该想到利用前缀和的思想，异或这东西不是有`x^x=0`这种好用的性质吗，题目要求的是对arr中间一段进行异或，那不是就可以后面的结果异或抵消前面的结果嘛。  \n这里有一个示意可以方便理解。  \n\n```\n--------\n^\n---\n=\n   -----\n```\n\n这样只需要遍历一遍arr，得到arr.size()个结果保存起来，剩下的就是做异或相抵消得问题了。  \n上代码：  \n```cpp\nclass Solution {\n	public:\n		vector<int> xorQueries(vector<int>& arr, vector<vector<int> >& queries) {\n			int len = arr.size();\n			vector<int> rec(len+1, 0);\n			//遍历arr得到arr个结果（第一个0作为初始值，作为最左值之前的结果）\n			for(int i=0; i<len; i++) {\n				rec[i+1] = (rec[i]^arr[i]);\n			}\n			vector<int> res;\n			//右下标异或左下标之前的结果作抵消\n			for(vector<int> lr: queries) {\n				res.push_back(rec[lr[1]+1]^rec[lr[0]]);\n			}\n			return res;\n		}\n};\n```\n\n\n## 62. 不同路径 　\n### 题目　　\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n\n### 思路：\n#### 方法1：数学法\n这个题一看到最初的思路是数学法，利用组合数 $C_{m+n-2}^{m-1}$ 。可以理解为一共有`m+n-2`个空，往其中填入`m-1`个黑棋，剩下的全部填入白棋，便得到了最终的结果，但实际写出来发现存在的问题是如果先计算分母极容易溢出。  \n如果使用的语言有关于组合数的API直接调用即可，如果没有，可以考虑\n```cpp\nfor (int x = n, y = 1; y < m; ++x, ++y) {\n            ans = ans * x / y;\n        }\n```\n(来自力扣官方题解)  \n\n最初纠结这样一个一个分数会不会产生分数，后来看到网友的评论突然想明白了。\n\n<img src=\"https://img.foril.fun/%E7%BB%84%E5%90%88%E6%95%B0.jpg\" width=\'1000\'/>\n\n#### 方法2：动态规划\n不多说废话，具体动态规划的要点可以查看我的另一篇博客 [专题：动态规划](https://www.foril.space/article/21)。  \n这一题通过一个二维数组记录到对应点的最多方法。\n\n上代码：\n```cpp\nint uniquePaths(int m, int n) {\n    int dp[m][n];   //二维数组\n    memset(dp,0,sizeof(dp));    //初始化（因为是memset针对字节，所以一般只能初始化为0）\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(i == 0 || j==0){\n                dp[i][j] = 1;   //边界值（初始化）\n            }\n            else{\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]; //状态转换方程\n            }\n        }\n    }\n    return dp[m-1][n-1];\n}\n```\n\n\n## 406. 根据身高重建队列　\n### 题目　　\n\n假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n\n示例：  \n输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]  \n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n\n\n### 思路：\n#### 方法一： 从高到低考虑\n这个题一开始上手没有找到其中的窍门，感觉类似的题目的关键就是能够找到一个窍门，或者说一个隐藏的属性。  \n这个题 ki 记录的是前面有多少身高大于等于 hi 的人数，言下的意思是前面如果放的是比他身高小的人，是没有任何影响的。那我们只要按照一定顺序填入队列就可以得到实际的位置。  \n官方题解的原话是：\n> 如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第 i 个人时：  \n> * 第 0, ... , i-10, ... ,i−1 个人已经在队列中被安排了位置，并且他们无论站在哪里，对第 i 个人都没有任何影响，因为他们都比第 i 个人矮；  \n> * 而第 i+1, ... ,i+1, ... ,n−1 个人还没有被放入队列中，但他们只要站在第 i 个人的前面，就会对第 i 个人产生影响，因为他们都比第 i 个人高。\n\n所以我们要先找到大个的相对位置，把大个的放进队列里，这样其他人的位置不会影响到更大个的人的位置。同时，相同个子的人需要先放入前面人少的人，也就是得到了一个排序的方法：**先按第一列从大到小排序，第一列相同的按第二列从小到大排序**。\n```cpp\n//排序\nsort(people.begin(), people.end() , [](const vector<int> & a, const vector<int> & b) {\n    if(a[0] == b[0]) return a[1]<b[1];\n    return a[0]>b[0];\n});\n```\n\n那么，对示例`[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`来说，排序后的结果应该是：  \n```\n7,0\n7,1\n6,1\n5,0\n5,2\n4,4\n```\n这也就是我们填入的顺序，每填入一个**当前最小个的人**，根据它前面的人数`ki`，把他放在第`ki`个位置，之后的全部往后移。最后全部填入，就是最终的顺序。  \n这样频繁插入移动，在java中考虑使用 LinkedList 。\n\n代码：\n```cpp\nvector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n    //第零列从大到小\n    //第一列从小到大哦\n    int len = people.size();\n    sort(people.begin(), people.end() , [](const vector<int> & a, const vector<int> & b) {\n        if(a[0] == b[0]) return a[1]<b[1];\n        return a[0]>b[0];\n    });\n\n    //排好序后开始放位置\n    vector<vector<int>> list(len);\n    for(int i = 0; i<len; i++) {\n        int pos = people[i][1];\n        for(int j = len-2; j>=pos; j--) {\n            //往后窜\n            list[j+1] = list[j];\n        }\n        list[pos] = people[i];\n    }\n    return list;\n}\n```\n\nPS:  \n后来发现往后窜的步骤可以通过 `insert`。\n```cpp\nfor (const vector<int>& person: people) {\n    ans.insert(ans.begin() + person[1], person);\n}\n```\n#### 方法二： 从低到高考虑\n同上，在排好序的队列中，个小的人是影响不到个高的人的 `ki` 的，所以我们可以按身高从低到高往队列中插入，前面只要留够 `ki` 个 “空座” 给之后个更高的人。对于相同身高的人，需要先排入 `ki` 大的人。  \n\n> 这里需要注意的是排序方法和方法一刚好相反。  \n\n对示例`[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`，排序后的结果应该是：  \n```\n4,4\n5,2\n5,0\n6,1\n7,1\n7,0\n```\n有了这个顺序，便遵循 `留空 -> 插入` 的原则找到位置即可。  \n\n<img src=\"https://img.foril.fun/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.webp\" width=1000/>\n\n代码：\n```cpp\nvector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n    sort(people.begin(), people.end(), [](const vector<int>& u, const vector<int>& v) {\n        return u[0] < v[0] || (u[0] == v[0] && u[1] > v[1]);\n    });\n    int n = people.size();\n    vector<vector<int>> ans(n);\n    for (const vector<int>& person: people) {\n        int spaces = person[1] + 1;\n        for (int i = 0; i < n; ++i) {\n            if (ans[i].empty()) {\n                --spaces;\n                if (!spaces) {\n                    ans[i] = person;\n                    break;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n\n## 96. 不同的二叉搜索树\n### 题目　　\n\n给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\n\n示例 1：  \n输入：n = 3  \n输出：5\n\n<img src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" width=800>\n\n### 思路：\n如果了解过**卡塔兰数**的话，可以直接得到\n$$\nC_{n+1} =  \\frac{2(2n+1)}{n+2}C_n\n$$\n> 令h(0)=1,h(1)=1，卡塔兰数满足递归式：\nh(n)= h(0)*h(n-1) + h(1)*h(n-2) + ... + h(n-1)h(0) (其中n>=2),这是n阶递推关系;\n\n以这个题作为背景的话，实际意义就是 n 个数对应分别以 1 到 n 作为根节点，也就是左孩子分别有 0 个到 n-1 个节点这n种情况的数量之和。  \n\n## 664. 奇怪的打印机\n### 题目　　\n\n有台奇怪的打印机有以下两个特殊要求：\n\n1. 打印机每次只能打印由 同一个字符 组成的序列。  \n2. 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。\n\n给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。\n\n**示例 1：**  \n输入：s = \"aaabbb\"  \n输出：2  \n解释：首先打印 \"aaa\" 然后打印 \"bbb\"。  \n    \n**示例 2：**  \n输入：s = \"aba\"  \n输出：2  \n解释：首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 \'a\'。  \n\n### 思路：\n之前在 [动态规划专题](https://www.foril.space/article/21) 中，提到过很多字符串最优问题都是使用动态规划解决的。  \n这个题一上手，并没有找到解决的方法，主要问题是找不到状态转换方程，在查看题解后，发现题解将一个区间的最优问题转化为小区间的最优问题求和的最小值。后来从评论区明白这是一类叫 **“区间DP”** 的问题。  \n\n#### 什么是区间DP？\n区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过 *合并小区间的最优解进而得出整个大区间上最优解* 的DP算法。  \n既然让我求解在一个区间上的最优解，那么我把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可。\n\n朴素区间DP（$N^3$）转移方程：  \n```cpp\ndp[j][ends] = min(dp[j][ends],dp[j][i]+dp[i+1][ends]+weigth[i][ends]);\n```\n有了这些背景知识，就可以得到本题的基本思路。\n\n动态规划的基本要素：  \n* **保存**：`dp[i][j]`保存下标从`i`到`j`的最小打印次数\n* **状态转移方程**： \n$$\ndp[i][j] = \n\\begin{cases}\n        dp[i][j-1] &,s[i]==s[j]\\\\\n        min_{k=i}^{j-1} dp[i][k] + dp[k+1][j]&,s[i]!=s[j]\n\\end{cases}\n$$\n* **初始化**：`dp[i][i] = 1`\n* **遍历顺序**：`i`从大到小；`j`从小到大\n* **结果**：`dp[0][n-1]`\n\n这就是做一道动态规划最重要的步骤了，这一题还有一个主要要理解的难点就是如何使用区间DP。  \n上代码：  \n```cpp\nclass Solution {\npublic:\n    int strangePrinter(string s) {\n        int n = s.length();\n        int dp[n][n];\n        //初始化\n        for(int i = 0;i<n;i++){\n            dp[i][i] = 1;\n        }\n        //状态转移方程\n        for(int i = n-1;i>=0;i--){\n            for(int j = i+1;j<n;j++){\n                if(s[i] == s[j]){\n                    dp[i][j] = dp[i][j-1];\n                }else{\n                    int minR = INT_MAX;\n                    for(int k = i;k<j;k++){\n                        minR = min(minR, dp[i][k] + dp[k+1][j]);\n                    }\n                    dp[i][j] = minR;\n                }\n            }\n        }\n        //结果\n        return dp[0][n-1];\n    }\n};\n```\n## 39. 组合总和\n### 题目　　\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n\n### 思路：\n这个题是在刷回溯专题时遇到的。接下来几个题都有很典型的回溯算法的结构。\n```cpp\nclass Solution {\nprivate:\n    vector<vector<int>> res;    //存放结果\n    void bt(vector<int>& v,int index, int already,int target, vector<int>& candidates){\n        if(already>target){ //出口条件（不合格，舍弃）\n            return;\n        }\n        if(already==target){//出口条件（是结果，加入结果数组）\n            res.push_back(v);\n            return;\n        }else{\n            //继续往下试探\n            for(int i = index;i<candidates.size();i++){ //尝试不同的数字作为下一个候选\n\n                v.push_back(candidates[i]); //第一部分，把当前数字加入结果往下试探\n\n                bt(v, i, already+candidates[i], target, candidates);    //递归试探过程\n\n                v.pop_back();   //试探结束后，为了使用下一个数字，要把当前数字所做的改变全部复原\n            }\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<int> v;\n        bt(v, 0, 0, target, candidates);    //进入\n        return res;\n    }\n};\n```\n'),(17,'项目管理笔记',1,'2021-05-06 07:21:26',74,'软件项目管理笔记。   \n\n# 软件管理\n\n# Class 1\n\n项目：为了得到一个产品、服务、成果而付出的一次性的临时努力\n\n项目的特点：临时（有开始，有结束），追求结束，一次性，独特的。其他项目的经验只能借鉴不能直接拿来用。\n\n渐进明细：波动式计划，远期粗略规划，近期细化\n\n运营：为了持续的经营下去，执行反复的流程。\n\n共同点：受资源限制，都需要计划\n\n项目的结果（产品）：项目成功的依据，范围、进度、成本、质量\n\n项目目标：追求成功，受到的影响：技术，分工，干系人影响最大\n\n识别：多目标，层次化，优先级	\n\n干系人：对项目有影响的人就是干系人（积极影响，消极影响）\n\n### 关键干系人：\n\n客户方：建设方（甲方）\n\n实施方：PM项目经理，团队成员（程序，测评，架构，系统分析，质量QA），外包团队\n\n第三方：咨询方（需求开发）---》监理方，专家\n\n### 项目经理角度考虑问题：\n\n1. 项目管理的知识领域（赶工，绩效）\n2. 广博的知识，丰富的经历\n3. 应用领域的知识标准和规定\n4. 良好的沟通和协调能力（人），软技能\n5. 良好的职业道德\n\n### 项目管理\n\n科学规划角度出发\n\n### 组织结构\n\n因为项目有多个干系人，干系人之间存在关系，如何管理干系人的关系（汇报）\n\n### 组织结构OBS\n\n1. 传统职能型：涉及到和职能经理谈判获取对应的资源，人员会受到多头管理，造成管理混乱，为了解决项目经理权限不足的问题，PMO（项目管理办公室）协调（位于总裁下方那个，比职能经理高半级）\n\n\n\n# Class 2\n\n项目：独特，结束，逐步细化\n\n衡量：范围，进度，成本，质量\n\n干系人：有影响的人，关键干系人（客户，承建，第三方）\n\n### 组织结构OBS\n\n1. 传统职能型：涉及到和职能经理谈判获取对应的资源，人员会受到多头管理，造成管理混乱，为了解决项目经理权限不足的问题，PMO（项目管理办公室）协调（位于总裁下方那个，比职能经理高半级），员工的职业连续性可以得到保证。\n2. 项目型：PM和员工都属于全时参与，便于绩效考核，员工缺乏事业连续性，PMO一般位于沟通中心，自上而下的按照优先级分配协调资源。\n3. 矩阵型：介于传统之鞥呢和项目之间的一种OBS模型。\n\n### 周期\n\n产品周期\n\n项目周期：项目周期的结束就是项目首尾（必须包含产品的验收和合同管理的收尾【归属于PM的合同部分结束---》将合同移交至外部（财务）】）\n\n管理周期\n\n合同周期\n\n### 阶段\n\n便于控制和管理项目。每个阶段末都应该有交付物，通过评审，评审（独立第三方）是作为结束上一阶段开始下一阶段的依据。\n\n### 项目各阶段因素的影响：PDCA\n\nP Plan（PM的任务，计划，计划，再计划）\n\nD Do（按照已评审的计划执行）\n\nCA Check Action（对于计划发现皮纳差，分析原因，原因可消除就去消除，不可消除修改计划）\n\n### 过程组\n\n启动过程组，规划过程组，执行过程组， 监控过程组，收尾过程组。\n\n过程组：将某项管理的管理内容（活动）分类处理，管理优化。\n\n## 项目管理：十大管理44个过程\n\n整体管理，需求，范围，进度，成本，质量，风险，团队，沟通，合同\n\n## 整体管理流程\n\n### 项目章程：\n\n内容：指导性文件、授权项目经理PM【PMO（项目管理办公室、出资人）】，批准项目或阶段\n\n输入：合同，SOW（工作说明书），柱子过程资产，企业环境因素\n\n工具与技术：项目管理软件，模板，转件判断，方法论\n\n输出：项目章程（主要内容）\n组织的约束，干系人，干系人的期望目标，概要的里程碑，概要的预算，授权项目经理（PM的合法权利）  \n\n\n\n### 初步范围说明书  \n需求来自于合同和SOW（产品需求），概括式的计划  \n\n输入：项目章程  \n工具与技术：  \n输出：范围说明书（初步）--》波动式计划\n\n\n### 整体规划\n制定项目的整体管理计划，包括各子计划  \nPM组织相关干系人制定计划（成果），通过评审后作为项目的指导文件  \n计划：定宗旨，选标准，指导后续工作  \n\n输入：初步范围说明书\n工具与技术：\n输出：\n\n### 执行  \nDo 按照计划做（PM组织资源）\n\n### 监控  \n监督和控制CA  \n万能的监控方式：组织相关干系人制定计划，通过评审，设置周期性和里程碑的监控点，对比计划发现偏差，如果产生偏差分析原因（1.原因可消除，消除原因，2.原因不可消除，更新计划），按照新计划执行，记录存档\n\n### 变更  \n强制变更（政策类），普通变更，不管哪一类变更，必须要走变更控制流程  \n1. 申请（PM提出）  \n2. 组织评估，提供评估报告（PM组织）  \n3. 提供CCB进行决策  \n4. 更新计划  \n5. 组织资源按照更新后的计划实施  \n6. 验证变更是否符合评估\n7. 记录日志（累积组织过程资产）\n\n### 收尾  \n项目的收尾包括产品的验收管理的收尾  \n产品验收：准备（产品，用户手册，质保，验收单），通知甲方验收（合同中写明验收规范）  \n管理收尾：绩效考核，总结经验\n\n# Class 3\n\nPDCA =》五大过程组。\n\n在项目管理过程中，前序工作的成果【在每个过程都叫做输出】通过评审（测试）可以作为后续工作的前提和依据【输入】，过程中采用的手段叫做工具与技术。\n\n性质，范围，合同是多方之间民事行为的约束\n\nSOW，工作说明书，用户需求的更详细的描述\n\n组织过程资产：积累的经验和教训\n\n企业环境因素：（不可裁剪）\n\n专家判断：德尔菲法\n\n多轮，背靠背（防止想法被片面方放大），投票，筛选\n\n纵向思维法，横向思维法，头脑风暴法\n\n范围：需求的抽象描述，范围就是完成项目需要仅需要做的工作或活动  \n\n# Class4\n\n变更：软件项目中，变更是不可避免的   \n变更混乱会发生，会发生配置管理混乱，返工   \nCCB：变更控制委员会（配置控制委员会），临时机构，负责进行变更的审批（变或不变）  \nCCB成员：具有资金审批权的人，甲乙双方以及监理的高层，PM也应该是CCB的成员（不可以承担副组长以上的职务）  \nCCB可以只有1人，也可以兼职  \n变更可能会引起项目的进度、成本、合同发生改变\n  \n\n推进顺序：  \n招投标和采购  \n招标：\n1. 编制标书（评标规则-无歧视，不能模糊）\n2. 发布招标公告（公共平台，声明资质要求）\n3. 发售标书（进行资格预审，购买费用+投标保证金）\n4. 接受投标（密封）\n5. 评标（解封）\n6. 宣布中标，签订合同  \n\n### 标书密封，标底可保密     \n反不正当竞争法：不得以低于成本价竞标，发售标书时间不得短于20天  ，如果修改了招标文件截止日期不得短于15天，确定中标需要通知所有投标方 （退还保证金），中标后30天内必须签订合同，评标技术专家不能低于2/3，专家不能少于5人，专家>=5人的奇数\n          \n可以不招标的活动，私人企业，可行性研究，涉密，救灾\n\n\n# Class5\n\n###身份（PM，投递，讲解）\n\n私企，涉密，救灾，可行性研究可以不招标  \n\n### 可行性研究  \n目的：论证项目是否可行（可能性，必要性）  \n可行性研究的方面：\n1. 技术可行性：人员、资源、 \n2. 经济可行性：敏感性（龙卷风 或者财务分析方法  \n3. 运行环境：（用户最关注的，调研客户的水平，能力，企业环境）\n4. 其他可行性：法律，社会行为\n  \n如果团队内部缺乏某些技术，可以采用的手段：  \n培训（内培）：团队能力的提升  \n招募：得到知识（不能确保事业的连续）    \n外包：专业的人做专业的事（降低成本），不易获取知识  \n财务分析：  \n静态：不需要考虑资金的时间价值，【关键字：期】  \n动态：考虑资金的时间价值 【利率，CPI】 【关键字：率，现，净】  \n计算回收期的时候，从投入的时候开始计算    \n\n<br />  \n\n可行性研究的过程：\n1. 机会研究【自运营重要】  （可省略）\n2. 初步可行性研究（级别）  （可省略）\n3. 详细可行性研究（量化）  （不可省略）\n4. 形成《可行性研究报告》进行论证   \n\n<br />\n中标后首先签合同，发布项目章程(授权PM)       \n<br />    \n\n### 需求管理：  \n需求分为需求工程（实际）和需求管理（管理）  \n### 需求的层次：  \n招投标文件+合同（用户的高层需求）-》SOW（产品需求）-》需求规格说明书（功能+性能+安全需求）  \n\n### 需求工程的过程\n1. 需求获取：充分，多层次都需要调研《用户需求说明书》\n2. 需求分析：建模，解决冲突（信息的使用者优先原则，优先满足信息使用者的需求）\n3. 需求定义：形成《需求规格说明书》，无歧义的多方签字认可的，具有法律效力的正式文档\n4. 需求验证：通过需求文档和产品能够双向追踪（需求的跟踪矩阵）\n     \n需求定义：产生了需求基线（基线需要改变，必须按照变更流程实施)  \n已定义，已实现，已删除  \n\n### 需求管理：\nPDCA，规划（定宗旨、造标准、如何指导后续工作），理解，承诺，管理变更（流程），维护需求的跟踪\n  \n企业的层次：高层战略+中层管理+基层操作+底层产品层\n\n# Class6  \n\n### 需求：    \n需求工程  \n需求管理：PDCA（规划、理解、承诺、变更、监控【双向跟踪】）\n立项：可行性研究（机会、初步、详细【报告】、论证）  \n可行性：技术、经济、运行、其他（法律、社会行为）  \n### 范围管理  \n范围完成项目所需要做的仅需要做的工作或活动\n范围管理特别适用于波动式计划【1、范围来自于需求的抽象描述  2、整体管理中已经生成了初步范围说明书】--》项目的范围应该是逐步细化的而不是蔓延的  \n### 范围管理的流程PDCA  \n规划：（定宗旨，选标准【符合自身】，指导后续工作）  \n定义：产生《范围说明书》--【干系人以及期望，假设以及约束，活动和产品的描述】--》作为后续工作的万能输入（范围基线【范围说明书+WBS+WBS字典】）  \nWPS（*）：  \n1. 工作分解结构，作用：将项目分解为更小更易于管理的单元，便于控制和管理，类似于WBS的OBS（组织），RBS（风险），RBS（资源），BOM（物料清单）   \n2. 依据和形式：层次化的树形结构（直观，如果对于大项目不合适（分级控制）），矩阵表格（目录），文本形式（详细描述，WBS字典--负责人，工作的描述，衔接））    \n3. 控制账号：WBS每个节点的控制单元，每个工作包只属于一个控制好，符合RACI模式，每个单元只有一个人负责  \n4. WBS划分规则：\n   1. 每个分支可以选择不同的划分方法（每个分支的划分方法尽量相同）\n   2. 可以按照交付物、周期、组织结构（超大型项目）\n   3. 外包工作需要纳入WBS\n   4. WBS的层次建议3-5层\n   5. 最小的工作包（叶子结点）建议80人时，1人两周工作量（周期性的安排监控点）    \n5. 步骤：  \n   1. 明确项目的范围\n   2. 选择合适的形式\n   3. 划分（分解）\n   4. 分配具体的控制账号\n   5. 通过评审  \n   \n确认（内部） ：  核心确保范围和需求一致 \n监控  CA  ：控制变更，纠偏  \n确认  （外部）：用户验证，确保范围的实现和用户的目标一致  \n\n质量控制和范围确认：    \n质量控制（内部）主要的目的是检测交付物满足标准的程度  \n范围确认（可内可外，一般强调外部）主要目的是检测交付物是否符合用户的期望  \n一般情况质量控制先于范围确认  \n\n\n作业：根据WBS模板，创建一个单月内学习计划\n\n# class 7\n### 范围管理\n完成项目目标所需仅需做的工作\n\n流程PDCA：规划=》定义【范围说明书】=》WBS（WBS字典）=》范围确认（内部）=》范围控制=》范围确认（客户）\n\n### 进度管理（周期管理），时间管理  \n流程：PDCA  \n活动定义：识别完成项目所需要的活动【借鉴WBS并更新】  \n活动排序：确定依赖关系【找到活动的前置后置逻辑关系】  \n活动资源估算：结合PMO提供的资源日历，确定资源的有效性。使用资源可以适当的评估历时  \n \n活动历时估算：  \n制定进度计划P：创建进度基线，需要调整，适用于合同  \n1. 关键路径CPM，完成项目所有目标的最长路径，CPM可以有多条，非关键路径上的调整会影响到CPM，关键活动没有自由时间  \n2. 图示技术调整进度【进度压缩】   \n进度控制CA:    \n\n#### 常见逻辑关系：  \n结束开始： FS，最常见  \n结束-结束：FF，  \n开始-结束：SF，后置活动开始，前置活动才结束（升级）  \n开始-开始：SS，并行    \n\n### 网络图示技术表示：\n1. 单代号网络图：AON,PDM前导图，节点表示工作，线表示逻辑关系（只能表示FS关系），节点可以通过不同的图示详细表示\n2. 双代号网络图：AOA，箭线图：节点表示关键点，线表示工作或活动，虚线表示虚活动（仅用来表示前后逻辑关系，不消耗任何资源）  \n3. 时标网络图：用于进度分析\n4. 甘特图：一般用日历日期表示，用于汇报，核对进度，缺陷不能表示复杂的逻辑关系\n\n  \n### 活动历时估算：  \n最直接：工作量/工作效率，弊端（理想化）  \n参数估算：计算沟通渠道  \n三点估算PERT：（乐观、悲观、可能）   \n正态分布：3个标准差的分布概率：68、95、99\n\n# class 8  \n进度（活动定义--识别WBS--》 排序--依赖逻辑 （FS)PDM，ADM，时标网络图，甘特图--》，资源估算【PMO资源日历】--》历史估算）  \n\nA\n\nB\n\nC\n\n如果多个工作串行方式安排，标准差 =  sqrt（方差之和 ===  所有标准差的平方之和）  \nsqrt 是开平方  \n压缩工期时需要注意：  压缩比例越大成本以指数级上升\n\n进度+成本+资源  \n\n成本管理（EVT）\n\n# class 9    \n进度偏差：用户引发（缩范围--先实现核心功能，多期开发），加资源（时间-团队管理混乱，成本，人手-经验丰富），适当并行（快速跟进）  \n\n图示--计算（查看状态、预知未来)  \n\n\n## 成本管理PDCA    \n流程：\n1. 成本计划：估算、预算、管理、监督、控制项目成本的过程  \n   ------------项目管理（风险、质量提前介入），风险管理计划是输入之一\n2. 成本估算：求得一个近似成本，识别成本项，找到可替代成本，确认成本值的质量（类别--每个项目都是不同的，外界因素干扰。自下而上的估算-WBS汇总，质量成本，储备分析--应急储备，管理储备）\n3. 成本预算：建立成本基线（基线），规划管理储备和项目资金预算，再将预算额度具体对应到活动中，（成本预算不是分配资金）\n4. 成本控制\n  \n成本投入过程对于软件项目：实施阶段比重最大，累计投入成本，估算值+应急储备构成成本基线  \n\n应急储备：介于成本基线和估算值之间的值，主要是应对已知风险，需要实现挣值管理（PM可调用，负责）  \n管理储备：项目预算（资金准备量）和成本基线之间的储备值，用于应对未知风险（PM不能把控），绩效考核中不纳入对PM的考核中，PM不可调用，PMO提供使用\n\n挣值分析EVT技术：  \n\nPM不关心任何利润，在成本基线的约束下完成项目目标  \n\nEVT几个基础值：\n1. 计划值：PV，规划中的预计值，总的PV也叫做BAC，如果没有特别说明当前PV，则PV为BAC/周期\n2. 实际成本：AC，已经支出的成本\n3. 挣值：EV，已创造的产品的价值\n  \n状态判断的基本模式  \nCV成本偏差 EV-AC  \nSV进度偏差 EV-PV    \nCPI成本绩效指数 EV/AC  \nSPI进度绩效指数 EV/PV\nCV,SV<0代表超支超时，>0代表节约提前   \nCPI,SPI<1代表超支超时，>1代表节约提前  \n一个项目的PV大于AC不代表项目节约  \n\nCV和SV主要用于判断状态，不用于多项目比较    \n预测未来  \nETC完工尚需成本：\n1. 典型偏差：偏差继续 ETC=(BAC-EV)/CPI\n2. 非典型偏差：消除偏差，回归原始计划 ETC=BAC-EV  \n     \nEAC完工总成本：EAC=ETC+AC\n\n\n\n\n\n\n\n\n\n\n\n'),(18,'Nginx学习笔记（基本操作篇）',1,'2021-05-07 06:48:01',83,'之前在理论篇中简单学习了一些必要的Nginx相关知识，在实际运用中，我们还需要熟悉相关的操作，本篇从安装开始，记录常用的Nginx操作。\n> 环境：\n> * CentOS 8.0 64bit with ARM　　\n> * Nginx 1.14.1  \n\n## 安装  \n### Yum\n首先简单介绍Yum（Yellow dog Updater, Modified），是一个在Fedora和RedHat以及CentOS中的Shell前端**软件包管理器**。 基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。（PS：如果上面过于官方的介绍不好理解，那么可以把yum简单的理解为CentOS中的npm。）  \n\n## 使用yum安装  \n\n```bash\nyum install nginx\n```\n\n之后可通过`nginx -v`来判断是否安装成功\n> tips:  \n> 可通过`whereis nginx`查找Nginx所有文件，如果之前安装过Nginx，可直接删去找到的文件后重新下载  \n\n## 命令行基本参数  \n   \n安装成功后，首先要学习Nginx命令行的基本命令\n\n1. `nginx -t` #测试配置文件是否有语法错误\n2. `nginx -s reopen` #重启Nginx\n3. `nginx -s reload` #重新加载Nginx配置文件，然后以优雅的方式重启Nginx\n4. `nginx -s stop` #强制停止Nginx服务\n5. `nginx -s quit` #优雅地(gracefully)停止Nginx服务（即处理完所有请求后再停止服务）\n6. `nginx -c [配置文件路径]` #为 Nginx 指定配置文件\n\n如果不指定配置文件，Nginx默认配置文件在`/etc/nginx/nginx.conf`，\n\n配置文件内包括`events`区块和`http`区块，`http`区块包含一个或多个`server`区块，`server`区块包含一个或多个`location`区块。  \n\nNginx目录结构下包括上文提到的`nginx.conf`以及一个conf.d文件夹，conf.d文件夹下包括Nginx所有配置文件目，`nginx.conf`中会包含conf.d文件夹内的所有配置文件块。\n\nnginx包含由配置文件中指定的指令控制的模块。 指令分为简单指令和块指令。 一个简单的指令由用空格分隔的名称和参数组成，并以分号（;）结束。 一个block指令与简单的指令有相同的结构，但不是以分号结束，而是以一系列由大括号（{和}）包围的附加指令结束。 如果一个block指令在大括号内可以有其他的指令，它就被称为一个上下文（例如：events，http，server和location）。\n\n不考虑其他正向代理、负载均衡等功能，一般我们要部署一个前后端分离的项目，只需要在http模块下的一个server块中加入我们要部署的站点信息以及对应的配置即可。  \n下面给出一个简单的配置案例。  \n```nginx\nserver {\n    listen 80;  # 监听80端口\n    server_name www.foril.fun;  # 域名符合的才能匹配进去\n    location / {    # 请求地址（正则）\n    root /aaa/bbb;  # 相应文件的根目录\n    index index.html index.htm; # 在以上根目录下默认的响应文件\n    gzip on;    # gzip压缩启动\n    gzip_min_length 1k;\n    gzip_buffers 4 32K;\n    gzip_http_version 1.1;\n    gzip_comp_level 3;\n    gzip_types text/css application/javascript;\n    gzip_vary on;\n    }\n}\n```\n\n\n### 接下来列出其内容并加以注释。\n> 内容很多，作为文档参考使用。  \n> 来自W3Cschool[1]  \n\n```nginx\n######Nginx配置文件nginx.conf中文详解#####\n\n#定义Nginx运行的用户和用户组\nuser www www;\n\n#nginx进程数，建议设置为等于CPU总核心数。\nworker_processes 8;\n \n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log /usr/local/nginx/logs/error.log info;\n\n#进程pid文件\npid /usr/local/nginx/logs/nginx.pid;\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n# event 模块的主要功能就是，监听 accept 后建立的连接，对读写事件进行添加删除。\nevents\n{\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\n    #补充说明：\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\n    #A）标准事件模型\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\n    #B）高效事件模型\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\n    use epoll;\n\n    #单个进程最大连接数（最大连接数=连接数*进程数）\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。\n    worker_connections 65535;\n\n    #keepalive超时时间。\n    keepalive_timeout 60;\n\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\n    #分页大小可以用命令getconf PAGESIZE 取得。\n    #[root@web001 ~]# getconf PAGESIZE\n    #4096\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\n    client_header_buffer_size 4k;\n\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n    \n    #这个是指多长时间检查一次缓存的有效信息。\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\n    open_file_cache_valid 80s;\n\n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\n    open_file_cache_min_uses 1;\n    \n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误.\n    open_file_cache_errors on;\n}\n \n \n \n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp\n{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n\n    #默认文件类型\n    default_type application/octet-stream;\n\n    #默认编码\n    #charset utf-8;\n\n    #服务器名字的hash表大小\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\n    server_names_hash_bucket_size 128;\n\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\n    client_header_buffer_size 32k;\n\n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\n    large_client_header_buffers 4 64k;\n\n    #设定通过nginx上传文件的大小\n    client_max_body_size 8m;\n\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\n    sendfile on;\n\n    #开启目录列表访问，合适下载服务器，默认关闭。\n    autoindex on;\n\n    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n     \n    tcp_nodelay on;\n\n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n\n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;    #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n\n\n\n    #负载均衡配置\n    upstream jh.w3cschool.cn {\n     \n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n     \n     \n     \n    #虚拟主机的配置\n    server\n    {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.w3cschool.cn w3cschool.cn;\n        index index.html index.htm index.php;\n        root /data/www/w3cschool;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n         \n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n         \n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n         \n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n        \'$status $body_bytes_sent \"$http_referer\" \'\n        \'\"$http_user_agent\" $http_x_forwarded_for\';\n         \n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n         \n        #对 \"/\" 启用反向代理\n        location / {\n            proxy_pass http://127.0.0.1:88;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n             \n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n             \n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n         \n         \n        #设定查看Nginx状态的地址\n        location /NginxStatus {\n            stub_status on;\n            access_log on;\n            auth_basic \"NginxStatus\";\n            auth_basic_user_file confpasswd;\n            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n        }\n         \n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n         \n        #所有静态文件由nginx直接读取不经过tomcat或resin\n        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|\n        pdf|xls|mp3|wma)$\n        {\n            expires 15d; \n        }\n         \n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n    }\n}\n######Nginx配置文件nginx.conf中文详解#####\n```\n\n## 参考：\n- [1] [W3Cshool：Nginx 配置文件nginx.conf中文详解](https://www.w3cschool.cn/nginx/nginx-d1aw28wa.html)\n'),(19,'Linux环境变量学习：su和su - 的区别',1,'2021-05-08 14:00:32',43,'之前一直没有注意过Linux切换身份的命令的不同，也没有注意过不同用户的环境变量问题。以为`su xxx`和`su - xxx`是同一个方法，直到有一次在运行hadoop时，发现找不到命令。明明记得在环境变量里加入过，但是`echo`也没打印出来~~，我一脸懵逼~~。后来在排除下发现是并没有在全局配置环境变量，而是配在了当时用户的环境变量下，后来也没有搞明白`su`和`su - `不同用法，导致了问题的产生。  \n所以在理解这两个命令的区别之前，应该首先搞明白另一个概念。  \n\n## Linux环境变量  \nLinux是一个多用户多任务的操作系统，所以像我们在Windows中配置环境变量可以选择 *全局变量* 和 *用户变量* 一样，Linux也有不同上下文的环境变量。  \n### 环境变量的分类  \n* 按照生命周期来分：  \n1. **永久的**：需要用户修改相关的配置文件，变量永久生效。\n2. **临时的**：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。\n\n<br />\n\n* 按照作用域来分：\n1. **系统环境变量**：系统环境变量对该系统中所有用户都有效。\n2. **用户环境变量**：顾名思义，这种类型的环境变量只对特定的用户有效。\n\n### 设置环境变量  \n\n* 在/etc/profile文件中添加变量 对所有用户生效（**永久的**）\n\n* 在用户目录下的.bash_profile文件中增加变量 【对单一用户生效（**永久的**）】\n\n* 直接运行export命令定义变量 【只对当前shell（BASH）有效（**临时的**）】\n\n这里还有一篇讲解很详细的参考文章：[Linux环境下不同脚本文件配置的环境变量作用域范围的区别](https://blog.csdn.net/highfly591/article/details/42497007)  \n\n<hr />\n\n在解决了以上的问题后，来到我们的下一个话题：`su xxx`和`su - xxx`的区别。  \n\n先说结论，su命令和su -命令最大的本质区别就是：\n- 前者只是切换了root身份，<u>但Shell环境仍然是普通用户的Shell</u>；\n- 而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。\n\n我们查看su的帮助文档可以发现：\n\n```bash\n -, -l, --login                  make the shell a login shell\n```\n\n**区别就是**  \nlogin shell：此种方式登录时，shell会重新读取/etc/profile和~/.bash_profile来应用新的环境变量。\n\nnon-login shell：此时shell不会读取 `/etc/profile` 和 `~/.bash_profile`，而是读取 `~/.bashrc` 来应用新的环境变量。\n\n到这里，我们就解决了我们的问题，区分了`su xxx`和`su - xxx`的区别。\n\n\n## 参考：\n- [1] [简书：Linux环境变量总结](https://www.jianshu.com/p/ac2bc0ad3d74)\n\n- [2] [CSDN：login shell和non-login shell](https://blog.csdn.net/zzzhktk/article/details/8221133)\n\n- [2] [CSDN：su 和su -的区别](https://blog.csdn.net/nayanminxing/article/details/76424115)\n'),(21,'专题：动态规划',3,'2021-05-15 04:08:03',140,'之前刷力扣都在刷日题，一段时间后感觉刷题有一点感觉了，但是收获不是很系统，近期决定做一段时间的专题，第一个专题就决定是动态规划。  \n\n## 定义  \n动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。\n以上是百度给出的定义，~~没什么参考价值~~其实按我个人理解，动态规划是一种用空间换时间的策略，记录之前的结果，状态转换方程利用之前的结果，然后快速得到答案。  \nDP的思想与分治法类似，都是把待求解的问题分解为多个子问题，不同的是适用于DP的问题往往不是互相独立的，有些子问题会被重复计算很多次。DP的做法是这些**已经解决的子问题答案保存下来**。\n\n### 引例：\n斐波那契数列\n```cpp\nint Fibonacci(int n) {\n	//0,1,1,2,3,5,8,...\n	//返回数列中第n个数\n	if(n==1 || n==2) return n-1;  //边界情况\n	int dp[n];  //记录方式\n	dp[0] = 0, dp[1] = 1;   //初始化\n	for(int i = 2; i<n; i++) {  //运算顺序\n		dp[i] = dp[i-1] + dp[i-2];  //状态转换方程\n	}\n	return dp[n-1];\n}\n```\n这个题目就是利用了简单的DP思想，是实际上这个题不需要数组，因为只用到了`dp[i-1]`和`dp[i-2]`，且最后不需要遍历找出最优，可以直接用两个变量代替，类似“滚动数组”。  \n\n\n## 核心问题\n\n对于动态规划的核心问题，我个人总结为4点：  \n1. 找到合适的记录方式  \n2. 找到状态转换方程\n3. 找到初始方法  \n4. 找到运算顺序  \n\n展开来谈：  \n### 找记录方式\n之前说DP以空间换时间，实际上就是指DP记录之前的运算结果并运用到新的计算当中。这就要求能够找到合适的记录方法，利用合适的记录方法将之前结果保存下来。 \n\n在近期刷题的经验中，发现DP会有很大概率**与字符串相关**，例如：  \n- [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n- [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n- [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n\n等等，都是DP的经典题目，实际上还会包括一些类似背包题目的其他问题。\n\n通常，DP会利用二维数组`dp[i][j]`记录从i到j的某些结果，或是一维数组`dp[i]`表示以`i`为开头或结尾的一些结果，之后按一定顺序转移计算。  \n\n其中需要**注意题目中给出的变量的范围**，我自己就遇到过选择了过大的二维数组然后发生溢出的错误。\n\n### 找到状态转换方程  \n决定了DP的记录方式以后，便需要通过对题目观察找到巧妙的状态转换方程，举个例子，一般`dp[i][j]`的转换方程可能利用到`i+1`、`j-i`这样的邻近结果，所以一般寻找时也需要从假设已知的状态写起。同时，要注意很多题目中状态转换方程存在条件变化，在不同的条件情况（例如`str[i]==str[j]`和`str[i]!=str[j]`）下，状态转换方程也会有所不同。  \n\n### 找到初始化方法\n有了状态转换方程，初始化方法就会比较轻松，一般是找到一些边界值，例如长度为`n`的字符串，常常会定义`n+1`的数组，下标0对应边界值；或是找到一些规律，例如二维数组***对角线***上的值和***边界***的值。这个过程往往需要从状态转换方程中找到灵感。\n\n### 找到运算顺序  \n同样，有了状态转换方程，运算顺序也比较好判断，假设`dp[i][j]`记录从i到j是否回文，实际上我们只用到了上三角的部分，有状态转换方程：    \n```\ndp[i][j]=dp[i+1][j-1] && str[i]==str[j]\n```  \n其中对角线的值为初始值，要知道`dp[i][j]`，实际上就是找对应矩阵上三角中 ***下一行前一列*** 的值。  \n在`i`固定的前提下，要确定`j`，就需要知道它前一个值，所以`j`的顺序必然是从前到后；  \n而对每一个`i`，要知道他的后一个值，所以应当从后往前运算。  \n之后就是实际的运算过程，在这个过程中，还需要注意一些边界情况。\n![DP例子示意图](https://img.foril.fun/DP.jpg)\n\n\n\n## 能用动态规划解决问题的特点[1]  \n动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。  \n\n能采用动态规划解决的问题，一般要具有三个性质：\n\n1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。\n\n2. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。\n\n3. 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）\n\n\n在理解了以上要点后，个人觉得就应该多刷题去总结自己的经验了。  \n\n## PS  \n何时使用**回溯**，何时使用**动态规划**：    \n\n* 首先看取值范围，递归回溯一维数组，100就是深度的极限了   \n* 迷宫的***路径***是回溯； 迷宫的***路径的条数***用dp\n\n屡试不爽\n\n\n---\n\n## 参考：\n- [1] [知乎：动态规划](https://zhuanlan.zhihu.com/p/126361983)'),(22,'写于210516',2,'2021-05-16 03:25:32',47,'大概是大二的时候萌生了自己写一个博客的想法，记录平时解决一些问题的方法和学习新东西的笔记，但总觉得忙于学习和其他项目，没有机会真正落地。20年底，终于下定决心开始做，最初写了一版样式，在网上与别人的博客一比较，觉得排版很一般而且做得花里胡哨的。在第二个版本重新调整后有了现在的样式。  \n中途因为考试与课程，搁置了一段时间。到了四月份的时候心想不能再拖了，火速完成了前端，飞速写了一版简单的后端，说实话后端非常简陋，甚至没有用到ORM直接手撸了SQL，但至少是完成了基本功能。可结束后心里一直觉得不爽，想要 ~~重构~~ 重写一个版本。算是在这里立下一个Flag。  \n\n---\n\n*网站在四月份上线，写下这篇博客时学校的紫藤萝都开得差不多了。*  \n\n2021年五月，对我而言又是一个交叉路口，要面对保研升学的压力。本来没有想过保研的事情，觉得不用准备很多，随缘就好，最近突然有了压力，毕竟人人都想去一个更高的平台。  \n几天前刚刚结束了一门必修考试，考完才想到可能是本科阶段最后一门考试了（之后的课程大都是大作业的形式）。大三学业相比之下是轻松了不少，有了更多的时间去做自己想做的事。  \n随笔写下本篇，想到哪里就写到哪里，如果真的有读者看到这里，请不要在意我的语无伦次。  \n\n>向光生长'),(23,'Nginx上的HTTPS配置相关内容',1,'2021-05-17 13:57:15',78,'算上之前配的内网服务器，这应该是第三次配置HTTPS了，但每次或多或少都要搜索一些资料和配置说明，这次直接写在博客里，以供之后翻阅查找信息。  \n## 简单原理\nHTTPS 协议是由 **HTTP 加上 TLS/SSL 协议** 构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。  \n有HTTPS的加持，我们的网站传输的数据多了三道安全保证：  \n* 数据保密性  \n* 数据完整性\n* 身份校验安全性  \n\n有了HTTPS协议，浏览器与服务器之间的交互大概可以概括为一下几个过程。  \n\n1. 客户端向服务端发起建立HTTPS请求。\n\n2. 服务器向客户端发送数字证书。\n\n3. 客户端验证数字证书，证书验证通过后客户端生成**会话密钥**（双向验证则此处客户端也会向服务器发送证书）。\n\n4. 服务器生成会话密钥（双向验证 此处服务端也会对客户端的证书验证）。\n\n5. 客户端与服务端开始进行加密会话（通过会话密钥加密）。\n\n## SSL证书申请\n\n这一步实际上可以通过你的域名提供商申请一个SSL证书，对于大多数网站来说，申请个人免费的证书已经绰绰有余了，CA会使用生成一对服务器的公私钥，然后用CA的私钥加密服务器的公钥得到公钥证书，最后将公钥证书颁发给你。  \n\n经过上面的操作，我们就可以得到公钥证书以及服务器的私钥，这里我们就可以配置HTTPS协议的网站了。\n\n> 本站使用的是腾讯云颁发的免费SSL证书，要注意免费的SSL证书不能使用通配符域名，可以是一级域名或者二级域名。  \n\n## Nginx 配置\n\n一般得到SSL证书后，可以根据服务器的类型不同选择不同的证书类型下载。选择Nginx服务器下载证书后，会得到 `.key` 文件和 `.pem` 文件，分别是你的私钥文件和公钥证书文件。**（私钥文件一定不要泄露出去）**  \n\n之后，我们可以将这两个文件放在Nginx的配置文件目录下（例如`/etc/nginx`，也就是有`nginx.conf`的目录下）。  \n这里我们在`nginx.conf`的同级目录下新建一个`cert`文件夹，将两个文件放进去，之后只需要更改Nginx的配置文件指定公私钥的位置即可。  \n\n例如：\n```nginx\nserver {\n listen 443; # 监听443端口\n server_name localhost; # 这里放对应的域名\n ssl on;\n root html;\n index index.html index.htm;\n ssl_certificate   cert/a.pem; # 这里对应公钥证书文件\n ssl_certificate_key  cert/a.key; # 这里对应私钥文件\n ssl_session_timeout 5m;\n ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; # 需要根据你的 openssl 版本支持的算法套件来配置\n ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n ssl_prefer_server_ciphers on;\n location / {\n     # 这里就是你自己的location块设置\n     root html;\n     index index.html index.htm;\n }\n}\n```\n\n### HTTP请求转发\n可以在配置中多加入一个server块，监听80端口，并将请求转发给HTTPS的URL。\n```nginx\nserver {  \n    listen 80;  \n    server_name www.wenhaofan.com;  \n       \n    rewrite ^(.*)$  https://$host$1 permanent;  \n}\n```\n或者还有一个方法，直接在443的server块中同时监听80端口，并加入\n```nginx\nif ($scheme = http) {\n    return 301 https://$server_name$request_uri;\n}\n```\n将请求转发。\n\n## 其他\n这里记录一些遇到的因为不太理解导致的比较坑的过程以及对应的解决方法。  \n\n### 关于重定向次数过多\n在刚配完HTTPS并部署重启后，出现了后端请求失败，错误代码 `ERR_TOO_MANY_REDIRECTS` 重定向过多的情况，最后解决发现是出现cookie重定向网站，清除浏览器数据后，重新访问发现问题解决。\n\n### 关于HTTP资源请求失败\n在解决了以上问题后，访问一些博客内容发现用来存放图片等资源的对象存储OSS资源全部失效，查看发现是图片内容被重定向到HTTPS请求。  \n\n之前Chrome对于HTTPS站点的HTTP子资源是提示不安全但不阻止，查阅资料后发现，从2020年 12 月开始测试的 Chrome 79 开始，Chrome 将会逐步阻止所有混合内容。到 2020 年 1 月，Chrome 80 会将所有混合音频和视频资源自动升级为 HTTPS，如果无法通过 HTTPS 加载，则将自动被阻止。最终，在 2020 年 2 月，Chrome 81 将所有混合图像、音频与视频自动升级为 HTTPS，并且阻止那些无法通过 HTTPS 加载的图像。\n\n这个问题可以通过设置Chrome允许不安全内容解决，但不可能要求所有人都不能用新版Chrome，并且不安全内容本身也是不安全因素。于是决定将OSS存储服务也升级HTTPS，因为用的是`img.`子域名CNAME记录的CDN加速服务，又单独申请了SSL证书，在服务提供商升级了HTTPS请求，代价就是1GB两毛八的额外流量费用，不过至少问题是解决了。\n'),(24,'专题三：回溯法',3,'2021-05-29 12:42:35',31,'回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  \n\n这里列出我接触的两个利用了典型的回溯思想解决的问题：\n* [96. 不同的二叉搜索树II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)　　\n* [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\n\n## 个人简单总结\n\n从这两个题中我个人感觉到的规律就是这类问题一般有 ***两种类型*** ：\n* 第一种相较于原问题是一个序列长度缩小的子问题，通过将一个根问题化解为若干个规模变小的子问题，便可以使用递归解决问题；  \n* 另一种一般对于每一个选项都可以选或者不选（或类似思路），一般会有 $O(2^n)$ 的时间复杂度。 \n \n在 **递归函数中** 需要注意的几点有：  \n1. 先定义判断结束的返回，即出口  \n2. 将问题化解为小问题（或是选或不选两个方向调用递归函数回溯）  \n3. 此时递归回溯阶段，之前的问题已经得到解决，在这里根据之前的结果加以处理返回  \n\n读者可以根据以上总结来阅读以下代码：\n```cpp\nclass Solution {\nprivate: \n    vector<TreeNode*> generateTrees(int start, int end){\n        //定义出口\n        if(start>end){\n            return {nullptr};\n        }\n        vector<TreeNode*> res;\n        for(int i = start ;i<=end;i++){\n            /****化解为小问题******/\n            vector<TreeNode*> lefts = generateTrees(start,i-1);//递归\n            vector<TreeNode*> rights = generateTrees(i+1,end);\n            /*******************/\n\n            //这里已经进入回溯阶段\n            //利用结果分解当前问题\n            for(auto left:lefts){\n                for(auto right:rights){\n                    TreeNode* node = new TreeNode(i, left, right);\n                    res.push_back(node);\n                }\n            }\n        }\n        return res;\n    }\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        //回溯法\n        return generateTrees(1,n);  //问题所求\n    }\n};\n```\n\n接下来是学习笔记。  \n\n## 定义\n回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。\n\n回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n\n> 白话：回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。  \n\n## 典型问题\n\n### N皇后问题\n\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。（不能处在同一行，同一列，同一条斜线）\n\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n\n在实际撰写的过程中，发现思路并不难，但想要写出高效的题解不是一件非常轻松的事情。  \n\n## 1239. 串联字符串的最大长度\n### 题目　　\n\n给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。\n\n请返回所有可行解 s 中最长长度。\n\n \n\n示例 1：\n\n输入：arr = [\"un\",\"iq\",\"ue\"]  \n输出：4  \n解释：所有可能的串联组合是 \"\",\"un\",\"iq\",\"ue\",\"uniq\" 和 \"ique\"，最大长度为 4。  \n示例 2：\n\n输入：arr = [\"cha\",\"r\",\"act\",\"ers\"]  \n输出：6  \n解释：可能的解答有 \"chaers\" 和 \"acters\"。  \n示例 3：\n\n输入：arr = [\"abcdefghijklmnopqrstuvwxyz\"]  \n输出：26\n \n\n提示：  \n* 1 <= arr.length <= 16\n* 1 <= arr[i].length <= 26\n* arr[i] 中只含有小写英文字母\n\n\n### 思路：\n这个题目就是上面所说两个类型中的第二个——对于每一个选项都可以选或者不选，这里专门贴出题目的范围：数组长度不超过16，每个句子长度不超过26，就是因为回溯对时间和空间的开销都很大，这里给出的数字并不大，所以我们可以考虑采用回溯的方法解决问题。  \n基本思路很简单，对于每个字符串，只有选择或者不选两种，时间复杂度为 $O(2^n)$ ，根据刚才总结的三步，定义出口，然后分选择和不选择分别递归，在这里由于是找到最大值，所以在判断出口的位置就可以完成比较，回溯部分没有任务。\n```cpp\nclass Solution {\n    void bt(set<char>& set, int & maxR, int index, const vector<string>& arr, int inh){\n        maxR = max(maxR, inh);\n        int len = arr.size();\n        if(index==len) return;\n        int i = 0;\n        std::set<char> single_set;   //单句子查重\n        for(;i<arr[index].length();i++){\n            if(set.find(arr[index][i])!=set.end() || single_set.find(arr[index][i])!=single_set.end()){\n                //有一种情况是一个句子里有重复单词\n                break;  //不能加\n            }\n            single_set.insert(arr[index][i]);\n        }\n        if(i==arr[index].length()){\n            //能加，加        \n            for(int i = 0;i<arr[index].length();i++){\n                set.insert(arr[index][i]);\n            }\n            bt(set, maxR, index+1, arr, inh+arr[index].length());\n            for(int i = 0;i<arr[index].length();i++){\n                set.extract(arr[index][i]);\n            }\n        }\n        bt(set, maxR, index+1, arr, inh);\n    }\npublic:\n    int maxLength(vector<string>& arr) {\n        set<char> set;\n        int maxR = 0;\n        bt(set, maxR, 0, arr,0);\n        return maxR;\n    }\n};\n```\n这里代码不太美观，下面给出官方题解简洁的题解。  \n主要思路是利用**回溯 + 位运算**，这里利用位运算排除重复字母是一个比较巧妙的思路。mask是作为形式参数传入，记录已经出现的字母位置，每个字符串有一个位数组记录，通过`相与`判断是否已经出现对应字母，通过`相或`来加入对应的字符串字母。\n```cpp\nclass Solution {\npublic:\n    int maxLength(vector<string> &arr) {\n        vector<int> masks;\n        for (string &s : arr) {\n            int mask = 0;\n            for (char ch : s) {\n                ch -= \'a\';\n                if ((mask >> ch) & 1) { // 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解\n                    mask = 0;\n                    break;\n                }\n                mask |= 1 << ch; // 将 ch 加入 mask 中\n            }\n            if (mask > 0) {\n                masks.push_back(mask);\n            }\n        }\n\n        int ans = 0;\n        function<void(int, int)> backtrack = [&](int pos, int mask) {\n            if (pos == masks.size()) {\n                ans = max(ans, __builtin_popcount(mask));   // 数出所有字母数量\n                return;\n            }\n            if ((mask & masks[pos]) == 0) { // mask 和 masks[pos] 无公共元素   加入字符串（选择的情况）\n                backtrack(pos + 1, mask | masks[pos]);// 注意这里传入的是形参，mask没变，还是没有加入当前字符串的状态\n            }\n            backtrack(pos + 1, mask);   //（不选择）的情况\n        };\n\n        \n        backtrack(0, 0);\n        return ans;\n    }\n};\n```\n'),(25,'位运算符相关技巧',3,'2021-05-30 01:49:46',86,'这里想记录一些在做题过程中遇到的位运算相关技巧。\n\n## 二进制表示中最低位\n在位运算相关的题目中，有很多会与位 1 的个数相关。这里有个相关的小技巧。\n\n```cpp\nn & (n-1)\n```\n\n通过以上表达式可以将数 `n` 二进制表示的最低位 1 移除。原理是最低位1后会跟一些0，记最后一位 1 前的高位为 $a$ （`n`为2的幂时全为0），`n` 即 $a10000_2$  ，而`n-1`为 $a01111_2$ ，这两数相与便可以将最后一位 1 移除，而其他位 1 不受影响。\n\n这个技巧可以运用在很多地方，比如我们想统计数`n`中`1`的数量。  \n可以直接让`n`与`n-1`相与，直到`n=0`。代码如下：\n```cpp\nwhile (n) {\n    n &= n - 1;\n    ret++;\n}\n```\n## 判断是否是2的幂\n利用  \n```cpp\n(n&(-n))==n\n```\n可以用来判断正整数`n`是否是2的幂，利用计算机补码知识，可以知道`-n`即为`n`所有位取反加一，记最后一位 1 前的高位为 $a$ （`n`为2的幂时全为0），`n`即 $a10000_2$ ，而 `-n` 为 $\\overline{a}01111 + 1$ ，即 $\\overline{a}10000$ ，所以当`n`为2的幂时， `n` 和 `-n` 相与后仍然得到 `n` 。\n\n## 注意\n在进行位运算时，要时刻注意位运算优先级较低，以上面判断是否是2的幂为例，应该使用  \n```cpp\n(n&(-n))==n\n```\n而不是\n```cpp\nn&(-n)==n\n```\n\n后者会先运算 `(-n)==n` 。  \n\n附上c++运算符优先级表:\n\n| 优先级 | 运算符              | 类          | 结合性  |\n|-----|------------------|------------|------|\n| 1   | ( )              | 括号运算符      | 由左至右 |\n| 1   | [ ]              | 方括号运算符     | 由左至右 |\n| 2   | !、 +(正号)、 - (负号) | 一元运算符      | 由右至左 |\n| 2   | ~                | 位逻辑运算符     | 由右至左 |\n| 2   | ++、–             | 递增与递减运算符   | 由右至左 |\n| 3   | *、/、%            | 算术运算符      | 由左至右 |\n| 4   | +、-              | 算术运算符      | 由左至右 |\n| 5   | <<、>>            | 位左移、位右移运算符 | 由左至右 |\n| 6   | >、>=、<、<=        | 关系运算符      | 由左至右 |\n| 7   | ==、!=            | 关系运算符      | 由左至右 |\n| 8   | &(位运算符AND)       | 位逻辑运算符     | 由左至右 |\n| 9   | ^(位运算负号XOR)      | 位逻辑运算符     | 由左至右 |\n| 10  | \\| (位运算负号OR)      | 位逻辑运算符     | 由左至右 |\n| 11  | &&               | 逻辑运算符      | 由左至右 |\n| 12  | \\|\\|               | 逻辑运算符      | 由左至右 |\n| 13  | ?:               | 条件运算符      | 由右至左 |\n| 14  | =                | 赋值运算符      | 由右至左 |\n\n'),(27,'力扣刷题笔记（三）',1,'2021-06-05 12:04:15',54,'第三篇刷题笔记 。  \n\n## 40. 组合总和 II\n\n### 题目　　\n\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n所有数字（包括目标数）都是正整数。\n解集不能包含重复的组合。 \n\n**示例 1:**\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n\n[  \n  [1, 7],  \n  [1, 2, 5],  \n  [2, 6],  \n  [1, 1, 6]  \n]  \n\n**示例 2:**\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n\n[  \n  [1,2,2],  \n  [5]  \n]  \n\n### 思路：\n这一题和上一题的不同在于有了**重复的数字**，上一个题中所有数字是排好了序的。这就会出现一部分结果相同但顺序不同的相同解重复的问题。  \n比如：`[1, 7] 和 [7, 1]`。这一点比较麻烦，我个人的题解中，是通过先将所有数字排序，这样相同的数字会在一起，就不会出现`[1, 7] 和 [7, 1]`这种情况，再利用set来除重，就有了这一种虽然低效但是也可用的解法。\n\n```cpp\nclass Solution {\nprivate:\n    set<vector<int>> ans;\n    void bt(vector<int>& v, int index, int remain, vector<int>& candidates){\n        if(remain==0){  //合格出口，加入结果\n            ans.insert(v);\n            return;\n        }\n        if(remain<0){   //不合格题解\n            return;\n        }\n        for(int i = index+1;i<candidates.size();i++){\n            v.push_back(candidates[i]); //加入当前数字，继续回溯\n\n            bt(v, i, remain-candidates[i], candidates); //递归试探\n\n            v.pop_back();   //试探结束后，为了继续使用其他数字，需要把影响复原，即再弹出当前数字。不用在意bt函数里进行了什么操作，只需要把当前自己加进去的数字删除即可\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<int> v;\n        bt(v, -1, target, candidates);\n        vector<vector<int>> ret;\n        ret.assign(ans.begin(), ans.end());\n        return ret;\n    }\n};\n```\n\n## 46. 全排列\n### 题目　　\n\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n\n示例 1：\n\n输入：nums = [1,2,3]  \n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  \n\n### 思路：\n按照我个人的思路，也是典型的回溯算法几个重要特征。\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    void backTrack(vector<int>& unused, vector<int>& shape ){\n        if(unused.size()==0){   //出口条件\n            res.push_back(shape);\n            return;\n        }\n        for(int i = 0;i<unused.size();i++){ \n            //加入当前数字需要做的变化\n            int tmp = unused.at(i);\n            unused.erase(unused.begin()+i);\n            shape.push_back(tmp);\n\n            backTrack(unused, shape);   //继续试探\n\n            //撤销所有影响\n            shape.pop_back();\n            unused.insert(unused.begin()+i, tmp);\n        }\n    } \n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<int> shape;\n        backTrack(nums, shape);\n        return res;\n    }\n};\n```\n\n\n## 542. 01 矩阵\n### 题目　　\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 。\n\n\n**示例 1：**\n\n输入：  \n[[0,0,0],  \n [0,1,0],  \n [0,0,0]]  \n\n输出：  \n[[0,0,0],  \n [0,1,0],  \n [0,0,0]]  \n\n### 思路：\n这个题一拿到手感觉像是动态规划的问题，但是每一个点的最小值可能是其上下左右四个值中最小值加一，我找不到合适的遍历方式，所以换了一个比较古怪的思路。\n### 方法一： \n所求答案矩阵`ans`和输入矩阵`input`形状一样，记为`m*n`的矩阵，将`ans`的所有值初始化为`INT_MAX`，以此遍历`i, j`，到每一个格时更新他为 0 或者 上下左右四个方向上的最小值加一（比原来的位置上距离小），每一轮遍历如果有更新，则继续遍历，直到没有更新为止。  \n这个方法实际提交能过，但是由于每一次有更新都可能需要多轮遍历来发散开，收敛相对很慢。所以提交结果比较差。\n\n```cpp\nclass Solution {\npublic:\n    \n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int rows = mat.size();\n        int cols = mat[0].size();\n        vector<vector<int>> res(rows, vector<int>(cols,INT_MAX));\n        int directions[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n        while(1){\n            //一直遍历直到没有更新\n            int count = 0;\n            for(int i = 0;i<rows;i++){\n                for(int j = 0;j<cols;j++){\n                    if(mat[i][j]==0 && res[i][j]!=0){\n                        res[i][j] = 0;\n                        count++;    //有更新\n                    }\n                    else{\n                        for(int k = 0;k<4;k++){ //四个方向\n                            int next_i = i+directions[k][0];\n                            int next_j = j+directions[k][1];\n                            if(next_i<0 || next_i==rows || next_j<0 || next_j==cols){\n                                continue;   //碰壁，下一个方向\n                            }\n                            if(res[next_i][next_j]!=INT_MAX && res[next_i][next_j] + 1 < res[i][j]){\n                                res[i][j] = res[next_i][next_j] + 1;    //更新最小值\n                                count++;    //有更新\n                            }\n                        }\n                    }\n                }\n            }\n            if(!count) break;  //没有更新\n        }\n        return res;\n    }\n};\n```\n\n### 方法二：动态规划  \n看了题解发现，虽然每一个格的的实际结果跟上下左右四个方向都可能有关系，但也可以通过动态规划解决这个问题，只需要分别考虑最近的 0 点在该点的**左上，左下，右上，右下**<u>四个方向上分别动态规划</u>，得到四个对应的`m*n`的矩阵，只需要每个点都取这四个矩阵中对应点的最小值，就可以得到最后的结果。\n```\n      |\n  zs  |  ys\n      |\n------1------\n      |\n  zx  |  yx\n      |\n```\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        // 初始化动态规划的数组，所有的距离值都设置为一个很大的数\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX / 2));\n        // 如果 (i, j) 的元素为 0，那么距离为 0\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    dist[i][j] = 0;\n                }\n            }\n        }\n        // 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1);\n                }\n                if (j - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1);\n                }\n            }\n        }\n        // 只有 水平向左移动 和 竖直向下移动，注意动态规划的计算顺序\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = 0; j < n; ++j) {\n                if (i + 1 < m) {\n                    dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1);\n                }\n                if (j - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1);\n                }\n            }\n        }\n        // 只有 水平向右移动 和 竖直向上移动，注意动态规划的计算顺序\n        for (int i = 0; i < m; ++i) {\n            for (int j = n - 1; j >= 0; --j) {\n                if (i - 1 >= 0) {\n                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1);\n                }\n                if (j + 1 < n) {\n                    dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1);\n                }\n            }\n        }\n        // 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = n - 1; j >= 0; --j) {\n                if (i + 1 < m) {\n                    dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1);\n                }\n                if (j + 1 < n) {\n                    dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1);\n                }\n            }\n        }\n        return dist;\n    }\n};\n\n```\n\n## 523. 连续的子数组和\n### 题目　　\n给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n\n* 子数组大小 至少为 2 ，且\n* 子数组元素总和为 k 的倍数。\n\n如果存在，返回 true ；否则，返回 false 。\n\n如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。\n\n### 思路：\n### 思路一：动态规划\n第一次提交，觉得这是一个动态规划题目，dp[i][j]记录从i到j的和。又根据题目，只要出现是k的倍数便可以停止遍历，不需要之前的结果，所以可以用两个变量分别记录上次结果（余数）和这次的数（余数），若为0便可以停止遍历。\n```cpp\nclass Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        int len = nums.size();\n        int before, curr;\n        //init\n        for(int i = 0;i<len;i++){\n            before = nums[i]%k;\n            for(int j = i+1;j<len;j++ ){\n                curr = (before + nums[j])%k;\n                before = curr;\n                if(curr == 0) return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n但是最后两个用例足有500KB，使用动态规划思想，时间复杂度为 $O(n^2)$ ，无法解决超时问题。\n\n### 思路二：前缀和 + 集合\n看到这个题目的关键字 **连续的** 、**数组和** ，应该想到利用前缀和，只需要分别计算从下标 0 到下标 i 的数组前缀和，只需要 $O(n)$ 的空间`sum[n]`，就可以知道任意从 a 到 b 的数组之和为`sum[b] - sum[a-1]`。这便是前缀和的思想。  \n值得注意的是一般从开头开始的序列需要减去值 0 ，我们可以通过开辟长度为`n+1`的数组或是初始化before变量为 0 来解决。\n```\n□□□□□□□□□\n-\n□□□□\n=\n    □□□□□\n```\n为了继续优化，我们考虑如果`sum[j] - sum[i]`即从`i+1`到`j`的数组和是`k`的倍数，则`sum[j]`和`sum[i]`的余数应该相同，可以使用一个**集合Set**来存放遇到过的所有余数，但要注意的是为了保证长度至少为2，我们应该在下一次遍历只后再放入上一次的余数结果。这样对于开头第一个数字，集合为空，对其他所有数字，看不到上一次的余数结果，就保证了长度至少为2。\n```cpp\nclass Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        int len = nums.size();\n        set<int> set;\n        int before = 0, curr;\n        for(int i = 0;i<len;i++){\n            curr = (before + nums[i])%k;\n            if(set.find(curr)!=set.end()) return true;\n            set.insert(before);\n            before = curr;\n        }\n        return false;\n    }\n};\n```\n\n## 416. 分割等和子集\n### 题目　　\n给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n### 思路：0-1背包问题\n容易想到的是，只需要判断是否能够从数组中选出一个子集使其和为原数组总和的一半即可。  \n因此将这个题转换为 `0-1背包问题` ，每个数字可以拿或者不拿，需要刚好凑够总和的一半。  \n\n### 最开始的判断\n先进行以下判断，之后才可以进行动态规划求解：  \n1. 总和 sum 是否为偶数，否则返回 false ，是偶数则令 target = sum/2\n2. 其中最大值是否大于 target ，是则直接返回 false ，如果没有这一步判断，在下面的动态规划中会导致下标访问直接溢出  \n\n### 动态规划\n创建二维数组 `dp[n][target+1]` ，包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。  \n**注意：** 需要 `target+1` 列来包括 `0~target`   \n\n```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);  //求和\n\n        //最开始的判断（防止溢出）\n        if(sum%2) return false;\n        int target = sum/2;\n        int maxNum = *max_element(nums.begin(), nums.end());\n        if(maxNum>target){\n            return false;\n        }\n\n        int len = nums.size();\n        vector<vector<bool>> dp(len,vector<bool>(target+1, false));\n        //初始化\n        for(int i =0;i<len;i++){\n            dp[i][0] = true;\n        }\n        dp[0][nums[0]] = true;\n\n        for(int i = 1;i<len;i++){\n            int num = nums[i];\n            for(int j = 1;j<=target;j++){\n                //状态转换方程\n                if(j - num <0){\n                    dp[i][j] = dp[i-1][j];\n                }else{\n                    dp[i][j] = dp[i-1][j] ||  dp[i-1][j-num];\n                }\n            }\n        }\n        //所需结果\n        return dp[len-1][target];\n    }\n};\n```\n\n## 525. 连续数组\n### 题目　　\n给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。\n\n### 思路：\n看到关键词 **“最长”** 、**“连续子数组”**， 可以想到本地可以使用 **前缀和+哈希表** 来解决。具体前缀和原理可参考上面 523. 连续的子数组和 。\n\n为了找到含有相同数量的 0 和 1 的最长连续子数组，可以使用一个变量 `count` 记录0和1的出现，见到1加一，见到的0减一。  \n也就是说，如果一个子数组 `[i,j]` 中 0 和 1 数量相同，这个区间的 `count` 应该为零，也就是 `count[j]-count[i-1] = 0` ，在实际的实现中，不需要数组来记录所有的count[i]，只需要使用一个哈希表，记录所有之前出现过的count，如果新的count在哈希表里，只需要比对是否是新的最大长度，否则就将这个count加入哈希表中。\n```cpp\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        int len = nums.size();\n        unordered_map<int, int> hashMap;\n        hashMap.insert({0,0});  //注意要加入初始值，如果使用数组保存，应该多声明一个，记录初始状态\n        int count = 0;\n        int max_num = 0;\n        for(int i =1;i<=len;i++){\n            //遍历每个数\n            if(nums[i-1]==1) count++;\n            else count--;\n            auto it = hashMap.find(count);\n            if(it!=hashMap.end()){\n                //存在\n                max_num = max(max_num,i - it->second);\n            }else{\n                //插入\n                hashMap.insert({count, i});\n            }\n        }\n        return max_num;\n    }\n};\n```'),(31,'专题四：并查集',3,'2021-06-08 08:25:46',27,'专门考察并查集的题目并不算多，与之前的专题相比，他不像是一类解决问题的思路，倒更像是一个工具，帮助我们给元素分组，分成不同的“帮派”，并可以方便的查找某两个元素是否是同一个组别中。  \n今天参加了一个ACM比赛，说实话自己接触算法不多，还是最近准备机试才开始刷题之旅，但从比赛的结果来看，确实也有很多的收获。最大的收获应该算是对于最近努力的肯定，让我有了更多的自信和坚持下去的动力。\n\n说回比赛，中间有一道题目，运用了克鲁斯卡尔生成树算法的思想，其中很重要的一部分是**并查集**的运用，在好容易完成代码的编写后提交却发现超时，换思路肯定是太费劲了，突然想到之前看到过不同的优化并查集的思路，于是当即翻出来加进代码，果然AC。第一次意识到是否优化代码的显著差别，时间差了将近十倍，也意识到了并查集优化的重要性，于是决定开专题将之前的学习笔记写下来，以便日后查阅。  \n\n## 并查集的目的\n简单的一句话——**元素分组**。  \n通过并查集，我们可以快速记录元素分组，并快速查询元素是否在统一分组中，这便是并查集最基础的使用目的。在克鲁斯卡尔算法中，我们用来判断是否当前剩下的最短边的起止结点在同一个连通分量中。  \n<img src=\"https://img.foril.fun/stickPicture.png\" width=700 alt=\"并查集\"/>\n而为了实现这一目的，要说到并查集的两个**基本操作**\n\n## 基本操作：\n1. 合并\n2. 查询\n\n这就是并查集的两个最基本的操作，通过这两个操作，我们就能实现对元素的分组操作。\n\n## 三个要素\n* 初始化  \n开始时，我们需要初始化将所有元素的根元素设为自己，也就是**每个元素自立帮派**。\n\n* 元素查询    \n要查询两个元素是否属于同一个分组，我们只需要查询他的根元素（**帮主**）是否是同一个人。  \n\n* 元素合并    \n相应的，要实现元素合并，就要选两个元素中的任意一个帮主，认另一个帮主作帮主（也就是当他的小弟！），这样我们之后查询两个元素的帮主应该就是同一个元素，我们也就认为他们是同一个分组。  \n\n我们直接上代码块理解并查集的这三个要素，实现了这三个要素，也就有了最基本的并查集，当然后期还有很大的优化空间。  \n\n* 初始化（每个人都做自己的帮主）\n```cpp\nint fa[MAXN];\ninline void init(int n)\n{\n    for (int i = 1; i <= n; ++i)\n        fa[i] = i;\n}\n```\n\n* 查询（递归）\n```cpp\nint find(int x)\n{\n    if(fa[x] == x) //如果帮主是自己\n        return x;\n    else\n        return find(fa[x]); //否则就去找帮主的帮主\n}\n``` \n\n* 合并\n```cpp\ninline void merge(int i, int j)\n{\n    fa[find(i)] = find(j);\n}\n```\n\n这样我们就写出了一个最基本的并查集，然而这个并查集还有很多需要优化的地方。\n\n## 优化\n### 问题一：路径太长（压缩路径）\n如果我们每次合并都只是单纯的让帮主认作别人的小弟，那么底下的小弟就需要通过多次查询才能找到自己真正的帮主，这就是这个并查集存在的第一个问题：**查询的路径太长**。    \n<img src=\"https://img.foril.fun/stickPicture%20(1).png\" alt=\"路径压缩\"/>  \n\n我们可以**压缩路径**来解决这个问题，如果有一个元素存在帮主，我们就在查询的过程中将他的父元素设置为他的帮主，这样在之后的查询过程中就可以一次查询到根元素。  \n体现在代码中就是查询的代码发生了变化：\n```cpp\nint find(int x)\n{\n    return x == fa[x] ? x : (fa[x] = find(fa[x]));\n}\n```\n<img src=\"https://img.foril.fun/stickPicture%20(2).png\"/>\n\n当然这样的解决方案存在一个小小的弊端，就是只有在第一次查询之后路径才会被压缩，而不是建立的时候就已经压缩完成。\n\n### 问题二：生成的树太高（按秩合并）\n之前在说到在并查集元素合并的时候，两个元素任意选择一个作为新的帮主，这就会引发一个问题，我们生成的查找分组的树可能会变的很高很不平衡，我们可以**引入一个新的数组**记录所有元素下面的层数（秩数），在合并时，只需要让秩数较小的元素认秩数大的元素为帮主即可；如果两个元素秩数相同，只需要一个认另一个帮主，再将新的帮主秩数加一即可。  \n<img src=\"https://img.foril.fun/stickPicture%20(3).png\" alt=\"按秩合并\" width=800/>\n#### 初始化加入变量\n```cpp\ninline void init(int n)\n{\n    for (int i = 1; i <= n; ++i)\n    {\n        fa[i] = i;\n        rank[i] = 1;    //引入新的变量\n    }\n}\n```\n\n\n#### 新的合并函数\n```cpp\ninline void merge(int i, int j)\n{\n    int x = find(i), y = find(j);    //先找到两个根节点\n    if (rank[x] <= rank[y])\n        fa[x] = y;\n    else\n        fa[y] = x;\n    if (rank[x] == rank[y] && x != y)\n        rank[y]++;                   //如果深度相同且根节点不同，则新的根节点的深度+1\n}\n```\n\n'),(32,'力扣刷题笔记（四）',1,'2021-06-17 12:16:29',70,'第四篇刷题笔记。\n## 494. 目标和\n### 题目　　\n\n给你一个整数数组 nums 和一个整数 target 。\n\n向数组中的每个整数前添加 \'+\' 或 \'-\' ，然后串联起所有整数，可以构造一个 表达式 ：\n\n* 例如，nums = [2, 1] ，可以在 2 之前添加 \'+\' ，在 1 之前添加 \'-\' ，然后串联起来得到表达式 \"+2-1\" 。\n返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n\n提示：  \n* 1 <= nums.length <= 20\n* 0 <= nums[i] <= 1000\n* 0 <= sum(nums[i]) <= 1000\n* -1000 <= target <= 100\n\n\n### 思路：\n#### 方法一：回溯\n这里我列出题目中的提示，重点是想说明题目要求的范围并不大，一共不超过20个数，所有数都是非负数且总和也没有超过1000，通过这样的提示，我们可以想到通过回溯解决问题，因为回溯的时间复杂度是 $O(2^n)$ ，所以只有在明确了题目中数字不会太大之后，我们才能考虑使用回溯方法。\n\n如果考虑使用回溯，那么这个题的思路就很明确了，定义出口是到了最后一个数字之后，否则分别考虑加减当前数字。\n\n```cpp\nclass Solution {\n    int res = 0;\n    void bt(vector<int>& v, int index, int target, int curr){\n        int len = v.size();\n        if(index==len){ //出口\n            if(curr == target) res++;\n            return;\n        }\n        \n        bt(v, index+1, target, curr+v[index]);\n        bt(v, index+1, target, curr-v[index]);\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        bt(nums, 0, target, 0);\n        return res;\n    }\n};\n```\n\n#### 方法二：动态规划\n同样因为这个题目中要求的范围很小，我们可以考虑通过动态规划解题，$dp[i][j]$表示通过前$i$个数可以得到$j$的方案数量，由此，答案所求即为$dp[n][target]$，状态转移方程为：  \n$$\ndp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]\n$$\n不过这里需要考虑的是，对每一个$i$，要检查**所有的** $j$，判断对 $i-1$ 得到的结果中能否得到$j-nums[i]$或是$j+nums[i]$，还要判断加减当前数字是否为越界。我们可以将状态转换方程，判断 $i-1$ 得到的结果中，不为一的数将他加减当前的数字。  \n\n另外要注意的是虽然总和不超过1000，但要考虑到如果全部是负号，会有-1000，所以需要开2001个空间加以映射。\n```cpp\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int* dp = new int[2001];//+1000\n        memset(dp, 0, 2001*sizeof(int));\n        int init = nums[0];\n        dp[init+1000] +=1;\n        dp[-init+1000] +=1;\n        int len = nums.size();\n        for(int i = 1;i<len;i++){\n            int* next = new int[2001];\n            memset(next, 0, 2001*sizeof(int));\n            for(int j = -1000;j<1001;j++){\n                if(dp[j+1000]>0){\n                    printf(\"dp[0][%d]>0\\n\",j+1000);\n                    next[j-nums[i]+1000] += dp[j+1000];\n                    next[j+nums[i]+1000] += dp[j+1000];\n                }\n            }\n            delete[] dp;\n            dp = next;\n        }\n        return dp[target+1000];\n    }\n};\n```\n\n\n## 31. 下一个排列\n### 题目　　\n\n实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须 原地 修改，只允许使用额外常数空间。\n\n示例 1：\n\n输入：nums = [1,2,3]  \n输出：[1,3,2]  \n示例 2：\n\n输入：nums = [3,2,1]  \n输出：[1,2,3]  \n示例 3：\n\n输入：nums = [1,1,5]  \n输出：[1,5,1]  \n示例 4：\n\n输入：nums = [1]  \n输出：[1]  \n\n\n### 思路：\n对于长度为 n 的排列 a：\n\n首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] < a[i+1] 。此时 [i+1,n)[i+1,n) 必然是下降序列。\n\n如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] < a[j] 。\n\n交换 a[i] 与 a[j] ，此时可以证明区间 [i+1,n) 必为降序。我们可以直接反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。\n\n官方简洁代码：\n```cpp\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int len = nums.size();\n        if(len==1) return;\n        auto it1 = nums.begin()+len-2;\n        auto it2 = it1+1;\n        while(it2!=nums.begin()){\n            if(*it1<*it2){\n                auto tmp = nums.end();\n                while(--tmp!=it1){\n                    if(*tmp>*it1){\n                        //交换\n                        swap(*it1,*tmp);\n                        break;\n                    }\n                }\n                sort(it1+1,nums.end());\n                return;\n            }\n            it1--,it2--;\n        }\n        sort(nums.begin(), nums.end());\n    }\n};\n``` \nPS:cpp自带api可以找到下一个字典序排序。  \n```cpp\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        next_permutation(nums.begin(), nums.end());\n    }\n};\n```\n\n## 33. 搜索旋转排序数组\n### 题目　　\n\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n示例 1：\n\n输入：nums = [4,5,6,7,0,1,2], target = 0  \n输出：4  \n示例 2：\n\n输入：nums = [4,5,6,7,0,1,2], target = 3  \n输出：-1  \n示例 3：\n\n输入：nums = [1], target = 0  \n输出：-1\n \n进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？\n\n### 思路：\n要求设计一个时间复杂度为$O(logn)$的算法，可以想到利用二分解决问题，但是本题目中的序列并不是有序的，好在题目是数组中的值各不相同，对任意一个下标的左侧或右侧必有一侧有序且可判断。  \n利用二分思想，找到中间点`mid`，如果左侧有序，判断目标在左侧有序范围内就更新右侧下标，不在左侧有序范围内，只可能在右侧，更新左侧下标，进入下一次循环。  \n同理如果右侧有序，判断目标在右侧有序范围内就更新左侧下标在右侧寻找，不在右侧有序范围内，只可能在左侧，更新右侧下标，进入下一次循环。  \n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int len = nums.size();\n        if(len==0) return -1;\n\n        int l = 0, r = len - 1;\n        while(l<=r){\n            int m = (l+r)/2;\n            if(nums[m]==target) return m;\n            if(nums[0]<=nums[m]){\n                //左侧有序\n                if(target>=nums[l] && target<=nums[m]){ //在左侧有序区间\n                    r = m - 1;\n                }else{  //只可能在右侧\n                    l = m + 1;\n                }\n            }else{\n                if(target>=nums[m] && target<=nums[r]){\n                    l = m + 1;\n                }else{\n                    r = m - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 16. 最接近的三数之和\n### 题目　　\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n示例：\n\n输入：nums = [-1,2,1,-4], target = 1  \n输出：2  \n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。  \n\n提示：\n\n* 3 <= nums.length <= 10^3  \n* -10^3 <= nums[i] <= 10^3  \n* -10^4 <= target <= 10^4  \n\n### 思路：\n最容易想到的自然是构造一个 $O(n^3)$ 复杂度的三重循环，寻找 `abs(a+b+c - target)` 的最小值，在题目中，数组长度为 $10^3$ ，这样的算法一般来说会超时，虽然我在力扣上试了一下，908ms居然都能AC。  \n更高效的想法是 **排序+双指针**，对整个数组进行升序排序，我们便可以利用排序的信息。\n遍历第一个数字`a`，后两个数字分别初始化为`a`后的最小的数`b`和最大的数`c`，接着判断`a+b+c - target`，若为负，将`b`右移，若为正，左移`c`，若等于零，可直接返回target，因为最接近的值必然是target。\n```cpp\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        int len = nums.size();\n        sort(nums.begin(),nums.end());\n        int recorder = INT_MAX;\n        int nearest = INT_MAX;\n        for(int i = 0;i<len-2;i++){\n            int j = i+1, k = len - 1;\n            while(j<k){\n                if(abs(nums[i]+nums[j]+nums[k]-target)<nearest){\n                    nearest = abs(nums[i]+nums[j]+nums[k]-target);\n                    recorder = nums[i]+nums[j]+nums[k];\n                }\n                if(nums[i]+nums[j]+nums[k]-target<0){\n                    j++;\n                }else if(nums[i]+nums[j]+nums[k]-target==0){\n                    return target;\n                }else{\n                    k--;\n                }\n            }\n        }\n        return recorder;\n    }\n};\n```\n实际上，每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 target 的值的关系，选择 **抛弃** 左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 11. 盛最多水的容器 中的双指针解法也是类似的。\n\n\n## 24. 两两交换链表中的节点\n### 题目　　\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1：\n\n输入：head = [1,2,3,4]  \n输出：[2,1,4,3]  \n\n示例 2：\n\n输入：head = [1,2,3]  \n输出：[2,1,3]  \n示例 3：  \n\n输入：head = [1]  \n输出：[1]  \n \n### 思路：\n之前说过做指针的题目重要的是理清思路一遍写完代码，这里先上自己的代码。\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode nullHead = ListNode(-1,head);  //加入一个空头指针\n        ListNode* l = head, * prev = &nullHead;\n        while(l!=nullptr){\n            ListNode* r = l->next;\n            if(r!=nullptr){\n                //交换\n                prev->next = r;\n                l->next = r->next;\n                r->next = l;\n                //更新l prev\n                prev = l;\n                l = l->next;\n            }else{\n                break;\n            }\n        }\n        return nullHead.next;\n    }\n};\n```\n官方有一种递归的解法，重要的是明白方法在栈中叠加，在回溯阶段解决问题的思路。\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);  //递归\n        //在回溯阶段解决问题\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n\n\n## 23. 合并K个升序链表\n### 题目　　\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n \n### 思路：\n最基础的思路就如同之前做过的两个升序链表合并，每次取出所有链表第一个元素中的最小值，然后构建新的链表。  \n在这里我们可以通过优先队列（最大堆）的数据结构来简化代码。  \n这里值得注意的是对`ListNode`做了包装，重载了小于号，使结构体能够直接作为优先队列的泛型，同时使最大堆成为最小堆。\n\n```cpp\nclass Solution {\npublic:\n    struct Status {\n        int val;\n        ListNode *ptr;\n        bool operator < (const Status &rhs) const {\n            return val > rhs.val;\n        }\n    };\n\n    priority_queue <Status> q;\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        for (auto node: lists) {\n            if (node) q.push({node->val, node});\n        }\n        ListNode head, *tail = &head;\n        while (!q.empty()) {\n            auto f = q.top(); q.pop();\n            tail->next = f.ptr; \n            tail = tail->next;\n            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});\n        }\n        return head.next;\n    }\n};\n```\n\n\n## 1530. 好叶子节点对的数量\n### 题目　　\n给你二叉树的根节点 root 和一个整数 distance 。\n\n如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。\n\n返回树中 好叶子节点对的数量 。\n\n提示：\n\n* tree 的节点数在 [1, 2^10] 范围内。\n* 每个节点的值都在 [1, 100] 之间。\n* 1 <= distance <= 10\n\n\n### 思路：\n这个题目比较有难度的是想到利用递归计算，因为题目中提示`distance<=10`这就给我们用一个数据结构记录他左右两部分不同距离的叶子节点数量的可能。\n\n我们通过递归，每一次向传递以当前节点作为根节点的距离在distance以内的叶子节点数量，同时传递当前节点以下的所有可能好叶子节点对数量。  \n这样，在每一次递归里，是需要计算左右孩子距离之和不超过distance的节点对数量，加上孩子节点传递的节点对数量再向上传递即可。  \n其中需要注意更新depths，阅读代码更能体会其中的思路。\n\n```cpp\n//递归\nclass Solution {\npublic:\n	pair<vector<int>, int> dfs(TreeNode* root, int distance) {\n		vector<int> depths(distance + 1, 0);\n		bool ifLeaf = !root->left && !root->right;\n		if (ifLeaf) {	//是叶节点\n			depths[0] = 1;\n			return make_pair(depths, 0);\n		}\n\n		//非叶节点\n		vector<int> leftDepths, rightDepths;\n		int leftCount, rightCount;\n		if (root->left) {\n			auto tmp = dfs(root->left, distance);\n			leftDepths = tmp.first;\n			leftCount = tmp.second;\n		}\n		if (root->right) {\n			auto tmp = dfs(root->right, distance);\n			rightDepths = tmp.first;\n			rightCount = tmp.second;\n		}\n\n		//更新depths\n		for (int i = 0; i < distance; i++) {\n			depths[i + 1] += leftDepths[i];\n			depths[i + 1] += rightDepths[i];\n		}\n\n		int count = 0;	//当前节点的左右孩子组合\n		for (int i = 0; i <= distance; i++) {\n			for (int j = 0; i+j+2 <= distance; j++) {\n				count += leftDepths[i] * rightDepths[j];\n			}\n		}\n		return make_pair(depths, leftCount + rightCount + count);\n	}\n\n	int countPairs(TreeNode* root, int distance) {\n		auto p = dfs(root, distance);\n		return p.second;\n	}\n};\n```'),(33,'01背包和完全背包',3,'2021-06-21 13:03:58',54,'一般来说，只要掌握了基本的 01背包问题 和 完全背包问题 就足够应付大多数面试。二者作为背包问题，区别就是对于物体的数量限制。\n## 01背包 和 完全背包 的区别\n01背包中不同物体只有一个，也就是说对于任一物体，只有选或不选两种选择，而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。  \n\n## 01背包\n有 N 件物品和一个最多能背重量为 W 的背包。第i件物品的重量是 weight[i]，得到的价值是 value[i]。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。  \n要素包括：  \n* N 件物品  \n* 容量为 W  \n* 重量列表 weight\n* 价值列表 value\n* 以及解决问题的前提：***每件物品只能用一次***，这也是01背包的关键特征  \n\n每个物品只能选或者不选，所以暴力解法的时间复杂度是 $O(2^n)$，指数级别。  \n所以需要动态规划来优化。  \n\n我们分别分析之前[动态规划专题](https://www.foril.space/article/21)中提到动态规划的要素：\n1. 找到合适的记录方式（确定dp数组以及下标的含义）  \n   典型的01背包，我们可以使用一个二维数组 $dp[i][j]$ 来表示到第 $i$ 个物品时容量为 $j$ 时背包的最大的价值。\n\n2. 找到状态转换方程  \n   根据记录方式,可以得到:  \n   $$\n    dp[i][j] = max\\{dp[i-1][j-weight[i]]+value[i], dp[i-1][j]\\}\n   $$\n   （这都得好好体会）\n3. 初始化  \n   根据记录方式，在 $j=0$ 时，背包的容量为 0，放不下任何物品，价值始终为 0，所以将 $dp[i][0]$ 赋值为 0。  \n   **注意**：常见的求最优解的背包问题中，有两种不太相同的问法。一种要求“恰好装满背包”时的最优解，一种则没有要求必须把背包装满。一种区别这两种问法的实现方法就是在初始化的时候有所不同。  \n   如果要求恰好装满背包，那么在初始化时除了 $dp[0][0]$ 为 0，其它 $dp[0][1..V]$ 均设为-∞，这样就可以保证最终得到的 $dp[M][N]$ 是一种恰好装满背包的最优解。  \n   如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 $dp[0][0..V]$ 全部设为0。  \n   可以这样理解： $j=0$ 时初始化的数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可能被价值为 0 的 `nothing` “恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。\n\n4. 找到运算顺序  \n   状态转换方程中都是通过当前的 $i,j$ 之前的结果得到的，所以 $i,j$ 都应该从小到大。\n\n之后便可以通过分析的结果运算01背包问题。  \n\n\n## 完全背包\n上面说到完全背包的物品数量是无限的，也就是说，有 N 种物品，每种物品有无限多个可以任取。  \n初始状态01背包和完全背包一致，当 i > 0 时 dp[i][j] 也有两种情况：  \n1. 不装入第i种物品，即dp[i−1][j]，同01背包；\n2. 装入第i种物品，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到dp[i−1][j−w[i]]而应该转移到dp[i][j−w[i]]，即装入第i种商品后还可以再继续装入第种商品。\n所以状态转换方程就是\n$$\ndp[i][j] = max\\{dp[i][j-weight[i]]+value[i], dp[i-1][j]\\}\n$$\n这个状态转移方程与01背包问题唯一不同就是max第一项不是dp[i-1]而是dp[i]。\n\n'),(34,'基于ALS协同推荐算法的简易购物推荐练习',1,'2021-06-28 07:44:13',57,'基于ALS协同推荐算法和SparkStreaming实时运算的的简易Kafka架构购物推荐练习。\n# 基于ALS协同推荐算法的简易购物推荐练习\n## 什么是ALS\nALS是交替最小二乘（Alternating Least Squares）的简称。  \n\nALS属于数据挖掘，可以做推荐系统，比如电影推荐、商品推荐、广告推荐等。  \n原理就是给各个指标，判定等加权重，然后将这些训练集输入ALS，包括其他的参数，内部进行矩阵相乘，根据这些权重，给用户未点击的商品也给一个分数，就是喜好程度。然后把喜好程度高的商品推荐给用户，假如用户不喜欢，从线上观察效果不好，那这个模型就有问题，需要修改参数，修改权重，或者添加权重，使之达到一个理想的效果!\n\n本项目做一个简易的基于ALS协同推荐算法的简易购物推荐练习，在只知道用户评分矩阵（即对于不同商品的评分）的情况下，向用户推荐商品。\n主要目的在于~~完成大作业~~ scala 的学习、MLlib的学习使用、sparkStreaming的学习使用等。\n\n## 开发流程\n### 架构搭建\n项目采用 Kafka 集群架构，Kafka能够提供消息队列，让生产者往队列的末尾添加数据，让多个消费者从队列里面依次读取数据然后自行处理。  \n> 但是，Kafka不仅仅是一套传统的消息总线，本质上Kafka是 **分布式的流数据平台**，因为以下特性而著名：  \n> 1. 提供Pub/Sub方式的海量消息处理。\n> 2. 以高容错的方式存储海量数据流。\n> 3. 保证数据流的顺序。\n\n![Kafka架构](https://img.foril.fun/kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpg)\n\n### 生产者模拟数据\n有了Kafka的存在，我们可以编写程序mock出模拟数据，这里我们只需要模拟用户ID，用户打分和对应的商品ID，利用一个线程池分别模拟数据，模拟出的数据作为生产者产出到我们的虚拟机上的Kafka集群中。（因为没有数据，同时我们也模拟出了用来训练模型的数据）  \n这一步注意需要提前在Kafka集群上建好topic：\n```\nkafka-topics.sh --create --partitions 3 --replication-factor 2 --topic rate --zookeeper node91:2181,node92:2181,node93:2181\n```\n![创建topic](https://img.foril.fun/%E5%88%9B%E5%BB%BAtopic.jpg)\n\n这里在模拟出数据了之后可以模拟消费者查看是否能够拉取到数据:\n```\nkafka-console-consumer.sh --bootstrap-server node91:9092,node92:9092,node93:9092 --topic rate --from-beginning\n```\n效果如图：\n![模拟消费者](https://img.foril.fun/%E6%A8%A1%E6%8B%9F%E6%B6%88%E8%B4%B9%E8%80%85.jpg)\n\n### 训练模型\n在下一步之前，我们可以通过之前模拟出的训练集，使用MLlib训练ALS模型并保存，这里我将模型保存在项目文件中，并将模型的地址保存在redis中。  \n将80%的模拟数据作为训练集，20%的数据作为测试集。（因为数据本身也是随机模拟，没有采用交叉验证）  \n\n### 利用模型实时推荐\n之后便可以在SparkStreaming中作为Kafka的消费者，对模拟出的每一个用户进行商品推荐了。推荐的结果可以按照需求存储，这里放入redis。\n\n![reids推荐结果](https://img.foril.fun/redis%E6%8E%A8%E8%8D%90%E7%BB%93%E6%9E%9C.jpg)\n\n项目后期加入[git仓库](https://gitee.com/foril/als_model_prac)，代码较草率，轻喷。\n'),(35,'初探符号执行',1,'2021-07-06 08:31:20',61,'符号执行技术在如今软件测试领域受到了越来越多的关注，现在已经在测试和查找各种软件中的错误方面证明是有效的，这些软件低至低级网络和操作系统代码，高至高级应用程序代码。很幸运在与老师的接触中，了解到了符号执行领域相关的知识，这篇文章记录在阅读了相关领域的文章后的一些学习笔记。  \n在阅读了帝国理工大学的 Cristian Cadar 的 [《Symbolic execution forsoftware testing: three decades later》](https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795)[1] 后，我对符号执行有了基本的认识，下面简述一下我的理解。  \n\n## 什么是符号执行\n符号执行是一种软件测试技术，从名字出发，大概意思是指利用符号而不是具体数值作为输入，进行代码的执行。  \n符号执行相关思想在上世纪八十年代就被提出，而在近代，随着约束可解性的进展，符号执行也得以蓬勃发展。其最核心的思想是利用符号值（*symbolic values*）代替具体的输入，从而将变量的值用基于符号的符号表达式（*symbolic expressoins*）来表达，最后得到的输出也是一个关于符号的函数。  \n\n### 能干什么\n作为一种软件测试技术，符号执行的关键目的是在给定的时间内探索（并检测）尽可能多的不同程序路径。  \n\n手动规范测试要求输入值是一笔很大的开销，且不能保证在测试期间观察到所有可能的行为。  \n为了改进观察到的行为范围（或测试覆盖范围），我们引入了各项技术，其中之一是随机生成潜在的测试数据，这种方法有着很明显的缺点：\n* 一是很产生很多结果相同的冗余用例\n* 二是想要尝试出会导致bug的输入用例的可能性非常小\n\n而另一种提出的方法就是我们要说的符号执行。如上文所说，在符号执行中，我们使用符号变量代替输入值来执行程序。程序中的每个条件表达式都表示一个确定执行路径的约束。其目标是为输入生成具体的值，从而导向不同的路径。选择路径的策略对分析的质量有很大的影响，经典的方法是使用通过回溯对路径的深度优先探索。\n\n而且符号执行具有能够生成高覆盖率测试用例和发现复杂应用中深层错误的特性，从生成测试用例和寻找程序缺陷两方面出发，符号执行的优势在于：  \n* 生成高覆盖率的测试用例\n* 提供触发bug的具体输入\n\n与其他程序分析技术相比，符号执行不限于查找缓冲区溢出等宽泛的错误，而是可以推理更高级的程序属性，如复杂的程序断言。\n\n## 传统符号分析\n在接触传统的符号分析之前，我们需要先明确几个概念。\n### 执行路径\n当我们在代码的执行过程中遇到程序分支时，我们将选择的布尔值连接，得到的就是我们走到当前路径点的执行路径，也就是说，执行路径就是一个由布尔值构成的序列，第`i`个值代表第`i`次分支的条件语句值。\n### 执行树\n执行路径通过树来表示。\n![执行树示意](https://img.foril.fun/%E6%89%A7%E8%A1%8C%E6%A0%91.jpg)\n\n这里注意图中绿色方块中代表的就是对应路径下的一个case。  \n而我们在符号分析的过程中的目标，就是希望通过 *constraint solver* 得到的具体值，关于这些会在下文继续说明。  \n\n有了以上概念的补充，接下来我们可以进入传统的符号执行技术的具体定义。   \n### 组成\n传统的符号执行主要包括两部分内容：  \n1. 一个符号状态 $\\sigma$ ：就是一个映射（函数），初始为空，存放**对应变量**在当前执行路径下的**表达式**（如 {z→2y, z→y}）\n2. 路径约束PC（*path constraint*）：针对对应执行路径下的路径限制，即需要满足的无量词一阶公式，初始为真。\n\n> 这里需要解释一下所谓**无量词一阶公式（quantifier-free first-order formula）**  \n> 根据维基百科，*First-order logic—also known as predicate logic* ，这里的first-order指的是一阶逻辑，也就是谓词逻辑，与零阶逻辑（命题逻辑）区别    \n> 在离散数学的知识中，我们知道谓词逻辑中有存在量词（existential quantifier）和全称量词（universal quantifier），这里的无量词，也就是在约束PC中不能包括量词  \n> 综合上面的定义，无量词一阶公式，就是将命题用逻辑连接词析取、合取、非连接即可（不包括量词）。\n\n我们在程序执行时，PC 和 $\\sigma$ 随着程序的执行而更新，在一条路径的尽头，用*constraint solver*来解出一个约束对应的具体值，即可作为当前路径的输入。*constraint solver* 作为另一个研究领域，这里不再详细讨论。  \n\n在路径中，每遇到一个条件判断（if），第一条路径为真，PC更新为 `PC ∧（命题为真条件）`，第二条为假，新增一个符号执行，加入 σ 并以 `PC ∧（命题为假条件）` 作为新的PC，这一步就是**约束收集**。直到路径出口或是遇到错误就可以利用 *constraint solver* 解出具体的值。\n\n### 基本实现\n关于基本实现的内容，我们可以在2010年卡耐基梅隆大学的一篇论文 [All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)](https://ieeexplore.ieee.org/abstract/document/5504796)[2] 中得到大概的认识，文中首先给出了一个简单语言 *SIMPIL* 的语法定义和操作语义。\n\n![语法定义](https://img.foril.fun/%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99.png)\n![操作语义](https://img.foril.fun/%E6%93%8D%E4%BD%9C%E8%AF%AD%E4%B9%89.png)\n![元语法变量](https://img.foril.fun/%E5%85%83%E8%AF%AD%E6%B3%95%E5%8F%98%E9%87%8F.png)\n\n上面三张图片定义的简单语言可以帮助我们更好地理解符号执行的具体方法，注意语法从下往上阅读。  \n要实现符号执行，我们只需要新加入一个上下文变量 $\\Pi$，记载当前路径下的约束；\n![加入变量](https://img.foril.fun/%E8%AF%AD%E6%B3%95%E5%8A%A0%E5%85%A5%E5%8F%98%E5%8C%96.png)\n\n同时执行语义加以简单变动，更新变量 $\\Pi$。  \n![更新变量](https://img.foril.fun/%E6%93%8D%E4%BD%9C%E8%AF%AD%E4%B9%89%E5%8F%98%E5%8C%96.png)\n\n文中通过这样的语言定义针对具体的例子给出了如何创造一个简单的符号执行引擎，并提出了遇到的问题和一些简单的解决方案，这里不再展开，感兴趣的读者可以自行阅读。\n\n另外，在具体的实现中还要注意在路径中遇到循环或是递归导致执行路径无限长的情况，需要加入限制，我们一般用超时、路径数量、循环迭代次数或探索的深度等指标加以限制，将无穷限制改为多个重复命题合取。  \n例：$N_i>0$为判断条件，当前的PC即可写为\n$$\n(\\bigwedge\\limits_{i\\in[1,n]}N_i>0) \\wedge(N_{n+1}\\leq0)\n$$\n### 限制\n在传统的符号执行中，所有输入都用符号代替，可能遇到的最大的限制就是约束不可求解的问题，这里举两个情况：\n1. 所执行的过程不可见（e.g.系统函数或闭源函数）；\n2. 所执行的过程不能被*constraint solver*计算，可以假设不能进行非线性的运算。\n\n以上两种情况，PC都不能被解出具体的数值，也就不能产生输出，为了解决这种问题，我们引出了现代的符号分析技术，以及其为了缓解不可解问题做出的取舍。　　\n***\n## 现代符号分析技术\n现代符号分析技术的重要特性就是**具体值和符号执行的混合**，也称动态符号分析技术。\n### Concolic测试：导向性随机测试（DART）\n以Concolic测试为例，在执行向下探索时，除了传统的符号状态 $\\sigma$，还会保存一个具体值的映射，映射的具体值也会在路径更新时通过 *constraint solver* 更新。  \n需要注意的是由于Concolic测试需要维护具体值，需要初始具体的值（指定或随机）。\n\n### 执行生成测试（EGT）\nEGT的本质还是具体值和符号执行的混合，他的具体操作方式是区分程序的具体状态和符号状态来工作：在每次执行前，检查值是否为具体的，如果是具体值，直接运算，否则，如果至少有一个值是符号值，就通过符号执行。  \n因此，在需要具体值时，EGT可以随时通过约束计算出一个具体值代入，这一点与Concolic测试**一直维护**一个具体值的映射做区别。  \n\n***\n综上，在现代符号执行技术中，由于采用了混合具体状态和符号状态，需要着重注意的一点就是如何做出**权衡**：  \n在与外界函数或者约束不可解的问题打交道时，动态符号执行采取的策略是利用具体值代替符号值，这样的问题就是可能会导致路径的丢失、完整性下降，所以必须要做出相应的权衡。\n\n## 挑战和一些解决方法\n在代码执行技术领域，目前遇到的主要挑战可分为以下四个：  \n### 路径爆炸\n这主要是指由于动态符号执行的过滤能力不足，程序中路径的指数型增长爆炸问题，当前比较流行的解决方案有：\n* 启发式技术对路径划定优先级  \n  主要利用随机探索或其他手段优先选择一些路径\n* 程序分析技术（减少程序复杂性）  \n  1. 静态合并一些路径，由于时间限制，具体采取的技术暂且不谈\n  2. 缓存和重用后续计算中的低级函数分析来改进符号执行，大概思想是重用类似属性的简单函数结果到复杂函数中（存疑）\n  3. 在路径探索过程中剪枝，删去冗余路径（如同一个程序点下约束相同的输入）\n\n### 约束求解\n\n上面说符号执行是在约束求解领域取得快速进展后快速发展，而实际上约束求解问题仍是现在符号执行领域最主要的瓶颈之一。  \n下面介绍两种具有代表性的优化：\n1. 不相关约束消除：  \n   对于当前分支约束求传递闭包，与**当前分支**无关的变量可忽视。\n2. 增量求解：  \n   **缓存**之前的限制和求解具体值，子集直接使用，超集判断是否可用（通常可用）。\n\n### 内存建模\n将程序语句转换为符号约束的精度会对符号执行实现的覆盖范围以及约束求解的可伸缩性产生显著影响。例如，使用实际整数代替内存中的定长证书数学模型可能有效，但可能会导致例如溢出等的边界用例的不精确问题。  \n\n还有对于指针问题的约束求解，一类代表是像DART这样的系统，它只解决具体指针的问题，或者像CUTE和CREST这样只支持指针的相等和不等的约束的系统，这类系统难题已被很好解决。另一类是EXE等使用数组理论来建模指针的基于STP或Z3这样的求解器实现的系统。\n\n同时应该非常注重在精度和约束求解的伸缩性之间的权衡，这种权衡常常基于被分析的代码的规模以及其处于系统中的层次。\n\n### 并发问题\n由于并发程序不确定性的内在属性，对并发程序的测试往往非常困难。尽管存在这些挑战，但动态符号执行已被有效地用于测试并发程序，包括具有复杂数据输入的系统、分布式系统和GPGPU应用程序。\n\n***\n以上就是代码执行技术领域，目前遇到的主要挑战。\n\n\n\n## 参考文献：\n[1]Cadar C, Sen K. Symbolic execution for software testing: three decades later[J]. Communications of the ACM, 2013, 56(2): 82-90.\n\n[2] Schwartz E J ,  Avgerinos T ,  Brumley D . All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)[C]// 31st IEEE Symposium on Security and Privacy, S&P 2010, 16-19 May 2010, Berleley/Oakland, California, USA. IEEE, 2010.\n'),(36,'在js中使用装饰器',1,'2021-09-11 03:13:50',22,'装饰器（Decorator）是一种与类相关的语法，用来注释或修改类和类方法。很多面向对象语言都有装饰器这种语法，值得注意的是，js并不是严格意义上的面向对象语言，称它是一种“*基于对象的语言*”应该更合适。在es5中，并没有太多对于装饰器的需求，但在es6中，随着class作为一种语法糖的出现，装饰器的便利性得到了体现，逐渐变得流行。\n\n## 装饰器的本质\n装饰器实质是上就是一段功能函数，放在类和类方法的定义前面，但不同于普通函数的是，它的**执行是在代码的编译阶段**，而普通函数的执行需要等到代码运行时，所以装饰器的实质是在**对编程语言进行编程**，属于元编程的一种思想。\n\n```js\n//使用示意\n@decorator_function\nclass ClassName{\n    ...\n}\n```\n\n## 装饰器的配置\n目前装饰器提案[[1]](https://github.com/tc39/proposal-decorators)处在Stage 2[2]，node以及各浏览器均不支持装饰器的语法，所以我们需要使用babel插`@babel/plugin-proposal-decorators`来转换代码。\n\n### 配置webpack\n如果使用webpack来打包项目，通过简单配置webpack就可以使项目支持装饰器语法。  \n\n首先下载webpack\n```bash\nyarn add -D webpack webpack-cli\n```\n下载babel依赖\n```bash\nyarn add -D babel-loader @babel/core @babel/preset-env @babel/plugin-proposal-decorators\n```\n创建`webpack.config.js`\n```js\n//webpack.config.js\nvar path = require(\'path\')\nmodule.exports = {\n    mode: \"development\",\n    entry: { main: \"./index.js\" },\n    output: {\n        path: path.resolve(__dirname, \"./build\"),\n        filename: \"build.js\"\n    }, module: {\n        rules: [\n            {\n                test: /\\.m?js$/,\n                exclude: /(node_modules|bower_components)/,\n                use: {\n                    loader: \'babel-loader\'\n                }\n            }\n        ]\n    }\n}\n```\n配置babel支持装饰器语法\n```json\n//.babelrc\n{\n    \"presets\": [\n        \"@babel/preset-env\"\n    ],\n    \"plugins\": [\n        [\n            \"@babel/plugin-proposal-decorators\",\n            {\n                \"legacy\": true\n            }\n        ]\n    ]\n}\n```\n在这里为了便于演示，简单修改package.json部分字段\n```json\n{\n    \"scripts\": {\n        \"build\": \"webpack\",\n        \"start\": \"node ./build/build.js\"\n    },\n}\n```\n接下来就可以在代码中使用装饰器语法了！\n> **PS**  \n> 如果使用VSCode做编辑器，可能会出现编辑器对装饰器语法依然报错的情况，可以在项目根目录下创建`jsconfig.json`配置VSCode对语法的支持。\n> ```json\n> //jsconfig.json\n> {\n>     \"compilerOptions\": {\n>         \"experimentalDecorators\":true,\n>     },\n>     \"exclude\": [\n>         \"node_modules\",\n>         \"dist/*\"\n>     ]\n> } \n> ```\n\n## 装饰器的常用写法\n装饰器 `@` 后必然需要接一个函数，这个函数需要带一个参数，也就是被装饰的类。  \n**需要注意的是`@`后的函数名带不带括号，带括号表示对函数的调用，调用的返回值不一定是函数**\n\n### 基础用法\n```js\n@fn\nclass MyClass{\n    message = \'hello\'\n}\n\nfunction fn(target){\n    //在类上加入静态属性\n    target.foo = \'bar\'\n}\n\n//注意是类的静态属性\nconsole.log(MyClass.foo)    //bar\n```\n\n### 加入参数的装饰器\n```js\n// 注意decorator后有没有括号，@后一定是一个函数\n@fn2(20)\nclass MyClass{\n    message = \'hello\'\n}\n\nfunction fn2(value){\n    //返回一个函数\n    return function(target){\n        target.count = value\n    }\n}\n\nconsole.log(MyClass.count)  //20\n```\n\n### 给类的实例加入属性\n```js\n@fn3\nclass MyClass{\n    message = \'hello\'\n}\n\nfunction fn3(target){\n    //target.prototype\n    target.prototype.foo = \'bar_ins\'    //给类的实例加入属性\n}\n\nconst c1 = new MyClass();\nconsole.log(c1.foo) //bar_ins\n```\n\n### 修饰类成员\n```js\nclass MyClass{\n    @fn4 message = \'hello\'\n}\n\n//修饰类成员，3个参数\nfunction fn4(target, name, descriptor){\n    console.log(target)             //目标类的.prototype\n    console.log(name)               //被修饰的类成员的名称:message\n    console.log(descriptor)         //被修饰的类成员的描述对象\n\n    //descriptor下有一些对成员的属性描述\n    descriptor.writable = false     //只读\n    descriptor.enumerable = false   //不能被遍历 \n}\n\nconst c1 = new MyClass();\nc1.message = 123    //error，不允许对只读属性赋值\n```\n\n## 参考：\n- [1] [ES6—Decorator，装饰器简介](https://zhuanlan.zhihu.com/p/55086365)\n\n\n## 注解\n\n> ## [2] TC39 Stage Process (TC39 的 Stage 阶段进程)\n> * 阶段 0：Strawperson 稻草人——代表目前仅仅是一个想法。  \n> * 阶段1: Proposal 提案——当想法变成提案，就需要进入阶段 1，面向委员会讲解和介绍，你需要概述解决方案，并且提出一些潜在的困难。委员会可能会接受你的提案，但并不代表就要在浏览器中生效。它仅仅是委员会觉得这是一个值得讨论的议题且愿意继续讨论。  \n> * 阶段2: Draft 草案——进入这一阶段的讨论会更加严肃，需要讨论具体的语法和语义的细节。你需要提供具体的解决方案，如何在语言中实现它，就像一个具体的 API 的实现。\n> * 阶段3: Candidate 候选——这个阶段设计的工作已经结束，你需要接受来自具体实现者和用户们的反馈。这个阶段也会有不同的 JavaScript 引擎来实现你的新特性。  \n> * 阶段4: finished 结束——一旦这个特性被添加进至少两个 JavaScript 实现并且通过具体的测试，代表着可以被大家使用了，提案的标准和规范也会进入到主要的标准规范中，我们会制定测试去保证未来的实现都会包含这项特性，也会添加参考文档。'),(37,'关于保研——我所知道的',2,'2021-09-13 13:31:35',77,'写下这篇文章时，我的夏令营早已结束，只是因为怠惰，没有当时及时写下自己的面试经历。先说我本人的情况，我很幸运地在夏令营阶段就拿到了心仪的offer，于是也决定放弃之后的预推免环节（主要是想提前躺平），所以八九月对我来说，是一个相当空闲的阶段，可以放开心去做一些自己想做的事情。这篇文章，我想从一下几个角度展开，跟有需要的学弟学妹说说我的经历和一些简单的经验：\n1. 什么是保研\n2. 我的夏令营经历\n3. 面试流程\n4. 经验心得\n\n想我自己在五六月临近保研季的时候，对整个保研流程仍是一窍不通，不知道什么是夏令营什么是九推十推，应该算是准备比较晚的，所以我觉得很多和我类似情况的学弟学妹首先最应该对保研的流程有一个大致的认识和心理准备。  \n## 什么是保研\n所谓保研，其实就是高校具有推荐免试生资格，国家下放推免名额，拿到推免名额的同学（也就是具有保研资格的同学）可以在9月28日至10月20日通过 [推免服务系统](https://yz.chsi.com.cn/tm/) 填报志愿、接收并确认招生单位的复试及待录取通知。目前全国共有300多所高校具有推荐免试生资格，不同的学校保研率不同，比如一般清北能有50%左右，一般的985高校能有20%左右，所以具体自己能否在大三学年结束的时候拿到推免名额就需要自己去详细查看学院的政策，大部分高校会参考学习成绩、优秀学生单项奖学金等方面下发推免名额，同时还有一部分专项保研名额，我们学校就有科创保研、支教保研等专项，不过这种专项保研可能会有只能保本校之类的限制。  \n所以一些在保研边缘不确定能否拿到推免名额的同学也可以大胆尝试，很多学校入营的条件都会对成绩放得很宽，可能只需要前30%就可以报名，哪怕没有拿到保研名额，这段推免经历也会在你成长过程中留下很深的印象。  \n\n所以这里产生的问题就是：学校要如何决定录取哪些学生？这就是夏令营和九推十推存在的意义，各个学校会举办自己的夏令营和推免活动来筛选优秀生源（抢人），得到学校认可的同学会得到学校发的**优秀营员**（一般就是拟录取资格，**具体查看学院通知**）。夏令营没有招满或是被咕咕咕的名额会在九月十月预推免（**九推十推**）时继续放出，当然也有很小一部分学校夏令营会超发（比如所谓*良好营员*），也就可能没有预推免活动。  \n夏令营一般会包括参观和考察等环节，很多学校会报销入营的学生的差旅费并解决夏令营期间的食宿问题（相当于简单的公费旅游，带一点考试的那种）。而九推十推就会直接一点，自己出钱去学校参加考试之后等待结果即可。\n\n需要说的是在填系统确认之前你和学校达成的所有协议都是一种契约精神，你可以向学校说明放弃名额，我的建议是拿到了更好的offer就一定及时释放确定不会去的offer，以免影响其他学校招生，恶劣的放鸽子行为可能会影响你的学弟学妹的保研。\n\n## 关于推免流程\n### 怎么准备\n夏令营的准备自然是越早开始越好，最好是四五月份就开始着手复习，能在六七月更加自信。以计算机、软件专业来说，夏令营、推免一般包括机试面试两部分。  \n#### 机试\n机试就是类似力扣类型，我之前也写了许多力扣博客作准备，可能有的学校机试还需要自己写IO，题型大差不差。个人感觉在力扣练习了大部分专题的中等难度题目也就足够了，一般刷200题以上，至少不会出现两眼一抹黑的情况，至于算法大佬（膜），这部分就不需要担心了。\n#### 面试\n面试一般会考察英语和专业，有的可能还会考察数学，我个人被问到了两次关于概率论的题目，都没有回答的很好。  \n英语一定是非常重要的一项，许多学校非常看重英语的水平，好看的四六级英语成绩会很吃香，有的学校面试会提前告诉你准备1分钟或3分钟自我介绍，还有可能会问不少其他问题。我认为应该提前准备并背熟不同时长几个版本的自我介绍，还有关于爱好、学校、喜欢的课程和家乡、朋友等主题的发言，就可以应付大多数学校的面试。  \n\n#### 专业\n想要又全面又细致地复习所有专业课程是不可能的，我的建议是重点复习408课程，其中数据结构与算法最为重要。同时还需要注意复习数据库等课程，需要承认在面试中运气的成分也很重要，认真地复习专业课能保证你不至于全程疯狂向老师道歉。  \n\n最后一点，也是最最重要的，一定要**足够自信**，有实力且足够自信，让老师看到你是个活生生的优秀的人，才更容易得到老师的认可。\n\n### 关于信息获取\n在夏令营中最容易忽视的就是信息的获取，而这却是是最重要的一点。应该提前关注自己选择的学校官网、研究生院等等网站及时获取信息，同时也有很多计算机保研人开辟的git仓库会同步很多学校的信息，着实在我的准备过程中产生了很大的帮助。\n\n![夏令营git仓库](https://img.foril.fun/%E5%A4%8F%E4%BB%A4%E8%90%A5git%E4%BB%93%E5%BA%93.jpg)\n\n### 关于整理\n开始前，应该尽早准备好自己需要的材料，包括各类证书和奖项、四六级证明、学生证身份证扫描件等等，尽量保证材料全面且随手可得（我自己采用了WPS云文件夹的形式，WPS在保研期间也发挥了很大的作用），才不会在需要时手忙脚乱焦头烂额。  \n\n同时关于自己心仪的学校通知信息，应该及时整理记录，每日检查，以防自己错过重要的时间点（会很懊悔）。使用excel就是一个不错的选择，我用腾讯文档记录了我关注的学校信息，既可以随时手机查看有很整齐。 ~~其实也挺乱~~\n\n![](https://img.foril.fun/%E6%B1%87%E6%80%BB1.jpg)\n![](https://img.foril.fun/%E6%B1%87%E6%80%BB2.png)\n\n此外，由于各个学校报名需要的材料内容不同，建一个文件夹按学校保存各个学校的材料也会让你省心不少。\n\n### 如何择校\n关于如何择校见仁见智，我认为多数人会考虑的因素会包括：\n* 学校的title\n* 学校所在城市\n* 联系的导师人品以及方向\n* 住宿宿舍条件\n\n具体以什么因素优先由自己决定，个人认为能找到一个非常喜欢的方向人好的强导最重要，但我选择的时候也还是兼顾到了学校title的因素。\n\n### 怎么联系导师\n联系导师当然也是趁早，毕竟一个萝卜一个坑，哪怕你非常优秀，心仪的导师联系晚了可能连回信都得不到。不过我并不建议所有学校都联系导师，毕竟跟老师沟通好了再咕咕咕对谁都不好，你也尴尬还有可能耽误老师招生。网上有很多联系导师的模板可以参考，下面是我联系导师的模板。\n```\n尊敬的xx老师：\n    您好，冒昧致信，请多包涵。\n    我叫xxx，是xx大学xx学院的2018级本科生。通过对自身学习成绩和综合素质的评估，预计我一定会获得推免资格。所以冒昧给您致信，希望能有机会攻读您的研究生。\n    下面是简单的自我介绍：我的加权绩点为xx，学院专业排名xx，六级成绩xx。在校获得多项奖学金，负责一项省级大学生创新训练项目，获得过包括xxxx的多项竞赛奖项。(一部分个人优势介绍)\n    在贵校首页看到您的个人主页，对您的研究方向非常感兴趣。我热切希望能有机会加入您的团队，在研究生阶段能得到您的指导！\n    附件中是我的个人简历和成绩单供您参考。\n    感谢您能在百忙之中阅信。诚盼老师的回复！\n    祝您身体健康，工作顺利！\n学生：xxx\n2021年x月x日\n```\n\n## 我的夏令营经历\n由于疫情，今年的夏令营也是线上的形式，估计是第二年搞线上学校学生都玩明白了，今年各学校疯狂抬高bar，所有学生疯狂海投（毕竟报名又不收费还基本不会冲突）。  \n首先说一下我的大概情况：成绩前3.6%（参营报名时用的前五学期成绩5.6%，所以能入营的基本5%差不多，面试基本都用的3.6%介绍自己），六级587，没有论文，没有出彩竞赛，项目也只有大创和算上这个博客，我报了十来个学校，和高考志愿大同小异，冲的稳的保的。等学校一个个出结果的过程是焦急的，不过到后面也就麻木了。我个人虽然入营不算多，但幸运的是入营的学校都拿到了优营，拿到一个优营以后也算是有了底气，之后的夏令营也就可以更加自信。    \n主要入营学校包括：  \n* 南京大学CS\n* 中山大学CS\n* 华东师范大学SE\n* 天津大学CS\n* 中南大学CS\n\n> 入营这东西比较玄学，每年学校情况都不太一样，只能作为参考，据说上届西交北理华科基本属于点击即送，于是我也打算西交北理保底，结果西交北理一个没过，着实是被搞了一把心态。\n***\n### 中南大学CS\n报中南大学是在西交大出结果的那天晚上，我一度怀疑自己是不是报高了一个档次，就报名了中南大学多一个保底。中南也是我参加的第一个开营的学校，常规的宣讲什么的也就挂个会议干自己的事。  \n中南要求联系老师考核，我联系的老师跟我约好当天下午面试，面试大概持续了20分钟，老师很认真，仔细研究了我的简历成绩单，专业问题问的不多，就是一些简单的机器学习问题，我虽然学的一般，但也勉强能应付，此外更多就是一些个人的情况，最后给了我三道机试题手写代码，一道是图，直接生套迪杰斯特拉即可，一道是简单的背包问题，最后一道和字符串有关，具体题目记不得了，只记得当时没有想到什么好的办法，反正是手写代码也不怕超时，就用类似遍历的方法写下来了。后来虽然获得了老师的推荐，不过因为之后接着得到了天大的认可，就连中南学校的面试都没有参加。\n***\n\n### 华东师范大学SE\n华东师范SE是出结果较早的几个学院之一，在软工学科中，华师大非常靠前，且中北校区地处魔都中心，这都是我考虑的几个因素，但同时需要说的是，华师大的考核也是我报名参加的所有学校中最烦心最耗时的一个。拿到入营资格后，需要首先联系导师，导师下发任务，在通过导师的考核任务和面试之后，再有一部分进入机试，机试筛选一部分后才能获得面试名额，面试又会筛选一半才能得到最后的结果。\n  \n为什么说他耗时，因为导师考核需要你看几篇导师的论文给导师做报告，假如一路顺利进入学院面试，又需要看另外的论文并做报告。这样下来，在你压力最大、时间最紧张的七月初，你要协调你的时间，在小学期课业、参加其他学校夏令营之余读论文做PPT展示。  \n为什么说他烦心，因为入营800进100，导师考核不知道筛选多少人，机试筛选至50人，面试之后只发25个offer，25个优营800人竞争，而且这期间每一个环节你都不知道自己能不能通过，但又不能不准备下一个环节，无疑是背负着巨大的心理压力的。  \n\n好的是我联系的导师是一位非常认真负责的老师，在这里不得不非常感谢华东师范大学苏亭老师，苏老师学术能力非常强，人好，在专业领域潜力无限，当时有很长一段时间我都想直接确定去找苏亭老师，最后也是经过许多考虑决定选择南大，也祝苏老师工作顺利。\n\n华师大的机试一小时，两道题，每道题十个用例，一个用例10分，共200分，一道题基本套用迪杰斯特拉稍稍优化即可，还有一道题当时不会做，现在也不记得了。至于面试，主要就是PPT自我介绍以及论文展示，还有一部分思想政治的考察，甚至问到了我遇到法轮功应该怎么办，正常回答，都比较顺利。\n\n总的来说，华师大SE实力强劲，但考察流程繁杂，竞争较激烈，毕竟只放出25个offer，不知道预推免会不会容易一些。\n***\n\n### 天津大学CS\n天津大学现在将CS和SE并入“*智算学部*”一起招生，没有机试，只有一个简单的面试，而且我选择的研究组应该算考察比较轻松，大概介绍了自己的情况，闲聊一会之后就拿到了老师的口头offer，相对很轻松，这里不再细说。\n***\n\n### 中山大学CS\n中山大学在今年的夏令营中超发了很多offer，印象中应该是只招收不到200人，但是刚入营的时候群上有600余人，后来随着机试面试的进行，大概退到400人左右。中山的考核流程就是属于中规中矩，机试加面试。\n机试共十道题1000分，三小时，难度力扣中等题，我也是老老实实三小时坐穿拿了490分，应该排名较后，根据学校后面的邮件，在学校超发的300多个优营中我排到了200-250名，所以机试的成绩还是相当重要的。  \n至于面试，是很多老师面试一个学生，除了简单的英文自我介绍以外，还让我用英文讲讲对学校的认识和选择中山大学的理由。专业问题不多，主要问了一些机器学习相关的知识和词汇，回答的不算很好，此外还问了两个概率相关的概念，一个回答上了一个印象不深，确实气氛有点尴尬。之后项目就算是个人比较有把握的部分，回答得都比较流畅，顺利结束。  \n\n虽然最后拿到了学校的offer，但排名并不是很靠前。不过我去中山大学的意愿也不是很强烈，也没有联系老师。\n***\n\n### 南京大学CS\n南大是我最想去的学校之一，也是我重点准备的学校，同时南大因为报名的人太多，也分了多轮考核，7月8号有第一轮线上考试，20道单选10道多选，全是408的内容，还有很多关于Linux的非常细致的问题，个人觉得有些题（尤其是多选题）难度还是挺高的，不过可能入营的标准不算特别高，我感觉我可能多选一个都不对，也顺利入营。  \n之后就是面试，本来南京大学应该是线下机试和面试，学校包夏令营几天的食宿，我连机票和前一天的酒店都订好了，结果由于南京突发疫情，又改回了线上，只有面试没有机试。记得当时是七月底，正值大连最热的几天，我决定等结束了所有夏令营再回家，学校的课程也已经结束，舍友也都回家了，好几天所有的活动都是围绕着南大的夏令营准备，确实是非常煎熬的一段日子，好在最终的结果是令人满意的。  \n\n面试是三个老师考察一个学生，面试开门见山，英语的自我介绍后，老师问我如果面对一个电脑小白，会向他介绍什么课程，为什么？我简单介绍了数据结构与算法的重要性以及主要内容和带给我个人的收获；之后下一个老师问我什么是动态规划，并让我举了一个具体的例子以及怎么用动态规划解决，好在这部分我之前写了博客准备，回答的比较到位；之后问到了项目，我之前都有所准备，老师问我前后端哪个做的比较多，以及对于前后端发展的看法，我从个人的角度发表了一些自己的看法；还问到了我学过哪些语言，觉得这些语言有什么区别，我就从编译型、解释型以及Java这种半编译半解释型的语言做了简单的对比和介绍；此外还有简单的个人性格考察，考察你遇到别人说你坏话后会采取什么样的应对的措施；之后老师问我什么是一个随机事件的期望和方差以及方差和协方差的区别，我回答后意识到自己没有从离散型和连续性分开说，不过也问题不大；之后还有一道面试经典题目：如何用5L的瓶子和3L的瓶子得到4L水，这个我之前有听过，比较顺利。  \n由于没有机试，面试的环节中还问到了不少机试题：\n* 2n+1个数中有n对相同的数和1个落单的数，如果得到这个数，我告诉他将所有的数异或即可；\n* 8个球中有1个球比其他的轻，最少几次可以得到这个轻的球。我当时说利用2分法3次可以得到，后来想到其实只针对8个球这个问题的话，有2次称重就可以找出的方法。\n***\n\n## 在最后\n说实话，真正经历过保研后才明白保研不比考研轻松多少，需要背负着巨大的压力去参加各种机试面试，可能好的一点就是不会在一棵树上挂死而且能比考研党早上岸，但是这背后承载着的，也是几年来自己一直不懈的努力。\n\n相信所有的付出都会得到回报，或早或晚。\n\nTHE END'),(38,'MobX与Redux',1,'2021-09-19 03:37:00',38,'Redux和MobX是当下较为流行的两个状态管理库，在复杂前端项目的状态管理中发挥了很大的作用，那么我们应该怎么使用它们，又该如何选择呢？本文记录一下学习过程中的笔记。\n## 什么是状态管理  \n当我们在使用React进行开发时，每个组件都有自己的状态可以管理，在简单的应用中，我们只需要组件管理好自己的状态，同时向下传递状态；而随着项目规模变大变复杂，在一些场景下，可能会出现一些比较棘手的组件间状态通信难题：\n* 多个组件间的状态共享\n* 组件触发其他组件的状态更新\n\n> React 只是 DOM 的一个抽象层，**并不是 Web 应用的完整解决方案**。有两个方面，它没涉及：  \n> 1. 代码结构\n> 2. 组件之间的通信\n\n\n按照React的设计思想，给出的建议是将公共状态提升，再需要的地方一层一层传递下来，但这样会使得代码臃肿而混乱，维护性极差；Redux和MobX这两个状态管理库，本质任务都是**解决状态管理混乱问题**，更好地管理状态，解决项目中常见到的一些组件间的状态通信问题。  \n\n> 如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。  \n\n## Redux\n再介绍Redux之前，不得不先介绍Flux。  \n\nFlux架构的概念由Facebook在2014年提出。不严谨地讲，它和MVC架构应该算同一个级别的东西。采用Flux组织你的前端应用开发，可以使你的数据组织更加清晰简单，更便于维护。  \n\nFlux 的最大特点，就是数据的\"单向流动\"。  \n\n![Flux的数据单向流动](https://img.foril.fun/bg2016011503.png)\n\n它将一个应用分成四个部分。\n* View： 视图层\n* Action（动作）：视图层发出的消息（比如mouseClick）  \n* Dispatcher（派发器）：用来接收Actions、执行回调函数（对应Redux的Reducer）  \n* Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面\n\n每个Action都是一个**对象**，包含一个actionType属性（说明动作的类型）和一些其他属性（用来传递数据）。Dispatcher 只能有一个，而且是全局的。  \n\n概括来说，整个数据流动过程包括用户与View交互，触发Action，这时Dispatcher监听到Action，根据Action的类型（ActionType）执行不同的回调函数，生成新的Store，Store在发生变动后，向View发出事件，实现数据和视图的同步。\n\nRedux就是对 *Flux* 与 *函数式编程* 的统一，与React结合，成为一时热门的前端解决方案。其特点是可预测（源于其纯函数的使用）、易调试（配合Redux DevTools），且能够与任何UI层搭配使用，使你的应用数据中心化。  \n\n## Redux的API使用\n对于Redux来说：\n1. Web 应用是一个状态机，视图与状态是一一对应的。\n2. 所有的状态，保存在一个对象里面。\n\n其基本组成与Flux对应，包括：\n### Store\nStore就是整个应用保存数据的地方，**整个应用只能有一个Store**。使用Redux，可以使用`createStore`这个函数生成Store。\n```js\nimport { createStore } from \'redux\';\nconst store = createStore(reducer);\n```\n`createStore`这个函数**接受一个Reducer**，生成Store。  \n（Reducer传入第一个参数默认值即是Store初始值，后面会提到。）\n\n下面是createStore的一个简单实现\n```js\nconst createStore = (reducer) => {\n  //本质是闭包\n  let state;\n  let listeners = [];\n\n  const getState = () => state;\n\n  const dispatch = (action) => {\n    state = reducer(state, action);\n    listeners.forEach(listener => listener());\n  };\n\n  const subscribe = (listener) => {\n    listeners.push(listener);\n    return () => {\n      listeners = listeners.filter(l => l !== listener);\n    }\n  };\n\n  dispatch({});\n\n  return { getState, dispatch, subscribe };\n};\n```\n此外，Store有三个重要的方法：\n* `store.getState()`  \n  Store对象包含所有数据。如果想得到某个时间点的数据，就要对 Store 生成快照。这种时间点的数据集合，就叫做 **State**。当前时刻的 State，可以通过store.getState()拿到。  \n* `store.dispatch()`  \n  是 **View 发出 Action 的唯一方法**，触发 Reducer 的自动执行，会在稍后的 Action 中提到。\n* `store.subscribe()`\n  Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数（比如更新视图的操作）；store.subscribe方法返回一个函数，调用这个函数就可以解除监听。\n  ```js\n  let unsubscribe = store.subscribe(() =>\n    console.log(store.getState())\n  );\n  unsubscribe();\n  ```\n\n### Action\nAction的本质其实就是一个对象，其中 `type` 属性是必选的，也可以自定义其他属性用来传递任意想要的数据。  \n```js\n//Action\nconst action = {\n  type: \'ADD_TODO\',\n  payload: \'Learn Redux\'\n};\n```\n当我们想要让Action携带不同的数据的时候（比如上面例子中的`payload`），就可以使用一个函数接收参数，返回一个携带了信息的Action，这样的函数就是 `Action Creator`。\n```js\nconst ADD_TODO = \'添加 TODO\';\n\n//Action Creator\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    payload: text   //将作为参数的text置入对象\n  }\n}\n//返回对象作为Action\nconst action = addTodo(\'Learn Redux\');\n```\n当视图层有所动作，需要触发Action时，需要使用`store.dispatch()`方法（**唯一方法**），将Action作为参数传入；`store.dispatch()`会触发Reducer的自动执行，得到更新后的State。\n```js\nimport { createStore } from \'redux\';\nconst store = createStore(fn);\n\nstore.dispatch({\n  type: \'ADD_TODO\',\n  payload: \'Learn Redux\'\n});\n```\n结合刚才提到的`Action Creator`你可以将代码写作：\n```js\nstore.dispatch(addTodo(\'Learn Redux\'));\n```\n### Reducer\nReducer可能是整个数据流动环节中最为重要的一环，负责根据Action的不同类型，执行不同的操作，更新State。  \n**Reducer的实质是一个函数。他接受当前State和一个Action作为参数，返回一个新的State。**  当没有最初始的State时，也就是第一次调用 Reducer 时，State采用传入的默认值，也就是State的初始值。\n```js\nconst defaultState = 0; //State初始值，以default的形式传给Reducer第一个参数\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case \'ADD\':\n      return state + action.payload;\n    default: \n      return state;\n  }\n};\n```\nstore.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。（串起来了）\n\n> 为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。（参数是state, action且返回新的state）请看下面的例子，一系列 Action 对象按照顺序作为一个数组。\n> ```js\n> const actions = [\n>   { type: \'ADD\', payload: 0 },\n>   { type: \'ADD\', payload: 1 },\n>   { type: \'ADD\', payload: 2 }\n> ];\n> \n> const total = actions.reduce(reducer, 0); // 3\n> ```\n> 上面代码中，0首先作为初始值，传入reducer，相当于`reducer(0, { type: \'ADD\', payload: 0 })`，返回新的state=0+0=0，返回的值0作为当前值，继续调用reducer，相当于`reducer(0, { type: \'ADD\', payload: 1 })`，得到新的state=0+1=1，以此类推。\n\n上面说到 Reducer 的本质是一个函数，这里需要注意的是，Reducer是一个**纯函数**，这就意味着，面对同样的输入，Reducer必然能得到同样的输出。  \n纯函数是函数式编程的概念，必须遵守以下一些约束：\n* 不得改写参数\n* 不能调用系统 I/O 的API\n* 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果\n\n也正因为此，Reducer 函数里面**不能改变 State，必须返回一个全新的对象**，请参考下面的写法。\n```js\n// State 是一个对象\nfunction reducer(state, action) {\n  return Object.assign({}, state, { thingToChange });   //用thingToChange覆盖原state中的key\n  // 或者\n  return { ...state, ...newState }; //同样是覆盖，返回的是全新的对象\n}\n\n// State 是一个数组\nfunction reducer(state, action) {\n  return [...state, newItem];   //返回的是全新的数组\n}\n```\n\n### Reducer的拆分\n整个应用只能有一个Store，这样会导致对于Reducer的管理非常冗杂，我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。\n```js\nconst chatReducer = (state = defaultState, action = {}) => {\n  const { type, payload } = action;\n  switch (type) {\n    case ADD_CHAT:\n      return Object.assign({}, state, {\n        chatLog: state.chatLog.concat(payload)\n      });\n    case CHANGE_STATUS:\n      return Object.assign({}, state, {\n        statusMessage: payload\n      });\n    case CHANGE_USERNAME:\n      return Object.assign({}, state, {\n        userName: payload\n      });\n    default: return state;\n  }\n};\n\n             |\n             | \n             | 改为\n             |\n            \\|/\n\nconst chatReducer = (state = defaultState, action = {}) => {\n  return {\n    chatLog: chatLog(state.chatLog, action),    //每个小的Reducer都返回一个小的state\n    statusMessage: statusMessage(state.statusMessage, action),\n    userName: userName(state.userName, action)\n  }\n};\n```\n\nRedux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。\n```js\nimport { combineReducers } from \'redux\';\n\nconst chatReducer = combineReducers({\n  chatLog,\n  statusMessage,\n  userName\n})\n\nexport default todoApp;\n```\n下面是combineReducer的简单实现。\n```js\nconst combineReducers = reducers => {\n  //返回的是一个大Reducer\n  return (state = {}, action) => {\n    //大Reducer返回的是所有的小state累加  \n    return Object.keys(reducers).reduce(\n      (nextState, key) => {\n        nextState[key] = reducers[key](state[key], action);\n        return nextState;\n      },    //accumulator\n      {}    //初始值\n    );\n  };\n};\n```\n### Redux工作流程\n附上Redux的工作流程\n![Redux工作流程](https://img.foril.fun/bg2016091802.jpg)\n## MobX\nMobX也是flux架构的一种实现，但是它凭借更简单的api和更快的速度，得到了很多人的追捧。MobX 是状态管理库中侵入性最小的之一。这使得 MobX的方法不但简单，而且可扩展性也非常好。React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。\n\n> Anything that can be derived from the application state, should be derived. Automatically.  \n> 任何起源于应用状态的数据应该自动获取。\n\nMobX的api非常间接也很符合直觉，如果项目支持装饰器语法，编写会更加简单高效，具体如何配置可参考 [在js中使用装饰器](https://www.foril.space/article/36) 。  \n\n### MobX的使用\n### 核心概念\n#### @observable\n通过使用 @observable 装饰器(ES.Next)来给你的类属性添加注解，可以使被注解的属性作为一个**可观察的状态**，可被外界观测到该状态的变化\n#### @observer\n通过@observer修饰你的组件，可以使组件观测到内部使用的可观测状态(observable)的变化，及时更新。\n#### @action\n通过@action可将你的函数变为一个**动作**，可在其中对状态进行修改，在严格模式下，只有动作才可以修改状态。  \n`action.bound`会绑定this。  \n`runInAction`函数：\n```js\nimport { runInAction } from \'mobx\'\nrunInAction(()=>{\n    store.count=10; //直接调用修改store\n})\n```\n\n#### @computed\n基于某些状态计算出的数据提炼为一个方法。**所依赖的可观测状态没有变化时，多次调用只会执行一次，计算结果会被缓存。（计算属性的好处之一）**\n```js\nimport { computed } from \'mobx\'\nclass Store{\n    @observable count = 0;\n    @computed get doubleCount(){\n        return this.count * 2;\n    }\n} \n```\n***\n### 监视数据\nMobX主要提供了三种方式监视数据：\n#### autorun\n在autorun内部使用到的可观测状态发生改变时，autorun会自动执行；同时autorun默认会在初始时执行一次。\n```js\nautorun(()=>{\n        console.log(store.count)    //依赖了store.count，发生变化时会执行（初始也会执行）\n    }\n)\n```\n\n#### when\n`when(predicate: () => boolean, effect?: () => void, options?)`  \nwhen 观察并运行给定的 predicate，直到返回true。 一旦返回 true，给定的 effect 就会被执行，然后 autorunner(自动运行程序) 会被清理。 该函数返回一个清理器以提前取消自动运行程序。\n```js\n//when两个参数，一个条件，一个操作\n//只会执行一次，若默认符合，一开始就执行\nwhen(\n    ()=>{\n        return store.count > 100\n    },\n    ()=>{\n        cconsole.log(\"条 件符合，进入\")\n    }\n)\n```\n\n#### reaction\nautorun 的变种，对于如何追踪 observable 赋予了更细粒度的控制。 它接收两个函数参数，第一个（**数据函数**）是用来追踪并返回数据，同时作为第二个函数（**效果函数**）的输入。不同于 autorun 的是当创建时效果函数不会直接运行，只有在数据表达式首次返回一个新值后才会运行。在执行效果函数时访问的任何 observable 都不会被追踪。\n```js\n//不同于autorun和when，只有当被观测的数据被改变的时候才会执行（没有autorun的第一次执行）\nreaction(\n    ()=>{\n        //业务操作，返回数据给下一个函数使用\n        return store.count\n    },\n    (countData, reaction)=>{    \n        console.log(countData)\n        reaction.dispose()  //停止当前reaction对数据的监听\n    }\n)\n```\n***\n接下来简单记录MobX的具体使用。\n### 安装\n```bash\nyarn add mobx\n# React 绑定库:\nyarn add mobx-react\n```\n### 初始化MobX容器仓库\n```js\nimport {observable, action} from \'mobx\'\n\nclass Store{\n    @observable count=0\n    @action.bound increment(){\n        this.count++\n    }\n}\n```\n\n### 在组件中使用MobX容器状态\n```js\nReactDOM.render(<App store={new Store()} />, document.getElementById(\'root\'))   //也可以使用Provider\n```\n### 组件中发起action修改容器状态\n```js\nimport {observer} from \'mobx-react\'\n\n@observer\nclass App extends React.Component{\n    render(){\n        const {store} = this.props\n        return(\n            <div>\n                <p>{store.count}</p>\n                <p>\n                    <button onClick={store.increment}>增加</button>\n                </p>\n            </div>\n        )\n    }\n}\n```\n### store间通信\n```js\n//aStore\nclass aStore{\n    @observable abc = []\n    @observable tmp = \'sdaf\'\n    constructor(rootStore){\n        //传入根store使能够找到其他store\n        this.rootStore = rootStore\n    }\n}\n\n//bStore\nclass bStore{\n    @observable asdf = []\n    @observable ddd = \'sdaf\'\n    constructor(rootStore){\n        this.rootStore = rootStore\n    }\n}\n\n//index\nclass rootStore{\n    constructor(){\n        //引入各个小的store\n        this.aStore = new aStore(this)\n        this.bStore = new bStore(this)\n    }\n}\n```\n\n### 将rootStore传递到所有组件\n```js\n//父组件\nimport { Provider } from \'mobx-react\'\nimport RootStore from \'./stores\'\n<Provider {...RootStore}>\n    <App />\n<Provider />\n\n//子组件\nimport { observer, inject } from \'mobx-react\'\n\n@observer\n@inject(\'StoreName\')    //把容器中的数据成员映射进来\nclass MyComponent{  \n    render(){\n        console.log(this.props.StoreName)\n        return(\n            ...\n        ) \n    } \n}\n```\n\n## MobX还是Redux\nMobX和Redux都是应用状态管理库，都适用于React，Angular，VueJs等框架或库，而不局限于某一特定UI库，在项目中应该如何选择呢？  \n从上面的笔记中也可以看出来，MobX的使用比Redux要方便许多，Redux需要写很多繁琐的action和reducer，而MobX是状态管理库中侵入性最小的之一。这使得 MobX的方法不但简单，而且可扩展性也非常好。  \n同时Redux对ts的支持比较困难，而MobX则完美支持ts。\n\n所以，MobX可能更适合在简单的、数据流不太复杂的中小型项目中，但这并不表示其不能支撑大型项目，关键在于大型项目通常需要特别注意可拓展性，可维护性，相比而言，规范的Redux更有优势，而MobX更自由，需要我们自己制定一些规则来确保项目后期拓展，维护难易程度；\n\n## 参考\n\n* [你需要MobX还是Redux？](https://www.cnblogs.com/zhouyangla/p/10165650.html)\n* [React官方文档Context](https://react.docschina.org/docs/context.html)\n* [阮一峰React 技术栈系列教程](http://www.ruanyifeng.com/blog/2016/09/)\n* [React 系列教程之 MobX](https://www.bilibili.com/video/BV1tL4y1h7ND?p=3&spm_id_from=pageDriver)');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `articlecate`
--

DROP TABLE IF EXISTS `articlecate`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `articlecate` (
  `cateID` int NOT NULL AUTO_INCREMENT,
  `cateName` varchar(255) NOT NULL,
  PRIMARY KEY (`cateID`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articlecate`
--

LOCK TABLES `articlecate` WRITE;
/*!40000 ALTER TABLE `articlecate` DISABLE KEYS */;
INSERT INTO `articlecate` VALUES (1,'学习笔记'),(2,'随笔而写'),(3,'力扣专题笔记');
/*!40000 ALTER TABLE `articlecate` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user` (
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES ('foril','WCX990824wcx'),('wrf','wangruifeng0001');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-10-10 11:42:49
