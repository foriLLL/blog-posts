第五篇刷题笔记，这篇笔记应该是参加南大夏令营前最后一篇刷题笔记，继续努力，一定会有回报。  


## 剑指 Offer 56 - I. 数组中数字出现的次数
### 题目　　
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]

### 思路：
其他数字出现两次，只有两个数字出现一次，很自然地想到`两个相同的数字异或为0`，记两个数字为`a`和`b`，可以通过这个方法抵消两个相同数字，整个数组全部异或的结果就是两个只出现一次的数字异或的结果`a^b`，我们需要分别列出`a`和`b`，那么显然还缺乏一个信息。官方题解的思路是**分组异或**，理解后确实觉得很妙。  
首先我们找到`a^b`最后一个1，也`a`和`b`最低位不同的数字。之后我们将这一位不同的数字单独异或，两组答案就分别是`a`和`b`了（相同的数字必在同一组）。
```cpp
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int ret = 0;
        for(int num:nums){
            ret^=num;
        }
        ret = ret^(ret&(ret-1));    //得到最后一位1的数
        int a = 0, b = 0;
        for(int num:nums){
            if(ret&num){
                a^=num;
            }else{
                b^=num;
            }
        }
        return {a,b};
    }
};
```

## 133. 克隆图
### 题目　　
给你无向`连通`图中一个节点的引用，请你返回该图的`深拷贝`（克隆）。

### 思路：
#### 方法一：DFS
对于本题而言，我们需要明确图的深拷贝是在做什么，对于一张图而言，它的深拷贝即构建一张与原图结构，值均一样的图，但是其中的节点不再是原来图节点的引用。因此，为了深拷贝出整张图，我们需要知道整张图的结构以及对应节点的值。　　
由于题目只给了我们一个节点的引用，因此为了知道整张图的结构以及对应节点的值，我们需要从给定的节点出发，进行**图的遍历**，并在遍历的过程中完成图的深拷贝。  

为了防止多次遍历同一个节点，陷入死循环，我们需要用一种数据结构记录已经被克隆过的节点。  
从给定节点开始遍历图。如果某个节点已经被访问过，则返回其克隆图中的对应节点。  


如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。**注意**：在进入递归之前，必须先创建克隆节点并保存在哈希表中。***如果不保证这种顺序，可能会在递归中再次遇到同一个节点，再次遍历该节点时，陷入死循环。***

```cpp
class Solution {
public:
    unordered_map<Node*, Node*> visited;
    Node* cloneGraph(Node* node) {
        if (node == nullptr) {
            return node;
        }

        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if (visited.find(node) != visited.end()) {
            return visited[node];
        }

        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        Node* cloneNode = new Node(node->val);
        // 哈希表存储
        visited[node] = cloneNode;

        // 遍历该节点的邻居并更新克隆节点的邻居列表
        for (auto& neighbor: node->neighbors) {
            cloneNode->neighbors.emplace_back(cloneGraph(neighbor));
        }
        return cloneNode;
    }
};
```

#### 方法二：BFS
要使用BFS，需要使用一个队列，保存接下来需要访问的节点，注意队列中每次取出的节点一定会给他加上所有的邻居（访问过的直接加入，没有的递归加入）。
```cpp
class Solution {
public:
    Node* cloneGraph(Node* node) {
        if (node == nullptr) {
            return node;
        }

        unordered_map<Node*, Node*> visited;

        // 将题目给定的节点添加到队列
        queue<Node*> Q;
        Q.push(node);
        // 克隆第一个节点并存储到哈希表中
        visited[node] = new Node(node->val);

        // 广度优先搜索
        while (!Q.empty()) {
            // 取出队列的头节点
            auto n = Q.front();
            Q.pop();
            // 遍历该节点的邻居
            for (auto& neighbor: n->neighbors) {
                if (visited.find(neighbor) == visited.end()) {
                    // 如果没有被访问过，就克隆并存储在哈希表中
                    visited[neighbor] = new Node(neighbor->val);
                    // 将邻居节点加入队列中
                    Q.push(neighbor);
                }
                // 更新当前节点的邻居列表
                visited[n]->neighbors.emplace_back(visited[neighbor]);
            }
        }

        return visited[node];
    }
};
```

## 102. 二叉树的层序遍历
### 题目　　
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
二叉树：[3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
```
返回其层序遍历结果：
```
[
  [3],
  [9,20],
  [15,7]
]
```

### 思路：
这个题如果不要求层序，直接使用一个队列输出即可，但是他要求按照层序组织成不同数组，那么我们需要保存每一层的数量，最初我的想法是保存当前层和下一层的数量，当前层每有一个孩子，下一层数量加一，当前层数量减为零时，开始遍历下一层，下一层数量作为当前层数量，下一层数量清零。  
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(!root) return {};
        int currNum=1, nextNum=0;
        queue<TreeNode*> que;
        que.push(root);
        vector<vector<int>> res;
        vector<int> once;
        while(!que.empty()||once.size()){
            if(currNum--){
                TreeNode* cur = que.front();
                que.pop();
                once.push_back(cur->val);
                if(cur->left){
                    nextNum++;
                    que.push(cur->left);
                }
                if(cur->right){
                    nextNum++;
                    que.push(cur->right);
                }
            }else{
                res.push_back(once);
                once.clear();
                currNum=nextNum;
                nextNum = 0;
            }
        }
        return res;
    }
};
```
看官方题解意识到其实每一层遍历结束时队列中剩余的节点数量，就是下一层的数量，只需要维护一个当前层的数量即可。  
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector <vector <int>> ret;
        if (!root) {
            return ret;
        }

        queue <TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int currentLevelSize = q.size();    //遍历完一层时队列剩余的数量就是下一层的数量
            ret.push_back(vector <int> ());
            for (int i = 1; i <= currentLevelSize; ++i) {
                auto node = q.front(); q.pop();
                ret.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        
        return ret;
    }
};
```

## 105. 从前序与中序遍历序列构造二叉树
### 题目　　
给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。

 Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  
Output: [3,9,20,null,null,15,7]

### 思路
可以使用分治的思想，把问题分解。其实这种问题自己手做的方法也就是类似一个分解的过程，分治也就是模拟了手做这种题目的过程。非常容易出错的十是各种各样的边界问题，一不小心就容易写错、越界。  
```cpp
class Solution {
public:
	TreeNode* my_buildTree(vector<int>& preorder, vector<int>& inorder, int pre_s, int pre_e, int in_s, int in_e) {
		if (pre_e - pre_s < 0) return nullptr;
		if (pre_e - pre_s == 0) return new TreeNode(preorder[pre_s]);
		int root_num = preorder[pre_s];
		int index = find(inorder.begin() + in_s, inorder.begin() + in_e, root_num) - inorder.begin();
		int left_size = index - in_s;
		int right_size = in_e - index;
		TreeNode * left = my_buildTree(preorder, inorder, pre_s + 1, pre_s + left_size, in_s, in_s + left_size - 1);
		TreeNode * right = my_buildTree(preorder, inorder, pre_s + left_size + 1, pre_e, index + 1, in_e);
		return new TreeNode(root_num, left, right);
	}
	TreeNode * buildTree(vector<int> & preorder, vector<int> & inorder) {
		return my_buildTree(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);
	}
};
```