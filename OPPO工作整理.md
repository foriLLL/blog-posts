## 关键字：

伪冲突、人类解冲突的本质（朝着实际解冲突的本质）、预训练、LSTM、迁移学习、RoBERTa、新的冲突解决建模方式（编辑脚本序列接受的分类）

非侵入式解决合并冲突，不需要改变 git 的任何东西，只需要在 git merge 之后，git commit 之前，使用我们的工具进行一次冲突解决即可。
利于实际落地

伪冲突原理 源码验证、自己编译 Git（replay） 查看分布 （伪冲突占 31.13%，其中 72.16% 都可以通过直接接受双方编辑脚本解决，ToDo 各个类别的占比）（231107）
其实伪冲突中空行冲突较多（25%左右，可能往往是 accept one side? 231107）

ToDo 以前的方法有什么问题：对流程改动大，token 粒度的决策在很多情况下会造成额外的识别负担，生成式方法丢失所有编码风格、缩进信息。而且之前的方法把预测为 newline 也算正确了（哪个工作？），我们的方法对于 newline 以外的所有类型解决率高。（但 vendor 合并基线的场景下，写新代码的解决类型应该本身就不多）
两种工作：自己合并（难以实际生产落地）、有冲突尝试解决（没有考虑解冲突的本质，大都从解决方案的类型分布建模）


之前的工作都默认认为一个冲突块就是两边的两个编辑针对相同的行造成合并冲突，但实际上，一个冲突块可能是两边的两个编辑针对不同的行，这些行可能有交集，也可能没有交集，这就是伪冲突（false positive），对于 Git 来说。
所以提出新的建模方式：针对每个编辑脚本，预测是否接受，对于 mixline 和 concat 类型效果不错，加入语义后对于 accept one side 等类型效果也不错


模拟人类解冲突的本质：
1. 识别准确，解决人员只需要 **识别双方编辑、尝试调和双方修改（全部采纳或者撰写新代码使编辑共存）或是选择其中一方接纳而拒绝接纳另一方**
2. 冲突块中元素匹配错误，需要人工定位识别具体变更
3. 其他情况相当少见

这么建模的一个前提假设是需要 git 匹配的行关系基本准确，而事实证明 git 使用的行粒度的匹配在大多数情况下还是可靠的，所以我们可以默认信任 git 的匹配结果，只需要关注合并双方修改的部分即可。（之后可以考虑针对不同语言，采用 AST match）这些内容可以算作未来工作

自己构建算法生成编辑脚本，使用回溯法（$O(2^n)$ 复杂度）分析接受编辑脚本解决问题的上界：不同类型的解决比例（不同数据集）
同时相邻的编辑脚本两种拼接方式都加入，探索 concatAB 和 BA<!-- ToDo 贴数据 -->
建模的局限性包括 concatAB 和 BA 无法区分，但实际发现大多是两个声明加在同一个位置，顺序与语义无关，且调整位置很简单

ToDo：阐述数据集收集规则
过滤了100行以上（大概率是匹配错误或大规模冲突，需要人工定位识别具体变更）
10个ES以上（只占很小一部分，但是计算慢）
strip 前后的空行。否则几乎所有 concat 都会被匹配到 mixline，综上，strip。这样会去除掉所有纯空白符冲突（约占 4 %，这部分理论上也可以用建模解决，但我们忽略，尽可能反映上界的真实性），如：'\n', ' \n', '\n\n', ' '
但与代码风格相关的空行（如两个函数声明间的空行会被保留），这样可以尽可能准确的生成编辑脚本
过滤 crlf/lf 导致的冲突
另外比较时对生成的内容，过滤空行比较，只比较语义内容

两个数据集不同类别占比分布差异大，但是每个类别伪冲突分布相当一致

各个类别可用这种建模方式解决（伪冲突或 one side）的比例  <!-- ToDo 贴数据 PPT上应该有比较详细的数据 -->

可以看出，mixline, concat 中伪冲突占比高，能用这种方式解决的占比高

<!-- 由于伪冲突的解决方法和编辑脚本的位置特征有非常大的关系，所以我们首先考虑加入位置特征，然后再加入语义特征，最后再加入语义特征和位置特征的交叉特征。

位置特征选取 7 个，自己的位置特征（起止行号、编辑前后行数、编辑前后行数差）解决成功率 33.65%，（231128）加入相对位置特征（只考虑前一个和后一个 last_start, last_end, next_start, next_end），解决成功率 68.23%（231129） -->

加入 LSTM，相当符合任务要求，准确率提升到（）
双向四层，可以考虑上下文，同时每个时间步一个输出，可以用来作为预测的特征，适合我们这个建模的场景

仅位置特征 69.84%，侧面说明伪冲突的占比以及位置特征对于解决冲突的重要性

加入语义信息、自己 embedding 以及 Code RoBERTa（其他预训练模型？）


跨仓库准确率？


对于上界以外的（尤其是 newline 类型的）工作（尝试调和实际的冲突）：分裂编辑脚本 + token 合并，上界能解决约 20% newline
编辑脚本分裂（基于相似度寻找匹配，阈值0.85，保证优化的 under-proximation，原则是可以不分裂，但希望分裂一定是准确的。规则过多过于复杂后，可能会导致模型准确率下降明显）
- 修改后的内容其实是 内容修改 + 新增
- 修改后的内容其实是 内容修改 + 删除
- 修改后的内容其实是 内容修改 + 删除
- A方的修改完全包含B方的修改，且B方修改内容在base对应内容在A中有匹配

newline 类型的冲突中 37.87% 可用 token 合并，其中 47.45% 正确解决，总正确率 17.97%，针对这一现象，我们将两边编辑脚本 base 范围相同且不为空的冲突采用 token 合并

在 LSTM 输出后加入 Attention 在送入 MLP

大模型的一些尝试

两种特征对不同类型效果好，能否尝试 bagging
可以使用注意力机制软对齐，做 CC embedding
